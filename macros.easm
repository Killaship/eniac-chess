# These define a basic language we use to specify "program" steps, 
# in the ENIAC sense of pulse-triggered operations, akin to microcode for the VM.

# RECeive on given input
defmacro rec inpr acc program input outpr
  p $inpr $acc.$programi
  s $acc.op$program $input
  p $acc.$programo $outpr
endmacro

# RECeive and do not (X) emit an output program pulse
defmacro recx inpr acc program input
  p $inpr $acc.$programi
  s $acc.op$program $input
endmacro

# RECeive and INCrement
defmacro recinc inpr acc program input outpr
  p $inpr $acc.$programi
  s $acc.op$program $input
  s $acc.cc$program C
  p $acc.$programo $outpr
endmacro

# RECeive and INCrement and do not (X) emit an output program pulse
defmacro recincx inpr acc program input
  p $inpr $acc.$programi
  s $acc.op$program $input
  s $acc.cc$program C
endmacro

# SEND and emit an output program pulse
defmacro send inpr acc program AorS outpr
  p $inpr $acc.$programi
  s $acc.op$program $AorS
  p $acc.$programo $outpr
endmacro

# SEND and do not (X) emit an output program pulse
defmacro sendx inpr acc program AorS 
  p $inpr $acc.$programi
  s $acc.op$program $AorS
endmacro

# SEND and Clear
defmacro sendc inpr acc program AorS outpr
  p $inpr $acc.$programi
  s $acc.op$program $AorS
  s $acc.cc$program C
  p $acc.$programo $outpr
endmacro

# SEND and Clear and do not (X) emit an output program pulse
defmacro sendcx inpr acc program AorS 
  p $inpr $acc.$programi
  s $acc.op$program $AorS
  s $acc.cc$program C
endmacro

# CLEAR accumulator
# triggered on inpr and emitting outpr when done (via transceiver t)
defmacro clear inpr acc program outpr
  p $inpr $acc.$programi
  s $acc.op$program 0
  s $acc.cc$program C
  p $acc.$programo $outpr
endmacro

# CLEAR accumulator and do not (X) emit an output program pulse
defmacro clearx inpr acc t
  p $inpr $acc.$ti
  s $acc.op$t 0
  s $acc.cc$t C
endmacro

# $manual-dummy program definition, with a given delay
# Use this to manually place a dummy program somewhere if needed.
defmacro manual-dummy inpr acc t delay outpr
  p {$inpr} $acc.{$t}i
  s $acc.op{$t} 0
  s $acc.rp{$t} $delay
  p $acc.{$t}o {$outpr}
endmacro

# Allocates an initiate unit clear transceiver for use as a dummy.
defmacro i-dummy inpr outpr
  p {$inpr} i.Ci{t-%name}
  p i.Co{t-%name} {$outpr}
endmacro

# Dummy to trigger outpr delay cycles after inpr
# Does not use a1-a5 nor other accums listed in exclude
# usage: $dummy-delay-exclude {p-in} 2 {p-out} -{a-foo},{a-bar},{a-baz}
#
# The defer directive delays output until the insert-deferred directive,
# which occurs after all accumulator programs are reserved.  This makes sure
# dummies do not claim otherwise necessary accumulator programs.
defmacro dummy-delay-exclude inpr delay outpr exclude
  defer allocate-dummy %name -a1,a2,a3,a4,a5 $exclude
  defer p {$inpr} {a-%name}.{t-%name}i
  defer s {a-%name}.op{t-%name} 0
  defer s {a-%name}.rp{t-%name} $delay
  defer p {a-%name}.{t-%name}o {$outpr}
endmacro

# Dummy to trigger outpr 1 cycle after inpr; does not use a1-a5
defmacro dummy inpr outpr
  $dummy-delay-exclude $inpr 1 $outpr -a1,a2,a3,a4,a5 
endmacro

# Dummy to trigger outpr delay cycles after inpr; does not use a1-a5
defmacro dummy-delay inpr delay outpr
  $dummy-delay-exclude $inpr $delay $outpr -a1,a2,a3,a4,a5
endmacro

# Dummy to trigger outpr 1 cycle after inpr
# Does not use a1-a5 nor other accums listed in exclude
defmacro dummy-exclude inpr outpr exclude
  $dummy-delay-exclude $inpr 1 $outpr $exclude
endmacro

# $discriminate
#
# Triggers outp if acc>=0 and outm if acc<0. Works by sending additively and
# subtractively on acc, with S(11) wired to outp and A(11) wired to outm.
#
# Note: any other programs on acc which send additively will trigger outm if
# A(11) is set, so care must be taken that acc is never negative during such
# programs to avoid mistriggering part of the discriminate sequence.
#
#   inp   - input program line
#   acc   - accumulator to wire for discrimination
#   dA,dS - data busses to use for acc.A acc.S
#   outp  - program line for acc>=0
#   outm  - program line for acc<0
defmacro discriminate inp acc dA dS outp outm
  p $inp $acc.{t-%name}i
  s $acc.op{t-%name} AS

  $discriminate-pm $inp $acc $dA $dS $outp $outm
endmacro

# Discriminate and clear
defmacro discriminatec inp acc dA dS outp outm
  p $inp $acc.{t-%name}i
  s $acc.op{t-%name} AS
  s $acc.cc{t-%name} C

  $discriminate-pm $inp $acc $dA $dS $outp $outm
endmacro

# Common PM steps for discriminate and discriminatec
defmacro discriminate-pm inp acc dA dS outp outm
  # acc >= 0 -> outp
  p $dS ad.dp.{ad-disc-%name-S}.11
  p ad.dp.{ad-disc-%name-S}.11 {p-%name-pm-S}
  $dummy-exclude {p-%name-pm-S} $outp -$acc

  # acc < 0 -> outm
  p $dA ad.dp.{ad-disc-%name-A}.11
  p ad.dp.{ad-disc-%name-A}.11 {p-%name-pm-A}
  $dummy-exclude {p-%name-pm-A} $outm -$acc
endmacro

# also need a version that delays for >1 cycles
# this one uses a transceiver to output a program pulse (passp) on both conditions
defmacro discriminatec-delay-passthru inp acc dA dS delay passp outp outm
  p $inp $acc.{t-%name}i
  s $acc.op{t-%name} AS
  s $acc.cc{t-%name} C
  p $acc.{t-%name}o $passp

  # acc >= 0 -> outp
  p $dS ad.dp.{ad-disc-%name-S}.11
  p ad.dp.{ad-disc-%name-S}.11 {p-%name-pm-S}
  $dummy-delay-exclude {p-%name-pm-S} $delay $outp -$acc

  # acc < 0 -> outm
  p $dA ad.dp.{ad-disc-%name-A}.11
  p ad.dp.{ad-disc-%name-A}.11 {p-%name-pm-A}
  $dummy-delay-exclude {p-%name-pm-A} $delay $outm -$acc
endmacro


# Convenience helper for making debug assertions
#   inp   - input program line
#   test  - an expression like {a-foo}~M00xxxxxxxx
defmacro assert inp test
  p $inp debug.assert.{%num}
  s debug.assert.{%num} $test
endmacro

# Convenience helper for making debug breakpoints
#   inp   - input program line
defmacro break inp
  p $inp debug.bp.{%num}
endmacro

# Convenience helper for dumping values for debugging
#   inp   - input program line
#   acc   - {a-foo}
defmacro dump inp acc
  p $inp debug.dump.{%num}
  s debug.dump.{%num} $acc
endmacro

# Connect two program lines via a pulse amplifier
#   inp   - input program line
#   outp  - output program line
defmacro pulseamp inp outp
  p {pa-a-%name} $inp
  p {pa-b-%name} $outp
endmacro
