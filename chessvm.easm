# ENIAC-VM for playing chess
# created 2020-3-30 by Jonathan Stray
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

# Accumulator layout

{a-pc}=a1
#    Program counter. A three level stack of 3 digit addresses, current PC on right. 

{a-ir}=a2
#    Instruction register. Holds up to 5 instructions queued to execute after
#    loading from a function table line. Rightmost instruction is next.
#    Instructions are stored in 9's complement form, to make it easy to detect
#    when the register is empty (adding 1 to 9999999999 flips the sign)

{a-ex}=a3
#   "Execution" register. Holds instruction to be executed and sends to decode.
#   Cleared before instruction execute starts, can be used as temp for instruction

{a-reg}=a13
#   (Register File) Registers A-E of the virtual machine. Use a13 so we can print it.

{a-ls}=a4
#   (Load/Store) Registers F-J of the virtual machine.

# Main data bus, used for most transfers
{d-main}=1

# Control cycle
# -------------
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute. 
# The basic pattern is from "Central Control for ENIAC", Adele Goldstine, 1947
# Control lines as follows:
#
# {p-fetch} begin fetch cycle
#      - clear EX
# {p-fetchcheck} do we need to fetch?
#      - discriminate on IR: M to nofetch, P to fetchline
#      - EX = IR
# {p-nofetch} no fetch needed, consume instruction
#      - IR(a2) = EX(a3)>>2 + 1
#      - goto 2-1
# {p-fetchline} no more instructons in IR, load new line from ft
#      - stimulate FT
#      - clear IR (should already be, but we may go to 1-4 after loading PC in jump instructions )
#      - clear EX
#      - delay 4 then goto {p-fetchread}
# {p-fetcharg} ft argument request
#      - FT <- bottom two digits of PC
# {p-fetchread} read ft line of instructions
#      FT sends complement of A and B
#      - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#      - EX = M 99 99 99 99 I1 = 99 99 99 99 A6A5 +1?
#      - PC += 1
#      - goto execute

# define a macro "clear" to clear accumulator acc,
# triggered on inp and emitting outp when done (via transceiver t)
defmacro clear inp acc t outp
p {$inp} {$acc}.{$t}i
s {$acc}.op{$t} 0
s {$acc}.cc{$t} C
p {$acc}.{$t}o {$outp}
endmacro

# -- {p-fetch} begin fetch cycle

# initiate button
p i.io {p-fetch}

# - clear a-ex
$clear {p-fetch} {a-ex} {t-fetch} {p-fetchcheck}

# -- p-fetchcheck: discriminate on IR: M to nofetch, P to fetchline
# During this cycle we both discriminate and read out the contents of IR into EX

# - Send on both ir.A and ir.S so one of two programs gets a pulse
p {p-fetchcheck} {a-ir}.{t-fetchcheck}i
s {a-ir}.op{t-fetchcheck} AS               
s {a-ir}.cc{t-fetchcheck} C   # clear IR after transmission
p {a-ir}.A {d-irA}
p {a-ir}.S {d-irS}

# IR < 0  -> {p-nofetch} via dummy program on a20
p {d-irA} ad.dp.{ad-irA}.11
p ad.dp.{ad-irA}.11 {p-irA}
p {p-irA} a20.{t-irA}i
p a20.{t-irA}o {p-nofetch}

# IR > 0 -> {p-fetchline} via dummy program on a20
p {d-irS} ad.dp.{ad-irS}.11
p ad.dp.{ad-irS}.11 {p-irS}
p {p-irS} a20.{t-irS}i
p a20.{t-irS}o {p-fetchline}

# EX = IR permuted, I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, assembled on d-ir-to-ex
# This puts the next instruction in the left of EX, ready to discriminate
p {p-fetchcheck} {a-ex}.{r-ir-to-ex}i   
s {a-ex}.op{r-ir-to-ex} {i-ir-to-ex}

# extract IR2,1 and shift to far left. 
p {d-irA} ad.s.{ad-ir-to-ex1}.8
p ad.s.{ad-ir-to-ex1}.8 {d-ir-to-ex}

# Shift the rest right, then drop the first two digits so the sign extend doesn't give 99
p {d-irA} ad.s.{ad-ir-to-ex2}.-2
p ad.s.{ad-ir-to-ex2}.-2 ad.d.{ad-ir-to-ex3}.-2 
p ad.d.{ad-ir-to-ex3}.-2 {d-ir-to-ex}

p {d-ir-to-ex} {a-ex}.{i-ir-to-ex}


# -- {p-nofetch} no fetch needed, begin instruction decode
# EX is now 100-I1 99-I5 99-I4 99-I3 99-I2
# Begin decode by adding 53 to EX, from constant transmitter

# Send 53 from CT to d-main
p {p-nofetch} c.26i 
s c.s26 Klr
s c.k10 5
s c.k9  3 
p c.o {d-main} 

# EX += d-main
p {p-nofetch} {a-ex}.{t-nofetch}i
s {a-ex}.op{t-nofetch} {i-nofetch}
p {d-main} {a-ex}.{i-nofetch}
p {a-ex}.{t-nofetch}o {p-disc-op}


# -- {p-disc-op} discriminate opcode I1>=53, to switch between two decode pathways
# Also store shifted instructions back to IR, this deletes just-dispatched opcode

p {p-disc-op} {a-ex}.{t-disc-op}i
s {a-ex}.op{t-disc-op} AS
p {a-ex}.A {d-exA}
p {a-ex}.S {d-exS}
p {a-ex}.{t-disc-op}o {p-decode}  # for now just print EX

# Store EX back to IR, with current opcode replaced by 99 (consume instruction)
# also add 1 to IR, to cause overflow if no more opcodes
p {p-disc-op} {a-ir}.{r-disc-op}i   
s {a-ir}.op{r-disc-op} {i-disc-op}

p {d-exA} ad.s.{ad-disc-op1}.2   # set EX 10,9 to 99 by shifting left 2 then right 2
p ad.s.{ad-disc-op1}.2 ad.s.{ad-disc-op2}.-2 
p ad.s.{ad-disc-op2}.-2 {a-ir}.{i-disc-op}
s {a-ir}.cc{r-disc-op} C          # add 1 to new I1, this is key to detecting no more opcodes


# -- {p-fetchline} no more instructons in IR, load new line from ft
# - stimulate FT, goto {p-fetcharg} for argument
# - delay 4 then goto {p-fetchread}

# - clear IR (not needed? already zero here from overflow?) and delay 4
$clear {p-fetchline} {a-ir} {t-fetchline} {p-fetchread}
s {a-ir}.rp{t-fetchline} 4    # repeat 4 to wait for FT result

# - clear EX as well, it will also receive from FT
p {p-fetchline} {a-ex}.{t-fetchline}i  
s {a-ex}.op{t-fetchline} 0
s {a-ex}.cc{t-fetchline} C

p {p-fetchline} f1.1i         # trigger ft
s f1.rp1 1                    # 1 repeat (neccessary?)
s f1.op1 S0                   # send complement, don't offset argument
s f1.cl1 C                    # pulse on C when done
p f1.C {p-fetcharg}           # goto when ready for argument


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)

# PC -> d2
p {p-fetcharg} {a-pc}.{t-fetcharg}i   
s {a-pc}.op{t-fetcharg} A
p {a-pc}.A 2                  # use d2 not mainbus because we're going through adapter (needed?)
p 2 ad.sd.{ad-fetcharg}.0     # bottom two digits of d2
p ad.sd.{ad-fetcharg}.0 f1.arg


# -- {p-fetchread} read ft line of instructions
#  - FT sends complement of A and B
#  - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = M 99 99 99 99 I1 = 99 99 99 99 A6A5+1
#  - PC += 1
#  - goto p-decode

p f1.A {d-f1A}
p f1.B {d-f1B}

# build up the re-ordered IR on d-main
# use deleters to prevent sign extension of 9s when isolating opcodes
# Simulator makes this a lot harder than it needs to be... in reality, 
# all this would be a single adapter with the pins soldered in permuted order.

p {d-f1A} ad.d.{ad-fr1}.-6          # A4A3
p ad.d.{ad-fr1}.-6 ad.s.{ad-fr2}.-2
p ad.s.{ad-fr2}.-2 {d-main}

p {d-f1A} ad.d.{ad-fr3}.-8          # A2A1
p ad.d.{ad-fr3}.-8 ad.s.{ad-fr4}.2 
p ad.s.{ad-fr4}.2 {d-main}

p {d-f1B} ad.d.{ad-fr5}.-4          # B6B5 digits don't move but must delete other digits
p ad.d.{ad-fr5}.-4 ad.s.{ad-fr6}.-4
p ad.s.{ad-fr6}.-4 ad.s.{ad-fr7}.4
p ad.s.{ad-fr7}.4 {d-main}

p {d-f1B} ad.d.{ad-fr8}.-6          # B4B3
p ad.d.{ad-fr8}.-6 ad.s.{ad-fr9}.-2
p ad.s.{ad-fr9}.-2 ad.s.{ad-fr10}.6
p ad.s.{ad-fr10}.6 {d-main}

p {d-f1B} ad.s.{ad-fr11}.8          # B2B1, don't need to delete left digits b/c we want M sign
p ad.s.{ad-fr11}.8 {d-main}

# B2B1 B4B3 B6B5 A2A1 A4A3+1 -> IR
p {p-fetchread} {a-ir}.{t-fetchread}i   
p {d-main} {a-ir}.{i-fetchread}     
s {a-ir}.op{t-fetchread} {i-fetchread}
s {a-ir}.cc{t-fetchread} C    # +1
p {a-ir}.{t-fetchread}o {p-decode}        # decode

# 99 99 99 99 A6A5+1 -> EX(a3)
p {p-fetchread} {a-ex}.{r-fetchread}i   
p {d-f1A} ad.s.{ad-fr12}.-4         # A>>4 to select first instruction, and pad with 9s
p ad.s.{ad-fr12}.-4 {a-ex}.{i-fetchread}
s {a-ex}.op{r-fetchread} {i-fetchread}
s {a-ex}.cc{r-fetchread} C    # +1

# PC += 1
p {p-fetchread} {a-pc}.{r-increment}i
s {a-pc}.op{r-increment} {i-nothing}    # nothing connected
s {a-pc}.cc{r-increment} C    # +1


# {p-decode} decode instruction in low two digits of EX

# decode magic here

# clear register file
$clear {p-decode} {a-reg} {t-decode} {p-printop}

# EX -> mainbus
p {p-printop} {a-ex}.{t-printop}i   
s {a-ex}.op{t-printop} A
p {a-ex}.{t-printop}o {p-printop2}

# mainbus -> REG
p {p-printop} {a-reg}.{r-printop}i
s {a-reg}.op{r-printop} {i-printop}
p {d-main} ad.d.{ad-printop}.-8 
p ad.d.{ad-printop}.-8 {a-reg}.{i-printop}
#p {d-exA} {a-reg}.a

# print "decoded" instruction, it's in a13
p {p-printop2} i.pi 
s pr.2 P
s pr.3 P





# ------------ DATA --------------

# function table values
s f1.RA0L6 0
s f1.RA0L5 1
s f1.RA0L4 0
s f1.RA0L3 2
s f1.RA0L2 0
s f1.RA0L1 3

s f1.RB0L6 0
s f1.RB0L5 4
s f1.RB0L4 0
s f1.RB0L3 5
s f1.RB0L2 0
s f1.RB0L1 6


s f1.RA1L6 1
s f1.RA1L5 1
s f1.RA1L4 1
s f1.RA1L3 2
s f1.RA1L2 1
s f1.RA1L1 3

s f1.RB1L6 1
s f1.RB1L5 4
s f1.RB1L4 1
s f1.RB1L3 5
s f1.RB1L2 1
s f1.RB1L1 6


s f1.RA2L6 2
s f1.RA2L5 1
s f1.RA2L4 2
s f1.RA2L3 2
s f1.RA2L2 2
s f1.RA2L1 3

s f1.RB2L6 2
s f1.RB2L5 4
s f1.RB2L4 2
s f1.RB2L3 5
s f1.RB2L2 2
s f1.RB2L1 6


s f1.RA3L6 3
s f1.RA3L5 1
s f1.RA3L4 3
s f1.RA3L3 2
s f1.RA3L2 3
s f1.RA3L1 3

s f1.RB3L6 3
s f1.RB3L5 4
s f1.RB3L4 3
s f1.RB3L3 5
s f1.RB3L2 3
s f1.RB3L1 6


s f1.RA4L6 4
s f1.RA4L5 1
s f1.RA4L4 4
s f1.RA4L3 2
s f1.RA4L2 4
s f1.RA4L1 3

s f1.RB4L6 4
s f1.RB4L5 4
s f1.RB4L4 4
s f1.RB4L3 5
s f1.RB4L2 4
s f1.RB4L1 6

