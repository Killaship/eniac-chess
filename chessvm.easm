s cy.op 1a

set a4  0444668800
set a5  9988776655

# memory values to check that various instructions save and restore
set a6  0606060606
set a7  0707070707
set a8  0808080808
set a9  0909090909
set a10 1010101010
set a11 1111111111
set a12 1212121212 
set a13 1313131313 
set a15 1515151515
set a16 1616161616
set a17 1717171717

# comment out these defines to disable the corresponding sequences
define RESET_SEQUENCE #  2 pas,  2 ts
define CONTROL_CYCLE  #  9 pas, 19 ts
define OP_SWAP        # 11 pas, 10 ts
define OP_LOADACC     #  3 pas, 22 ts
define OP_SWAPALL     #  3 pas,  3 ts
define OP_MOVXA       # 15 pas, 12 ts
define OP_MOVFA       #  4 pas,  6 ts
define OP_CLRA        #  1 pas,  1 ts
define OP_MOVIMMA     #  3 pas,  2 ts
define OP_INC         #  0 pas,  1 ts
define OP_DEC         #  0 pas,  1 ts
define OP_ADD         #  4 pas,  2 ts
# define OP_SUB         #  6 pas,  3 ts
define OP_JSR         #  2 pas,  5 ts
define OP_RET         #  2 pas,  3 ts
define OP_JMPFAR      #  4 pas,  4 ts
define OP_JMP         #  0 pas,  0 ts
define OP_JN          #  4 pas,  9 ts
define OP_PRINT       #  3 pas,  4 ts
define SUB_JMP        #  1 pas,  4 ts (OP_JMP, OP_JN)
define SUB_DISCFT     #  0 pas,  1 ts (OP_JSR, OP_RET, OP_JMPFAR)
define SUB_STARTJMP   #  1 pas,  1 ts (OP_JSR, OP_RET, OP_JMPFAR)
define SUB_FINISHJMP  #  4 pas,  1 ts (OP_JSR, OP_RET)
define SUB_CONSUME_OP #  2 pas,  2 ts (OP_JN, OP_MOVIMMA)
define SUB_CLEARA     #  3 pas,  1 ts (OP_MOVXA, OP_CLRA, OP_MOVIMMA)
define SUB_RFTOEX     #  2 pas,  0 ts (OP_SWAPALL, OP_MOVXA, OP_ADD)


# ENIAC-VM for playing chess
# Jonathan Stray and Jered Wierzbicki
# created 2020-3-30 
#
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute,
# and implements all the opcodes. The control cycle design is adapted from 
# "Central Control for ENIAC", Adele Goldstine, 1947
#
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

include macros.easm

# -- ACCUMULATOR LAYOUT --
# Defines all accumulators and patches to and from data trunks
# That patching encodes the possible permutations on acc inputs and outputs,
# as well as digit-to-program triggers for discrimination and 1-of-N decoding.
# Listed centrally here to make it easier to track allocation.

# Main data bus, used for most transfers
{d-main}=1

# macro to setup main bus connections - no "a-" before acc
defmacro acc-main acc
  p {a-$acc}.A {d-main}
  p {d-main} {a-$acc}.{i-main}
endmacro

# main bus connections for acc used for discrimination. We need to remove sign,
# and create another bus for the S output. Otherwise any sign pulse on d-main would
# trigger one of our discrimination programs. 
defmacro acc-disc-main acc
  p {a-$acc}.A {d-$accA}
  p {d-$accA} ad.permute.{ad-drop-$acc-sign}
  s ad.permute.{ad-drop-$acc-sign} 0,10,9,8,7,6,5,4,3,2,1
  p ad.permute.{ad-drop-$acc-sign} {d-main}

  p {a-$acc}.S {d-$accS}

  p {d-main} {a-$acc}.{i-main}
endmacro


# - Program counter -
# Layout: SS RRRR PPPP
# Current program counter PPPP and return address RRRR, plus a temp SS used for op decode
# Four digit address is FFLL: FF = which ft (09=ft1, 90=ft2, 99=ft3), LL = ft line

{a-pc}=a1
$acc-main pc

# A - mp steppers, op<=55
# S - mp steppers, op>55
# Decode needs the digits of the SS field to be swapped.
p {a-pc}.S ad.permute.{ad-swap-pc-ss-digits}
s ad.permute.{ad-swap-pc-ss-digits} 11,9,10,8,7,6,5,4,3,2,1
p ad.permute.{ad-swap-pc-ss-digits} {d-main}

# shiftl8 input: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
p {d-main} ad.s.{ad-pc-shiftl8}.8
p ad.s.{ad-pc-shiftl8}.8 {a-pc}.{i-shiftl8}

# clear A input: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
p {d-exS} ad.permute.{ad-exS-clearA}
s ad.permute.{ad-exS-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-exS-clearA} {a-pc}.{i-exS-clearA}

# loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
p {d-main} ad.d.{ad-pc-loadPC2}.-8
p ad.d.{ad-pc-loadPC2}.-8 {a-pc}.{i-loadPC2}

# loadPC4: SS RRRR PPPP -> 00 0000 PPPP, used for JMP FAR/JSR/RET
p {d-main} ad.d.{ad-pc-loadPC4}.-6
p ad.d.{ad-pc-loadPC4}.-6 {a-pc}.{i-loadPC4}


# Several sequences will want to load pc from the main bus so share that
# program via pulse amp
defmacro loadpc prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {a-pc}.{r-loadpc}i
endmacro
s {a-pc}.op{r-loadpc} {i-main}


# - Instruction Register -
# Layout: P I6 I5 I4 I3 I2
# Holds up to 5 instructions queued to execute after loading from a function
# table line. Fills in 99 from the left as instructions are executed. When empty, 
# this will be 9999999999 and then +1 flips to M0, easy to detect
# So we use the sign of IR to decide whether we need to fetch (discriminate on IR)

{a-ir}=a2
$acc-disc-main ir

# fetch input: from d-fetch, used for loading new line of instructions permuted from function table
p {d-fetch} {a-ir}.{i-fetch}

# fill99 input: replace top 2 digits of IR with 99, clear P/M
# the 99 comes from a constant M00000, the rest from EX sent on main
p {d-main} ad.permute.{ad-fill99-main}
s ad.permute.{ad-fill99-main} 0,11,11,8,7,6,5,4,3,2,1
p ad.permute.{ad-fill99-main} {a-ir}.{i-fill99}


# - Execution Register -
# Empty at the beginning of every opcode program
# Typically the only temp space in the machine, so used extensively to save
# contents of other accumulators while they are used functionally
# Also used to disc opcode >55

{a-ex}=a3
$acc-disc-main ex

# rotate-ir input: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2 for control cycle
# Shift the instructions right, then we execute and clear I1, removing one from the queue
p {d-main} ad.permute.{ad-ir}
s ad.permute.{ad-ir} 11,2,1,10,9,8,7,6,5,4,3
p ad.permute.{ad-ir} {a-ex}.{i-rotate-ir}

# clearA input: XX XX XX XX XX -> 00 XX XX XX XX, used in control cycle
p {d-main} ad.permute.{ad-ex-clearA}
s ad.permute.{ad-ex-clearA} 11,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-ex-clearA} {a-ex}.{i-clearA}

# clearPC2: SS RRRR PPPP -> SS RRRR PP00, used for JMP/JN/JZ/JIL
p {d-main} ad.permute.{ad-clearPC2}
s ad.permute.{ad-clearPC2} 11,10,9,8,7,6,5,4,3,0,0
p ad.permute.{ad-clearPC2} {a-ex}.{i-clearPC2}

# clearPC4: SS RRRR PPPP -> SS RRRR 0000, used for JMP FAR/JSR/RET
p {d-main} ad.permute.{ad-clearPC4}
s ad.permute.{ad-clearPC4} 11,10,9,8,7,6,5,0,0,0,0
p ad.permute.{ad-clearPC4} {a-ex}.{i-clearPC4}


# predefine programs that load ex from and store ex to main -- we use these everywhere
# go through pulseamps so other uses don't flow backwards
defmacro loadex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{r-loadex}i
endmacro
s {a-ex}.op{r-loadex} {i-main}

# loads EX with A field (digits 10 and 9) clear
defmacro loadex-clearA prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {a-ex}.{r-loadex-clearA}i
endmacro
s {a-ex}.op{r-loadex-clearA} {i-clearA}

# sends EX to main and clears
defmacro storeex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{t-storeex}i
endmacro
s {a-ex}.op{t-storeex} A
s {a-ex}.cc{t-storeex} C


# - Register File -
# Registers A-E of the virtual machine. A is our accumulator.
{a-rf}=a4
$acc-main rf

# RF.S is used to negate fields of RF for arithmetic.  Discard sign to avoid
# setting EX.PM to M, which might misfire discrimination.  A 1'p on digit 1
# might cause the E field to carry into D; we don't need -E so just don't
# connect digit 1.
p {a-rf}.S ad.permute.{ad-drop-rf-sign}
s ad.permute.{ad-drop-rf-sign} 0,10,9,8,7,6,5,4,3,2,0
p ad.permute.{ad-drop-rf-sign} {d-main}

# i-selBA input: XX aa XX XX XX -> aa 00 00 00 00, used for MOV BG,A
p {d-main} ad.permute.{ad-rf-selBA}
s ad.permute.{ad-rf-selBA} 11,8,7,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selBA} {a-rf}.{i-selBA}
$recx {p-rf-selBA} {a-rf} {r-rf-selBA} {i-selBA}

# i-selCA input: XX XX aa XX XX -> aa 00 00 00 00, used for MOV CH,A
p {d-main} ad.permute.{ad-rf-selCA}
s ad.permute.{ad-rf-selCA} 11,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selCA} {a-rf}.{i-selCA}
$recx {p-rf-selCA} {a-rf} {r-rf-selCA} {i-selCA}

# i-selDA input: XX XX XX aa XX -> aa 00 00 00 00, used for MOV DI,A
p {d-main} ad.permute.{ad-rf-selDA}
s ad.permute.{ad-rf-selDA} 11,4,3,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selDA} {a-rf}.{i-selDA}
$recx {p-rf-selDA} {a-rf} {r-rf-selDA} {i-selDA}

# i-selEA input: XX XX XX XX aa -> aa 00 00 00 00, used for MOV EJ,A/MOV #X,A
p {d-main} ad.permute.{ad-rf-selEA}
s ad.permute.{ad-rf-selEA} 11,2,1,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selEA} {a-rf}.{i-selEA}
$recx {p-rf-selEA} {a-rf} {r-rf-selEA} {i-selEA}

# load/store macros
$recx {p-loadrf} {a-rf} {t-loadrf} {i-main}
defmacro loadrf prog
  $pulseamp $prog {p-loadrf}
endmacro

defmacro send-rf prog
  $pulseamp $prog {a-rf}.{t-send-rf}i
endmacro
s {a-rf}.op{t-send-rf} A

defmacro sendc-rf prog
  $pulseamp $prog {a-rf}.{t-sendc-rf}i
endmacro
s {a-rf}.op{t-sendc-rf} A
s {a-rf}.cc{t-sendc-rf} C


# - Load/Store -
# Registers F-J of the virtual machine. 
{a-ls}=a5
$acc-main ls


# - MEM0 -
# Discriminate memory cycle 0-9 vs. 10-14
{a-mem0}=a6
{a-discmemcyc}=a6
$acc-disc-main discmemcyc

# splitA: Prepare A for disc A<10, and lookup in FT. A1 -> PM, A2 -> digit 1
p {d-main} ad.permute.{ad-discmemcyc}
s ad.permute.{ad-discmemcyc} 10,0,0,0,0,0,0,0,0,0,9
p ad.permute.{ad-discmemcyc} {a-discmemcyc}.{i-splitA}


# - MEM1 -
# Trigger mem cycle 10-14 on S outputs
{a-mem1}=a7
{a-memcyc1014}=a7
$acc-main mem1

p {a-memcyc1014}.S {d-memcyc1014S}

# i-ftselacc: get 10 digits from FT, for loadacc/storeacc
p {d-ftselacc} {a-memcyc1014}.{i-ftselacc}


# - MEM2 -
# Discriminate JZ, part 1
{a-mem2}=a8
{a-discjz1}=a8
#$acc-disc-main discjz1


# - MEM3 -
# Discriminate JZ, part 2
{a-mem3}=a9
{a-discjz2}=a9
#$acc-disc-main discjz2


# - MEM4 -
# Used for swap A,BCDE 
{a-mem4}=a10
{a-swapBCDE}=a10
$acc-main mem4

p {d-main} ad.permute.{ad-swapAB}
s ad.permute.{ad-swapAB} 11,8,7,10,9,6,5,4,3,2,1
p ad.permute.{ad-swapAB} {a-swapBCDE}.{i-swapAB}

p {d-main} ad.permute.{ad-swapAC}
s ad.permute.{ad-swapAC} 11,6,5,8,7,10,9,4,3,2,1
p ad.permute.{ad-swapAC} {a-swapBCDE}.{i-swapAC}

p {d-main} ad.permute.{ad-swapAD}
s ad.permute.{ad-swapAD} 11,4,3,8,7,6,5,10,9,2,1
p ad.permute.{ad-swapAD} {a-swapBCDE}.{i-swapAD}

p {d-main} ad.permute.{ad-swapAE}
s ad.permute.{ad-swapAE} 11,2,1,8,7,6,5,4,3,10,9
p ad.permute.{ad-swapAE} {a-swapBCDE}.{i-swapAE}


# - MEM5 -
{a-mem5}=a11
$acc-main mem5


# - MEM6 -
# Shift inputs and programs for shifting the PC for JSR/RET.
{a-mem6}=a12
{a-shiftpc}=a12

$acc-main mem6

# extract-pc input: XX XX XX PP PP -> 00 00 00 PP PP
p {d-main} ad.permute.{ad-extract-pc}
s ad.permute.{ad-extract-pc} 0,0,0,0,0,0,0,4,3,2,1
p ad.permute.{ad-extract-pc} {a-shiftpc}.{i-extract-pc}

# shiftr4-pc input: shift XX RRRR PPPP to 00 0000 RRRR
p {d-main} ad.permute.{ad-shiftr4-pc}
s ad.permute.{ad-shiftr4-pc} 0,0,0,0,0,0,0,8,7,6,5
p ad.permute.{ad-shiftr4-pc} {a-shiftpc}.{i-shiftr4-pc}

# shiftl4-pc input: shift XX XXXX PPPP to XX PPPP 0000
p {d-main} ad.permute.{ad-shiftl4-pc}
s ad.permute.{ad-shiftl4-pc} 0,0,0,4,3,2,1,0,0,0,0
p ad.permute.{ad-shiftl4-pc} {a-shiftpc}.{i-shiftl4-pc}


# - MEM7 - 
# MEM7 is a13 and is used for printing, has an input that shifts AB into printing position
{a-mem7}=a13
{a-print}=a13
$acc-main mem7

p {d-main} ad.permute.{ad-printAB}
s ad.permute.{ad-printAB} 11,0,10,9,8,7,0,0,0,0,0
p ad.permute.{ad-printAB} {a-mem7}.{i-printAB}


# - MEM8 -
{a-mem8}=a14
$acc-main mem8


# - MEM9 -
# Used for JN
{a-mem9}=a15
{a-discjn}=a15
$acc-disc-main discjn


# - MEM10 -
# Trigger mem cycle 0-9 on S outputs
{a-mem10}=a16
{a-memcyc09}=a16
$acc-main mem10

p {a-memcyc09}.S {d-memcyc09S}

# i-ftselacc: get 10 digits from FT, for loadacc/storeacc
p {d-ftselacc} {a-memcyc09}.{i-ftselacc}



# - MEM11 -
{a-mem11}=a17
{a-movfa}=a17
$acc-main mem11

# clearA input: aa bb cc dd ee -> 00 bb cc dd ee, used in MOV F,A
p {d-main} ad.permute.{ad-movfa-clearA}
s ad.permute.{ad-movfa-clearA} 11,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-movfa-clearA} {a-movfa}.{i-clearA}

# selectA input: aa bb cc dd ee -> aa 00 00 00 00, used in MOV F,A
p {d-main} ad.permute.{ad-movfa-selectA}
s ad.permute.{ad-movfa-selectA} 11,10,9,0,0,0,0,0,0,0,0
p ad.permute.{ad-movfa-selectA} {a-movfa}.{i-selectA}


# - MEM12 -
{a-mem12}=a18
$acc-main mem12


# - MEM13 -
{a-mem13}=a19
$acc-main mem13


# - MEM14 -
{a-mem14}=a20
$acc-main mem14


# - Function table decode -
# The PM digits of M18, M19, and M20 select the current function table for
# instruction fetch -- you can think of this as the current ROM bank. 
# The Function Table Selection Group (FTSG), so named by Adele, is the upper two
# digits of the PC and R registers. We use ft1 = 09, ft2 = 90, ft3 = 99.
# This is translated by p-sub-discft using the inputs below into PM=P on the
# selected ft, M otherwise. At fetch time we send on S on all three.

{a-discft1}=a18
{a-discft2}=a19
{a-discft3}=a20

defmacro discftaccum name ftnum
  # S.PM is wired to a dummy program to trigger an FT
  p {a-$name}.S ad.dp.{ad-$name-discft$ftnum}.11
  p ad.dp.{ad-$name-discft$ftnum}.11 {p-trigger-ft$ftnum-pm}
  $dummy-exclude {p-trigger-ft$ftnum-pm} {p-trigger-ft$ftnum} -{a-discft1},{a-discft2},{a-discft3}

  # i-ftsg1 puts the ftsg1 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg1}
  s ad.permute.{ad-$name-ftsg1} 3,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg1} {a-$name}.{i-ftsg1}

  # i-ftsg2 puts the ftsg2 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg2}
  s ad.permute.{ad-$name-ftsg2} 4,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg2} {a-$name}.{i-ftsg2}
endmacro

# Strictly speaking only discft3 needs both i-ftsg1 and i-ftsg2 inputs but we
# are not constrained on inputs for these accumulators.
$discftaccum discft1 1
$discftaccum discft2 2
$discftaccum discft3 3

# discft1 is also used to form intitial PC address on reset
# resetPC input: takes M0 from bus, sets initial PC to 0900
p {d-main} ad.permute.{ad-pc-reset}
s ad.permute.{ad-pc-reset} 0,0,0,0,0,0,0,0,11,0,0
p ad.permute.{ad-pc-reset} {a-discft1}.{i-resetPC}



# - Constant transmitter -
# So that we can use all the constant switches, connect both the left and the
# right 5 constant digits to the leftmost wires of d-main where they're needed.
# This is perhaps electrically questionable, but should work?  Provided the
# right constants are positive, there should be no bus conflicts - if they were
# negative, the constant transmitter would also drive 9s onto the same wires
# for sign extension.
p c.o ad.permute.{ad-constant-left}
s ad.permute.{ad-constant-left} 11,10,9,8,7,6,0,0,0,0,0
p ad.permute.{ad-constant-left} {d-main}
p c.o ad.permute.{ad-constant-right}
# (Delete sign so that eniacsim doesn't send two copies of the sign pulses...)
s ad.permute.{ad-constant-right} 0,5,4,3,2,1,0,0,0,0,0
p ad.permute.{ad-constant-right} {d-main}

# M99000 used in control cycle, DEC
s c.jl  M
s c.j10 9
s c.j9  9

# M00000 used in control cycle to fill consumed op with 99, machine reset
s c.kl  M
s c.k10 0
s c.k9  0

# whenever you need a 9 on the bus, call sendM0 (goes through a pulseamp)
defmacro sendM0 prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} c.25i
endmacro
s c.s25 Kl

# P43000 used in control cycle, to test opcode > 55. 43 = 99-55-1
s c.kr P
s c.k5 4
s c.k4 3

# P01000 used in control cycle, INC
s c.jr P
s c.j5 0
s c.j4 1


# - Setup MP as an opcode decoder -
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6

# This switch setting makes eniacsim disable/disassociate MP decade counters.
#
# Decade counters are a problem for decoding because they trigger a spurious
# extra step whenever they overflow, and they count in a data-dependent way on
# each program input (e.g. p.Ai, p.Bi, ...). Possibly some scheme could be
# devised to guarantee decade counters are safe before p.Ai for decode - they
# don't have an explicit clear control, but do clear on overflow.  But it's far
# simpler just to unplug the things.
#
# Associator switches on the MP front panel don't permit disconnecting decade
# counters, but the operating manual notes "To disassociate a decade from its
# stepper pull out gate tube 63 in the stepper plug-in unit. See block diagram
# PX-8-304."
s p.gate63 unplug

# Receive opcode at master programmer stepper direct inputs
p {d-main} ad.dp.{ad-opcode-10}.10   # opcode 10's digit (0x-5x)
p ad.dp.{ad-opcode-10}.10 p.Adi
p {d-main} ad.dp.{ad-opcode-9}.9     # opcode 1's digit (0x-5x)
p ad.dp.{ad-opcode-9}.9 p.Bdi
p ad.dp.{ad-opcode-9}.9 p.Cdi
p ad.dp.{ad-opcode-9}.9 p.Ddi
p ad.dp.{ad-opcode-9}.9 p.Edi
p ad.dp.{ad-opcode-9}.9 p.Fdi
p ad.dp.{ad-opcode-9}.9 p.Gdi        # opcode 1's digit (0x-5x) or 10's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Hdi      # opcode 1's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Jdi
p ad.dp.{ad-opcode-10}.10 p.Kdi

# Trigger the appropriate ones digit for opcodes <= 55
p p.A1o p.Bi
p p.A2o p.Ci
p p.A3o p.Di
p p.A4o p.Ei
p p.A5o p.Fi
p p.A6o p.Gi

if CONTROL_CYCLE
# For opcodes>55, Gi is triggered both by A6o when decoding 5x, and explicitly
# via a program control to decode the tens digit of 7x-9x.
$pulseamp {p-mp-789x} p.Gi
endif


# Wire the outputs to individual opcode programs
# outputs rotated with respect to digits as we decode I1+1
defmacro op-lines-le55 stepper tens
  p p.$stepper1o {p-op$tens5}
  p p.$stepper2o {p-op$tens0}
  p p.$stepper3o {p-op$tens1}
  p p.$stepper4o {p-op$tens2}
  p p.$stepper5o {p-op$tens3}
  p p.$stepper6o {p-op$tens4}
endmacro

$op-lines-le55 B 0
$op-lines-le55 C 1
$op-lines-le55 D 2
$op-lines-le55 E 3
$op-lines-le55 F 4
# G1o-G3o are used for 7x-9x.
p p.G4o {p-op52}
p p.G5o {p-op53}
p p.G6o {p-op54}

# Trigger the appropriate ones digit for opcodes >= 70.
p p.G1o p.Hi
p p.G2o p.Ji
p p.G3o p.Ki

# Rotated because we decode on PC.S for op>55, so this is 99-(OP+1) = 100-OP.
# TODO Confirm MP steppers increment from 6 to 1 - we're assuming so here for
# nicer opcode numbering.
defmacro op-lines-gt55 stepper tens
  p p.$stepper1o {p-op$tens2}
  p p.$stepper2o {p-op$tens1}
  p p.$stepper3o {p-op$tens0}
  p p.$stepper4o {p-op$tens5}
  p p.$stepper5o {p-op$tens4}
  p p.$stepper6o {p-op$tens3}
endmacro

$op-lines-gt55 H 9
$op-lines-gt55 J 8
$op-lines-gt55 K 7

if RESET_SEQUENCE

# -- RESET --
# Builtin clearing should first set all accumulators to 0
p i.io {p-reset}

# Reset PC, IR, and initial ft selector accumulators
# Send M00000
$sendM0 {p-reset}

# Set discft2/discft3 signs to M so that ft1 is selected via discft1.PM = P
$rec {p-reset} {a-discft2} {t-reset} {i-main} {p-reset-2}
$recx {p-reset} {a-discft3} {r-reset} {i-main}

# IR to M0 so we trigger a fetch
$recx {p-reset} {a-ir} {r-reset} {i-main}

# Set discft1 to 0900 which is the initial PC, then copy to PC (out of PC inputs)
$recx {p-reset} {a-discft1} {r-reset} {i-resetPC}

# Reset PC from discft1 and clear discft1
$sendc {p-reset-2} {a-discft1} {t-reset-2} A {p-fetch}
$loadpc {p-reset-2}

endif # RESET_SEQUENCE


if CONTROL_CYCLE

# -- CONTROL CYCLE --

# - A program line to jump to if ex has something in it
$clear {p-clearex-fetch} {a-ex} {t-clearex-fetch} {p-fetch}


# -- p-fetch: begin next instruction
# During this cycle:
#  - discriminate, to decide whether to fetch new instructions, clear IR
#  - read out the contents of IR into EX
#  - send next instruction (I1) to PC (assume PC.SS is 0)
$assert {p-fetch} {a-ex}~P0000000000
$assert {p-fetch} {a-pc}~x00xxxxxxxx

# If more instructions are needed, IR is M0, and control proceeds to p-fetchline.
# Otherwise, IR is P I5 I4 I3 I2 I1+1 and we trigger p-nofetch-eat-op.
$discriminatec {p-fetch} {a-ir} {d-irA} {d-irS} {p-nofetch-eat-op} {p-fetchline}

# IR -> EX 
# $discriminate sends IR on d-main, and EX receives it permuted I5 I4 I3 I2 I1+1
# -> I1+1 I5 I4 I3 I2.  This puts the next instruction in the left (first two
# digits) of EX. 
$recx {p-fetch} {a-ex} {r-fetch} {i-rotate-ir}

# IR -shiftl8-> PC
# Also send first opcode to left of PC. This copy of the instruction will later be
# sent to MP steppers for decoding.
$recx {p-fetch} {a-pc} {r-fetch} {i-shiftl8}



# -- {p-nofetch} no fetch needed, begin instruction decode
$pulseamp {p-nofetch-eat-op} {p-nofetch}
# PC has I1+1 at left
# EX is P I1+1 I5 I4 I3 I2
$assert {p-nofetch} {a-ex}~Pxxxxxxxxxx

# Begin decode by adding 43 to EX, from constant transmitter

# Send 43 from CT on d-main
p {p-nofetch} c.26i 
s c.s26 Kr

# EX += 43 for discrimination next cycle
# EX = I1+1
# If I1 <= 55 then I1+1+43 < 100, EX still P
# If I1 > 55 then I1+1+43 >= 100, EX now M
$rec {p-nofetch} {a-ex} {t-nofetch} {i-main} {p-disc-op}

# If we are eating an operand (removing it from IR) then we need to set
# the top digits of IR to 99 after next instruction (delay 1 cycle)
$dummy {p-nofetch-eat-op} {p-eat-op}


# -- {p-disc-op} discriminate opcode I1>55, to switch between two decode pathways
# EX starts P/M I1+44 I5 I4 I3 I2 and ends clear.
# Also store I5..I2 back to IR, replacing just-dispatched opcode with 99 if p-eat-op.
$assert {p-eat-op} {a-ir}~P0000000000

# Discriminate based on sign of EX, already set based on whether I1 > 55. Clear EX.
$discriminatec {p-disc-op} {a-ex} {d-exA} {d-exS} {p-ople55} {p-opgt55}

# If we are consuming from IR, store EX back into IR without the op we are now decoding.
# Replace first two digits with M from a constant, so the top of IR is
# P99. Finally, increment so that an empty IR, P9999999999, wraps to M0000000000.
# This also turns I2 into I2+1 at the right of IR.
$recincx {p-eat-op} {a-ir} {t-disc-op} {i-fill99}
# Send M00000 from the constant transmitter to fix IR.  EX doesn't send a sign
# on d-main so there's no bus conflict.
$sendM0 {p-eat-op}

# Clear MP prior to decode.  Clearing isn't synchronous, so this needs to
# happen "next cycle" i.e. during pulse 17 of p-disc-op.
$dummy {p-disc-op} {p-clear-mp}
p {p-clear-mp} p.Acdi
p {p-clear-mp} p.Bcdi
p {p-clear-mp} p.Ccdi
p {p-clear-mp} p.Dcdi
p {p-clear-mp} p.Ecdi
p {p-clear-mp} p.Fcdi
p {p-clear-mp} p.Gcdi
p {p-clear-mp} p.Hcdi
p {p-clear-mp} p.Jcdi
p {p-clear-mp} p.Kcdi


# -- p-ople55 - send tens digit of opcode to stepper A, ones digit to B-G
# Also PC->EX to begin clearing SS 
$assert {p-ople55} {a-ex}~P0000000000

# Send PC on main and receive in EX with SS (opcode field) clear.
$sendc {p-ople55} {a-pc} {t-ople55} A {p-ople55-2}
$loadex-clearA {p-ople55}


# -- p-ople55-2 - send input pulse to master programmer
# sign of EX must be P to avoid misfiring p-ople55
$assert {p-ople55-2} {a-pc}~P0000000000
$assert {p-ople55-2} {a-ex}~P00xxxxxxxx

# Send EX back to PC with opcode field clear to prep for instruction.
# Note that this would trigger the MP steppers, but the opcode field contains
# 00 here so this doesn't mess up decode.
$sendcx {p-ople55-2} {a-ex} {t-ople55-2} A
$loadpc {p-ople55-2}

# Trigger master programmer
p {p-ople55-2} p.Ai


# -- p-opgt55 - send tens digit to mp G stepper, ones digit to H-K
$assert {p-opgt55} {a-ex}~P0000000000

# Send PC subtractively on main, stepping the MP, and receiving in EX.
# Note that EX receives the 10's complement of PC, so will include an extra +1
# from the 1pp. This is undone when sending EX back to PC subtractively next
# cycle.
$sendc {p-opgt55} {a-pc} {t-opgt55} S {p-opgt55-2}
$loadex {p-opgt55}


# -- p-opgt55-2 - send input pulse to master programmer
# Sign of EX must be M to avoid misfiring p-ople55 (triggered from a-ex.S sign)
$assert {p-opgt55-2} {a-ex}~Mxxxxxxxxxx

# EX back to PC, with opcode field (SS) cleared
# Note #1: This is arithmetically incorrect. PC receives the 9's complement of
# EX with 0s in the opcode field, then an extra +1 from the 1pp. If PC were
# Pxx00000000, this would give P0099999999 and the 1pp would cause a carry into
# the opcode field leaving it P01... instead of P00. That can't happen because
# PC.PPPP always begins with 09, 90, or 99, so there's no possibility of a
# carry into digit 9.
# Note #2: EX.S is not connected to d-main. If it were, this would cause
# spurious MP inputs.
$sendcx {p-opgt55-2} {a-ex} {r-opgt55-2} S
$recx {p-opgt55-2} {a-pc} {r-opgt55-2} {i-exS-clearA}

# Trigger master programmer.
p {p-opgt55-2} {p-mp-789x}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# Trigger the currently selected FT to send
$send {p-fetchline} {a-discft1} {t-fetchline} S {p-fetchtrig}
$sendx {p-fetchline} {a-discft2} {r-fetchline} S
$sendx {p-fetchline} {a-discft3} {r-fetchline} S

# FT settings
defmacro triggerft num
  p {p-trigger-ft$num} f$num.1i
  s f$num.rp1 1                    # send once in r-fetchread
  # TODO switch to A+2 addressing to minimize overlap with accumulator decode
  s f$num.op1 A0                   # send uncomplemented, don't offset argument
endmacro
$triggerft 1
$triggerft 2
$triggerft 3


# -- {p-fetchtrig}
# FT is "stimulated" in this cycle, from discft1-3 S output
# Meanwhile, clear IR (needed only on jumps, otherwise already zero here from overflow)
$clear {p-fetchtrig} {a-ir} {t-fetchtrig} {p-fetcharg}

# wait 4 cycles until argument ready 
$dummy-delay {p-fetchtrig} 4 {p-fetchread}


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)
$send {p-fetcharg} {a-pc} {t-fetcharg} A {p-preinc-fetch}
p {d-main} f1.arg  # only bottom two digit lines connect so no deleter is required
p {d-main} f2.arg
p {d-main} f3.arg


# -- {p-preinc-fetch} preincrement left field of EX and PC
$assert {p-preinc-fetch} {a-ex}~P0000000000
$assert {p-preinc-fetch} {a-pc}~P00xxxxxxxx

# Send P01000 from the constant transmitter
p {p-preinc-fetch} c.28i
s c.s28 Jr

# Preload P01 into EX and PC so that when the FT sends I1, EX and PC will end
# up I1+1 which is the precondition in p-nofetch.
$loadex {p-preinc-fetch}
$loadpc {p-preinc-fetch}


# -- {p-fetchread} read ft line of instructions
#  - FT sends uncomplemented instructions on A and B
#  - IR = P I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = P I1+1 00 00 00 00 = A6A5+1 00 00 00 00
#  - PC = P I1+1 xx xx xx PC+1

# B2B1 B4B3 B6B5 A2A1 A4A3 -> IR
p f1.A {d-fA}
p f2.A {d-fA}
p f3.A {d-fA}
p {d-fA} ad.permute.{ad-fetchA}
s ad.permute.{ad-fetchA} 0,0,0,0,0,0,0,2,1,4,3
p ad.permute.{ad-fetchA} {d-fetch}

p f1.B ad.permute.{ad-fetchB}
p f2.B ad.permute.{ad-fetchB}
p f3.B ad.permute.{ad-fetchB}
s ad.permute.{ad-fetchB} 11,2,1,4,3,6,5,0,0,0,0
p ad.permute.{ad-fetchB} {d-fetch}

# Increment IR to make the rightmost instruction I2+1 instead of I2
$recincx {p-fetchread} {a-ir} {r-fetchread} {i-fetch}

# A6A5 00 00 00 00 -> EX,PC
p {d-fA} ad.permute.{ad-fetch-ex}
s ad.permute.{ad-fetch-ex} 11,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-fetch-ex} {d-main}

# Get I1+1 in the top of EX and PC, and increment PC
$loadex {p-fetchread}
$recinc {p-fetchread} {a-pc} {t-fetchread} {i-main} {p-nofetch}

endif # CONTROL_CYCLE


# -- MICRO-SUBROUTINES --
# Sequences shared between instructions, none of which retrigger the main cycle

if SUB_CONSUME_OP

# - CONSUME-OP -
# Consume opcode: used to read immediate operands
# Sends IR on first cycle, I1 can be read off as needed
# Rotates IR back to EX, shifts right, places 99 at left, adds 1
# This mimics how the control cycle works in microcosm

defmacro consume-op prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {p-sub-consume-op}
endmacro

$assert {p-sub-consume-op} {a-ir}~Pxxxxxxxxxx  # so fetch/nofetch discrim does not trigger

# IR -rotate-r-> EX
$sendc {p-sub-consume-op} {a-ir} {t-consume-op} A {p-sub-consume-op-2}
$recx {p-sub-consume-op} {a-ex} {t-consume-op} {i-rotate-ir}  # out of recievers

# EX -fill99-> IR 
# Put shifted instructions back in IR, filling top with 99, +1 to detect IR empty
$storeex {p-sub-consume-op-2}
$recincx {p-sub-consume-op-2} {a-ir} {r-consume-op-2} {i-fill99}

# fill99 requires an M0 on the bus
$sendM0 {p-sub-consume-op-2}

endif # SUB_CONSUME_OP


if SUB_JMP

# - JMP -
# Short jump (2 digits, no FT switch) to immediate operand

defmacro jmp prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {p-sub-jmp}
endmacro

# Clear lower digits of PC (not ftsg, this is a near jump)
# PC -clearPC2-> EX
$sendc {p-sub-jmp} {a-pc} {t-sub-jmp} A {p-sub-jmp-2}
$recx {p-sub-jmp} {a-ex} {t-sub-jmp} {i-clearPC2} 

# EX -> PC
$storeex {p-sub-jmp-2}
$rec {p-sub-jmp-2} {a-pc} {t-sub-jmp-2} {i-main} {p-sub-jmp-3}

# Copy next word in IR to PC, then fetchline. Because we jump, don't need to update IR
$sendx {p-sub-jmp-3} {a-ir} {r-send} A
$rec {p-sub-jmp-3} {a-pc} {t-sub-jmp-3} {i-loadPC2} {p-fetchline} 

endif # SUB_JMP


if SUB_DISCFT

# - DISCFT -
# The common receive portion of the sequence to select ft from PC ftsg
# Note that applying this twice is a NOP. So for far jumps (JMP FAR/JSR/RET)
# we invoke once with current PC, then update FTSG, and call again.

defmacro discft prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-discft}
endmacro

# Decode discft1 and discft2 signs
$recx {p-sub-discft} {a-discft1} {r-sub-discft} {i-ftsg2}
$rec {p-sub-discft} {a-discft2} {t-sub-discft} {i-ftsg1} {p-sub-discft-2}
$recx {p-sub-discft} {a-discft3} {r-sub-discft} {i-ftsg1}

# Finish decoding discft3 sign
$recx {p-sub-discft-2} {a-discft3} {r-sub-discft-2} {i-ftsg2}

endif # SUB_DISCFT


if SUB_STARTJMP

# - STARTJMP -
# Send PC twice and then clear it to load new PC, meanwhile deselecting current FT
defmacro startjmp prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-startjmp}
endmacro

$sendcx {p-sub-startjmp} {a-pc} {t-sub-startjmp} A
s {a-pc}.rp{t-sub-startjmp} 2
$discft {p-sub-startjmp}

endif # SUB_STARTJMP


if SUB_FINISHJMP

# - FINISHJMP -
# Send shiftpc twice, load pc, meanwhile selecting new ft, and then go to fetch
defmacro finishjmp prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-finishjmp}
endmacro

# Send shiftpc twice for discft to select new function table
$sendc {p-sub-finishjmp} {a-shiftpc} {t-sub-finishjmp} A {p-sub-finishjmp-3}
s {a-shiftpc}.rp{t-sub-finishjmp} 2
$discft {p-sub-finishjmp}
$loadpc {p-sub-finishjmp}

# Restore shiftpc from ex in parallel with p-fetchline
$storeex {p-sub-finishjmp-3}
$recx {p-sub-finishjmp-3} {a-shiftpc} {r-sub-finishjmp-3} {i-main}
$pulseamp {p-sub-finishjmp-3} {p-fetchline}

endif


if SUB_CLEARA

# - CLEARA -
# clear A register in RF
defmacro clearA prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-clearA}
endmacro

# RF -clearA-> EX
$sendc {p-sub-clearA} {a-rf} {t-sub-clearA} A {p-sub-clearA-2}
$loadex-clearA {p-sub-clearA}

# EX -> RF
$storeex {p-sub-clearA-2}
$loadrf {p-sub-clearA-2}

endif # SUB_CLEARA


if SUB_RFTOEX

# - RFTOEX -
# send RF, receive EX.  NB does not clear RF!
defmacro rf-to-ex prog
  p $prog {pa-a-%name}
  p {pa-b-%name} {p-sub-rftoex}
endmacro

$send-rf {p-sub-rftoex}
$loadex {p-sub-rftoex}

endif


# -- OPCODE IMPLEMENTATIONS --

#$break {p-op00}  # NOP
#$break {p-op01}  # SWAP A,B
#$break {p-op02}  # SWAP A,C
#$break {p-op03}  # SWAP A,D
#$break {p-op04}  # SWAP A,E
#$break {p-op10}  # LOADACC
#$break {p-op12}  # SWAPALL
#$break {p-op20}  # MOV B,A
#$break {p-op21}  # MOV C,A
#$break {p-op22}  # MOV D,A
#$break {p-op23}  # MOV E,A
#$break {p-op24}  # MOV F,A
#$break {p-op25}  # MOV G,A
#$break {p-op30}  # MOV H,A
#$break {p-op31}  # MOV I,A
#$break {p-op32}  # MOV J,A
#$break {p-op35}  # CLR A
#$break {p-op40}  # MOV #xx,A
#$break {p-op52}  # INC A
#$break {p-op53}  # DEC A
#$break {p-op70}  # ADD D,A
#$break {p-op72}  # SUB D,A
#$break {p-op73}  # JMP xx
#$break {p-op74}  # JMP xxxx
#$break {p-op80}  # JN xx
#$break {p-op84}  # JSR xxxx
#$break {p-op85}  # RET
#$break {p-op92}  # PRINT
#$break {p-op95}  # HALT


# - NOP -
p {p-op00} {p-fetch}


if OP_SWAP

# - SWAP A,[BCDE] -
# First two cycles of each instruction is per-op, last two cycles shared
# 1. per-op: swapBCDE->EX
# 2. per-op: RF-swapA[BCDE]->swapBCDE, this is where the actual swap is
# 3. shared: swapBCDE->RF  $memcyc4-2
# 4. shared: EX->swapBCDE  $memcyc4-3
# This uses 10 programs total, rather than 16 if we do all sequences separately

p {p-op01} {p-opswapAB}
p {p-op02} {p-opswapAC}
p {p-op03} {p-opswapAD}
p {p-op04} {p-opswapAE}

defmacro swapBCDE-op reg
  # swapBCDE->EX, save swapBCDE
  $sendc {p-opswapA$reg} {a-swapBCDE} {t-swapA$reg} A {p-opswapA$reg-2}
  $loadex {p-opswapA$reg}

  # RF->swapBCDE, on swap input -- actually does the swap
  $sendc-rf {p-opswapA$reg-2}
  $rec {p-opswapA$reg-2} {a-swapBCDE} {t-opswapA$reg-2} {i-swapA$reg} {p-opswapBCDE}
endmacro
$swapBCDE-op B
$swapBCDE-op C
$swapBCDE-op D
$swapBCDE-op E

# The rest of the swap sequence has to done with dummies, we used 8 transcievers
# We need to send+clear swapBCDE, and then restore it from d-main, but this is
# exactly the memory cycle sequence so reuse that (a-swapBCDE == a-mem4).
$pulseamp {p-opswapBCDE} {p-memcyc4-2}

# swapBCDE->RF, saves swapped values back to RF
$dummy-exclude {p-opswapBCDE} {p-opswapBCDE-2} -{a-swapBCDE}
# p-memcyc4-2 sends a-swapBCDE
$loadrf {p-opswapBCDE}

# EX->swapBCDE, restore swapBCDE
$dummy-exclude {p-opswapBCDE-2} {p-fetch} -{a-swapBCDE}
$storeex {p-opswapBCDE-2}
# p-memcyc4-3 receives a-swapBCDE

endif # OP_SWAP


if OP_LOADACC

# - LOADACC -
p {p-op10} {p-oploadacc}

# Wiring to send rightmost 10 digits of f3, plus PMA, to d-ftselacc
# used for loadacc, storeacc
# PMA A4A3 A2A1 B6B5 B4B3 B2B1 -> d-ftselacc
p f3.A ad.permute.{ad-decodeA}
s ad.permute.{ad-decodeA} 11,4,3,2,1,0,0,0,0,0,0
p ad.permute.{ad-decodeA} {d-ftselacc}
p f3.B {d-ftselacc}

# Create the memory cycle program for each acc
# Start with a dummy triggered from memcyc[09|1014].S. Delays one cycle (delay=2, as delay-2 
# means very next cycle when triggered from digit pulses). Then send/clear, then receive. 
# In this way the same program can be used for both load and store operations
defmacro memcyc-prog x range
  # TODO If we can trigger dummies at the same time as other programs on an
  # accumulator, then it should be fine to include a-memcyc09/1014.
  $dummy-delay-exclude {p-memcyc$x} 2 {p-memcyc$x-2} -{a-memcyc$range}
  $sendc {p-memcyc$x-2} {a-mem$x} {t-memcyc-2} A {p-memcyc$x-3}
  $recx  {p-memcyc$x-3} {a-mem$x} {r-memcyc-3} {i-main}
endmacro

# Patch one digit of d-memcyc09S to a send reciever program on mem0..mem9
# shift to get desired digit in 2 position, then use digit select adapter
# 2 position because 1 position always generates 1'P pulse on S send. This
# means trigger for 9 is stored in PM digit
defmacro select-memcyc09-acc x
  p {d-memcyc09S} ad.s.{ad-memcyc-$x}.-$x
  p ad.s.{ad-memcyc-$x}.-$x ad.dp.{ad-memcyc-dp$x}.2
  p ad.dp.{ad-memcyc-dp$x}.2 {p-memcyc$x}
endmacro

# Decode and allocate the memcyc programs for each acc
defmacro connect-memcyc09 x 
  $select-memcyc09-acc $x
  $memcyc-prog $x 09
endmacro

$connect-memcyc09 0
$connect-memcyc09 1
$connect-memcyc09 2
$connect-memcyc09 3
#$connect-memcyc09 4
$connect-memcyc09 5
$connect-memcyc09 6
$connect-memcyc09 7
$connect-memcyc09 8
$connect-memcyc09 9

# a-mem4 is also used for SWAP which needs all its t- programs, so memcyc4 must
# use r- programs with dummies elsewhere.
$select-memcyc09-acc 4
$dummy-delay-exclude {p-memcyc4} 2 {p-memcyc4-2} -{a-memcyc09},{a-mem4}
$sendcx {p-memcyc4-2} {a-mem4} {r-memcyc-2} A
$dummy-exclude {p-memcyc4-2} {p-memcyc4-3} -{a-memcyc09},{a-mem4}
$recx {p-memcyc4-3} {a-mem4} {r-memcyc-3} {i-main}


# similar for 10-14
defmacro select-memcyc1014-acc x minus10
  p {d-memcyc1014S} ad.s.{ad-memcyc-$x}.-$minus10
  p ad.s.{ad-memcyc-$x}.-$minus10 ad.dp.{ad-memcyc-dp$x}.2
  p ad.dp.{ad-memcyc-dp$x}.2 {p-memcyc$x}
endmacro

# Decode and allocate the memcyc programs for each acc
defmacro connect-memcyc1014 x minus10
  $select-memcyc1014-acc $x $minus10
  $memcyc-prog $x 1014
endmacro

$connect-memcyc1014 10 0
$connect-memcyc1014 11 1
$connect-memcyc1014 12 2
$connect-memcyc1014 13 3
#$connect-memcyc1014 14 4


# Start by saving DISCMEMCYC -> EX, clear
$sendc {p-oploadacc} {a-discmemcyc} {t-oploadacc} A {p-oploadacc-2}
$loadex {p-oploadacc}

# also clear LS, we'll want that empty to recieve acc value
$clearx {p-oploadacc} {a-ls} {r-clear}

# send A to DISCMEMCYC, first digit into sign: X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1
$send-rf {p-oploadacc-2}
$rec {p-oploadacc-2} {a-discmemcyc} {t-oploadacc-2} {i-splitA} {p-oploadacc-3}

# Discriminate: are we reading from 0-9 (pos) or 10-14 (neg)?
# Always triggers {p-oploadacc-4} next cycle, but wait 3 cycles before triggering 
# conditional branches (p-oploadacc09 vs p-oploadacc1014), as next two ops are shared
$discriminate-delay-passthru {p-oploadacc-3} {a-discmemcyc} {d-discmemcycA} {d-discmemcycS} 3 {p-oploadacc-4} {p-oploadacc09} {p-oploadacc1014}

# trigger FT same cycle
p {p-oploadacc-3} f3.2i
s f3.op2 A-2

# Shared steps post discriminate, always send FT arg and restore DISCMEMCYC
$sendc {p-oploadacc-4} {a-discmemcyc} {t-oploadacc-4} A {p-oploadacc-5}

$rec {p-oploadacc-5} {a-discmemcyc} {t-oploadacc-5} {i-main} {p-oploadacc-6}
$storeex {p-oploadacc-5}

# Now wait 4 cycles until the address is decoded and acc memory cycle begins
# Use LS program as it's guaranteed not a memory accumulator
$manual-dummy {p-oploadacc-6} {a-ls} {t-oploadacc6} 4 {p-oploadacc-7}


# POSITIVE (0-9) and NEGATIVE (10-14) branches of discriminate differ only on which acc
defmacro loadacc-branch x
  # Save MEMCYC$x -> EX, clear
  $sendc {p-oploadacc$x} {a-memcyc$x} {t-oploadacc$x} A {p-oploadacc$x-2}
  $loadex {p-oploadacc$x}

  # FT -> MEMCYC$x, read FT line when it's ready
  $rec {p-oploadacc$x-2} {a-memcyc$x} {t-oploadacc$x-2} {i-ftselacc} {p-oploadacc$x-3}

  # MEMCYC$x -S-> trigger memXX loadstore
  # Now MEMCYC$x is all 9 except for a 0 for the accumulator we want. When we send on S,
  # it will activate the loadstore program of one accumulator. Clear as we do this,
  # so we can restore from EX later
  $sendc {p-oploadacc$x-3} {a-memcyc$x} {t-oploadacc$x-3} S {p-oploadacc$x-4}

  # restore MEMCYC$x
  $recx {p-oploadacc$x-4} {a-memcyc$x} {r-oploadacc$x-4} {i-main}
  $storeex {p-oploadacc$x-4}
endmacro

$loadacc-branch 09
$loadacc-branch 1014


# Now the memory cycle proper; these two steps run while the selected accumulator 
# is running. Each memcyc is two steps: sendc, then rec. We need to receive the 
# accumulator value into LS, then immediately send it again

# MEMXX-> LS, receive accumulator value
$rec {p-oploadacc-7} {a-ls} {t-oploadacc-7} {i-main} {p-oploadacc-8}

# LS -> MEMXX, restore accumulator value, then next op
$send {p-oploadacc-8} {a-ls} {t-oploadacc-8} A {p-fetch}


endif # OP_LOADACC


if OP_SWAPALL

# - SWAPALL -
# Exchange RF and LS. Nothing fancy here.
p {p-op12} {p-opswapall}

# RF->EX, clear
$sendc-rf {p-opswapall}
$loadex {p-opswapall}
$dummy {p-opswapall} {p-opswapall-2}

# LS->RF
$sendc {p-opswapall-2} {a-ls} {t-opswapall-2} A {p-opswapall-3}
$loadrf {p-opswapall-2}

# EX->LS
$storeex {p-opswapall-3}
$rec {p-opswapall-3} {a-ls} {t-opswapall-3} {i-main} {p-fetch}

endif # OP_SWAPALL


if OP_MOVXA

# - MOV [BCDEGHIJ],A -
# Four inputs on RF let us share almost the same 4-cycle sequence for most
# MOVs, except MOV F,A which needs an extra input.  We could get 2-cycle MOVs
# for [BCD] by wiring movBA, movCA, movDA inputs on RF instead, but that would
# take more total programs, and having [BCDE] timing be the same might be
# helpful for word insert/extract for the memory cycle.
# 1. $clearA-1
# 2. $clearA-2
# 3. RF -> EX(no clear) or LS -> EX(no clear)
# 4. EX -sel[BCDE]A-> RF
#
# TODO If we had a $send program on EX rather than just a $sendc program, we
# could fit this into 3 cycles as
# 1. RF -clearA-> EX
# 2. EX -> RF, don't clear
# 3. EX -sel[BCDE]A-> RF, clear
#
# TODO An alternative 6-cycle sequence would reuse swapBCDE programs and would
# work for all mov X,A... it would probably conserve programs but not pulse
# amps.
# 1. $clearA-1
# 2. $clearA-2
# 3. swapBCDE -> EX
# 4. RF -swapBCDE-> swapBCDE
# 5. swapBCDE -selectA-> RF
# 6. EX -> swapBCDE
p {p-op20} {p-opmovBA}
p {p-op21} {p-opmovCA}
p {p-op22} {p-opmovDA}
p {p-op23} {p-opmovEA}
p {p-op25} {p-opmovGA}
p {p-op30} {p-opmovHA}
p {p-op31} {p-opmovIA}
p {p-op32} {p-opmovJA}

# Decode which select inputs to use, e.g. mov B,A and mov G,A each select the
# same field to move into A.
# XXX Use dummies instead of pulseamps because pulseamps are more constrained.
#$pulseamp {p-opmovBA} {p-opmovBGA}
#$pulseamp {p-opmovGA} {p-opmovBGA}
#$pulseamp {p-opmovCA} {p-opmovCHA}
#$pulseamp {p-opmovHA} {p-opmovCHA}
#$pulseamp {p-opmovDA} {p-opmovDIA}
#$pulseamp {p-opmovIA} {p-opmovDIA}
#$pulseamp {p-opmovEA} {p-opmovEJA}
#$pulseamp {p-opmovJA} {p-opmovEJA}
# ops that use rf
$pulseamp {p-opmovBA} {p-opmovRFA}
$pulseamp {p-opmovCA} {p-opmovRFA}
$pulseamp {p-opmovDA} {p-opmovRFA}
$pulseamp {p-opmovEA} {p-opmovRFA}
# ops that use ls
$pulseamp {p-opmovGA} {p-opmovLSA}
$pulseamp {p-opmovHA} {p-opmovLSA}
$pulseamp {p-opmovIA} {p-opmovLSA}
$pulseamp {p-opmovJA} {p-opmovLSA}
# all the mov ops
$pulseamp {p-opmovRFA} {p-opmovXA}
$pulseamp {p-opmovLSA} {p-opmovXA}

# shared dummies (12 total)
# Manually placed so they don't overlap with the multicycle sel dummies.
$manual-dummy {p-opmovXA} a19 {t-opmovXA} 3 {p-opmovXA-4}
# NB only one of these two may be active so fine if same accum
$manual-dummy {p-opmovRFA} a20 {t-opmovRFA} 2 {p-opmovRFA-3}
$manual-dummy {p-opmovLSA} a20 {t-opmovLSA} 2 {p-opmovLSA-3}
# only one sel dummy can be active so fine if same accum
# XXX Use dummies instead of pulseamps because pulseamps are more constrained.
#$dummy-delay-exclude {p-opmovBGA} 3 {p-rf-selBA} -a20,a19
#$dummy-delay-exclude {p-opmovCHA} 3 {p-rf-selCA} -a20,a19
#$dummy-delay-exclude {p-opmovDIA} 3 {p-rf-selDA} -a20,a19
#$dummy-delay-exclude {p-opmovEJA} 3 {p-rf-selEA} -a20,a19
$dummy-delay-exclude {p-opmovBA} 3 {p-rf-selBA} -a20,a19
$dummy-delay-exclude {p-opmovCA} 3 {p-rf-selCA} -a20,a19
$dummy-delay-exclude {p-opmovDA} 3 {p-rf-selDA} -a20,a19
$dummy-delay-exclude {p-opmovEA} 3 {p-rf-selEA} -a20,a19
$dummy-delay-exclude {p-opmovGA} 3 {p-rf-selBA} -a20,a19
$dummy-delay-exclude {p-opmovHA} 3 {p-rf-selCA} -a20,a19
$dummy-delay-exclude {p-opmovIA} 3 {p-rf-selDA} -a20,a19
$dummy-delay-exclude {p-opmovJA} 3 {p-rf-selEA} -a20,a19
$dummy {p-opmovXA-4} {p-fetch}

# Clear A register
$clearA {p-opmovXA}

# Read either RF or LS in EX
p {p-opmovRFA-3} {p-sub-rftoex}
$sendx {p-opmovLSA-3} {a-ls} {r-opmovLSA-3} A
$loadex {p-opmovLSA-3}

# Store back other register into A register from EX
$storeex {p-opmovXA-4}
# dummy will trigger p-rf-selXA this cycle

endif # OP_MOVXA


if OP_MOVFA

# - MOV F,A -
# Separate from other MOVs because RF doesn't have enough inputs to select A.
# TODO This is kinda expensive but seems important... is there a cheaper way?
# 1. MOVFA -> EX
# 2. RF -clearA-> MOVFA
# 3. LS -selectA-> MOVFA
# 4. MOVFA -> RF
# 5. EX -> MOVFA
p {p-op24} {p-opmovFA}

# Stash MOVFA in EX
$sendc {p-opmovFA} {a-movfa} {t-opmovFA} A {p-opmovFA-2}
$loadex {p-opmovFA}

# Get 0BCDE in MOVFA and clear RF
$sendc-rf {p-opmovFA-2}
$rec {p-opmovFA-2} {a-movfa} {t-opmovFA-2} {i-clearA} {p-opmovFA-3}

# Get F0000 in MOVFA
$sendx {p-opmovFA-3} {a-ls} {t-opmovFA-3} A
$rec {p-opmovFA-3} {a-movfa} {t-opmovFA-3} {i-selectA} {p-opmovFA-4}

# Replace RF with FBCDE and clear MOVFA
$sendc {p-opmovFA-4} {a-movfa} {t-opmovFA-4} A {p-opmovFA-5}
$loadrf {p-opmovFA-4}

# Restore stashed MOVFA
$storeex {p-opmovFA-5}
$rec {p-opmovFA-5} {a-movfa} {t-opmovFA-5} {i-main} {p-fetch}

endif # OP_MOVFA


if OP_CLRA

# - CLR A -
p {p-op35} {p-opclrA}

# Use clear A subroutine
$clearA {p-opclrA}
$dummy-delay {p-opclrA} 2 {p-fetch}

endif # OP_CLRA


if OP_MOVIMMA

# - MOV #XX,A -
p {p-op40} {p-opmovimmA}

# First clear A
$clearA {p-opmovimmA}
$dummy-delay {p-opmovimmA} 2 {p-opmovimmA-3}

# Now consume the next word in IR, saving it into A
$consume-op {p-opmovimmA-3}
$pulseamp {p-opmovimmA-3} {p-rf-selEA}  # save lowest word into A

# wait for 2 cycles of consume-op, then next op
$dummy-delay {p-opmovimmA-3} 2 {p-fetch}

endif # OP_MOVIMMA


if OP_INC

# - INC -
p {p-op52} {p-opinc}

# Send P01000 on d-main
p {p-opinc} c.29i
s c.s29 Jr

# Increment A field of RF
# XXX should probably use pulseamp
$rec {p-opinc} {a-rf} {t-opinc} {i-main} {p-fetch}

endif # OP_INC


if OP_DEC

# - DEC -
p {p-op53} {p-opdec}

# Send M99000 on d-main
p {p-opdec} c.30i
s c.s30 Jl

# Decrement A field of RF
# XXX should probably use pulseamp
$rec {p-opdec} {a-rf} {t-opdec} {i-main} {p-fetch}

endif # OP_DEC


if OP_ADD

# - ADD D,A -
p {p-op70} {p-opadd}

# RF -> EX
$rf-to-ex {p-opadd}
$dummy {p-opadd} {p-opadd-2}

# EX -selDA-> RF
$storeex {p-opadd-2}
$pulseamp {p-opadd-2} {p-rf-selDA}
$dummy {p-opadd-2} {p-fetch}

endif # OP_ADD


if OP_SUB

# - SUB D,A -
# 1. RF.S -> EX
# 2. EX -> selDA -> RF
# 3. P01 -> RF
# 4. M00 -> RF  # ideally we'd send M01, but don't have it
p {p-op72} {p-opsub}

# RF.S -> EX
$send {p-opsub} {a-rf} {t-opsub} S {p-opsub-2}
$loadex {p-opsub}

# EX -selDA-> RF
$storeex {p-opsub-2}
$pulseamp {p-opsub-2} {p-rf-selDA}
$dummy {p-opsub-2} {p-opsub-3}

# P01 -> RF
$loadrf {p-opsub-3}
p {p-opsub-3} c.27i
s c.s27 Jr
p c.27o {p-opsub-4}

# M00 -> RF
$loadrf {p-opsub-4}
$sendM0 {p-opsub-4}
$dummy {p-opsub-4} {p-fetch}

endif # OP_SUB


if OP_JMP

# - JMP XX -
p {p-op73} {p-sub-jmp}

endif # OP_JMP


if OP_JMPFAR

# - JMP XXXX -
# This is similar to JSR/RET sequences but saves a cycle by using IR directly
# because there is no need to shift.
# 1. PC -clearPC4-> EX  $discft-1
# 2. send PC            $discft-2
# 3. EX -> PC
# 4. IR -loadPC4-> PC   $discft-1
# 5. send IR            $discft-2
p {p-op74} {p-opjmpfar}

# Deselect current function table
$startjmp {p-opjmpfar}
# PC -clearPC4-> EX
$rec {p-opjmpfar} {a-ex} {t-opjmpfar} {i-clearPC4} {p-opjmpfar-2}

$dummy-exclude {p-opjmpfar-2} {p-opjmpfar-3} -{a-discft1},{a-discft2},{a-discft3}

# EX -> PC
$storeex {p-opjmpfar-3}
$loadpc {p-opjmpfar-3}
$dummy-exclude {p-opjmpfar-3} {p-opjmpfar-4} -{a-discft3}

# Select new function table and go to fetch
$assert {p-opjmpfar-4} {a-ir}~Pxxxxxxxxxx  # don't trigger IR discrimination
$send {p-opjmpfar-4} {a-ir} {t-opjmpfar-4} A {p-fetchline}
s {a-ir}.rp{t-opjmpfar-4} 2
$discft {p-opjmpfar-4}
# Load new PC
$recx {p-opjmpfar-4} {a-pc} {r-opjmpfar-4} {i-loadPC4}

endif # OP_JMPFAR


if OP_JSR

# - JSR XXXX -
# 1. SHIFTPC -> EX
# 2. IR -extract-pc-> SHIFTPC
# 3. PC -shiftl4-pc-> SHIFTPC  $discft-1
# 4. send PC                   $discft-2
# 5. SHIFTPC -> PC             $discft-1
# 6. send SHIFTPC              $discft-2
#  . EX -> SHIFTPC             (parallel with p-fetchline)
p {p-op84} {p-opjsr}

# Save shiftpc in ex
$sendc {p-opjsr} {a-shiftpc} {t-opjsr} A {p-opjsr-2}
$loadex {p-opjsr}

# Extract pc from ir into shiftpc
$assert {p-opjsr-2} {a-ir}~Pxxxxxxxxxx
$sendx {p-opjsr-2} {a-ir} {t-opjsr-2} A
$rec {p-opjsr-2} {a-shiftpc} {t-opjsr-2} {i-extract-pc} {p-opjsr-3}

# Deselect ft and load RRRR into PPPP field in shiftpc
$startjmp {p-opjsr-3}
$rec {p-opjsr-3} {a-shiftpc} {t-opjsr-3} {i-shiftl4-pc} {p-opjsr-4}

# Select new ft, reload new PC, goto fetchline, restore shiftpc
$dummy-exclude {p-opjsr-4} {p-sub-finishjmp} -{a-discft3}

endif # OP_JSR


if OP_RET

# - RET -
# 1. SHIFTPC -> EX
# 2. PC -shiftr4-pc-> SHIFTPC  $discft-1
# 3. send PC                   $discft-2
# 4. SHIFTPC -> PC             $discft-1
# 5. send SHIFTPC              $discft-2
#  . EX -> SHIFTPC             (parallel with p-fetchline)
p {p-op85} {p-opret}

# Save shiftpc in ex
$sendc {p-opret} {a-shiftpc} {t-opret} A {p-opret-2}
$loadex {p-opret}

# Deselect ft and load RRRR into PPPP field in shiftpc
$startjmp {p-opret-2}
$rec {p-opret-2} {a-shiftpc} {t-opret-2} {i-shiftr4-pc} {p-opret-3}

# Select new ft, reload new PC, goto fetchline, restore shiftpc
$dummy-exclude {p-opret-3} {p-sub-finishjmp} -{a-discft3}

endif # OP_RET


if OP_JN

# - JN XX -
p {p-op80} {p-opjn}

# save DISCJN
$sendc {p-opjn} {a-discjn} {t-opjn} A {p-opjn-2}
$loadex {p-opjn}

# RF->DISCJN, this puts sign of A into DISCJN PM
$send {p-opjn-2} {a-rf} {t-opjn-2} A {p-opjn-3} # replace with RF send macro?
$recx {p-opjn-2} {a-discjn} {t-opjn-2} {i-main}

# discriminate, and clear to ready DISCJN for restored memory value
$discriminatec {p-opjn-3} {a-discjn} {d-discjnA} {d-discjnS} {p-opjn-pos} {p-opjn-neg}

# if positive, restore acc, consume and carry on
$storeex {p-opjn-pos}
$rec {p-opjn-pos} {a-discjn} {t-opjn-pos} {i-main} {p-opjn-eat}

$consume-op {p-opjn-eat}
$dummy-delay {p-opjn-eat} 2 {p-fetch}

# if negative, restore acc and jump
$storeex {p-opjn-neg}
$rec {p-opjn-neg} {a-discjn} {t-opjn-neg} {i-main} {p-sub-jmp}

endif # OP_JN


if OP_PRINT

# - PRINT - 
# Save a13, RF-printAB->a13, restore
# Really the only trick here is that we can only print from a13,
# and during the transfer we shift RF right so we print 0AABB not AABBC
p {p-op92} {p-opprint}

# PRINT->EX, clear
$sendc {p-opprint} a13 {t-opprint} A {p-opprint-2}
$loadex {p-opprint}

# RF-printAB->a13. Puts AB in lower 4 digits of upper half of accumulator
$send-rf {p-opprint-2}
$rec {p-opprint-2} a13 {t-printAB} {i-printAB} i.pi # trigger print

# prints high half accumulator 13 
s pr.2 P            
p i.po {p-opprint-3}

# restore contents of MEM13
$clear {p-opprint-3} a13 {t-opprint-3} {p-opprint-4}

$storeex {p-opprint-4}
$rec {p-opprint-4} a13 {t-opprint-4} {i-main} {p-fetch}

endif # OP_PRINT


# - HALT -
# Wire halt to quit the simulator so we can run programs and exit when they're
# done.
# p {p-op95} debug.quit


# -- ACCUMULATOR DECODE --
# lookup table used to trigger accumulators on loadacc / storeacc
# This is on FT3 but doesn't conflict with FTL values on I1 since it uses 10 of 12 digits
defmacro acc-decode-line line x01 x02 x03 x04 x05 x06 x07 x08 x09 x10
  s f3.RA$lineS  $x01
  s f3.RA$lineL4 $x02
  s f3.RA$lineL3 $x03
  s f3.RA$lineL2 $x04
  s f3.RA$lineL1 $x05
  s f3.RB$lineL6 $x06
  s f3.RB$lineL5 $x07
  s f3.RB$lineL4 $x08
  s f3.RB$lineL3 $x09
  s f3.RB$lineL2 $x10
  s f3.RB$lineL1 9      # use 2-10 + sign, digit 1 is not usable on S due to 1'P
endmacro

s f3.mpm1 T             # send individual line signs through

# These are the 9s complements of 000..9..00 (we send from memcyc09/memcyc1014 on S)
# Use rows -2..7 with A-2 addressing to minimize program overlap.
$acc-decode-line -2 M 9 9 9 9 9 9 9 9 0
$acc-decode-line -1 M 9 9 9 9 9 9 9 0 9
$acc-decode-line  0 M 9 9 9 9 9 9 0 9 9
$acc-decode-line  1 M 9 9 9 9 9 0 9 9 9
$acc-decode-line  2 M 9 9 9 9 0 9 9 9 9
$acc-decode-line  3 M 9 9 9 0 9 9 9 9 9
$acc-decode-line  4 M 9 9 0 9 9 9 9 9 9
$acc-decode-line  5 M 9 0 9 9 9 9 9 9 9
$acc-decode-line  6 M 0 9 9 9 9 9 9 9 9
$acc-decode-line  7 P 9 9 9 9 9 9 9 9 9


# -- DUMMIES --
# Reserved after other all other accumulator programs are configured.
insert-deferred


# -- CURRENT PROGRAM --
include ftdata.easm

# Start the machine
b i
