s cy.op 1a
set a1 0
b i

# ENIAC-VM for playing chess
# created 2020-3-30 by Jonathan Stray
#
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute,
# and implements all the opcodes. The control cycle design is adapted from 
# "Central Control for ENIAC", Adele Goldstine, 1947
#
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.


# -- MACROS --
# These define a basic language we use to specify program steps
# Program in the ENIAC sense of pulse-triggered operations, akin to microcode for the VM

# RECeive on given input
defmacro rec inpr acc program input outpr
  p $inpr $acc.$programi
  s $acc.op$program $input
  p $acc.$programo $outpr
endmacro

# RECeive and do not (X) emit an output program pulse
defmacro recx inpr acc program input
  p $inpr $acc.$programi
  s $acc.op$program $input
endmacro

# RECeive and INCrement
defmacro recinc inpr acc program input outpr
  p $inpr $acc.$programi
  s $acc.op$program $input
  s $acc.cc$program C
  p $acc.$programo $outpr
endmacro

# RECeive and INCrement and do not (X) emit an output program pulse
defmacro recincx inpr acc program input
  p $inpr $acc.$programi
  s $acc.op$program $input
  s $acc.cc$program C
endmacro

# SEND and do not (X) emit an output program pulse
defmacro sendx inpr acc program AorS 
  p $inpr $acc.$programi
  s $acc.op$program $AorS
endmacro

# SEND and Clear
defmacro sendc inpr acc program AS outpr
  p $inpr $acc.$programi
  s $acc.op$program $AS
  s $acc.cc$program C
  p $acc.$programo $outpr
endmacro

# SEND and Clear and do not (X) emit an output program pulse
defmacro sendcx inpr acc program AorS 
  p $inpr $acc.$programi
  s $acc.op$program $AorS
  s $acc.cc$program C
endmacro

# CLEAR accumulator
# triggered on inp and emitting outp when done (via transceiver t)
defmacro clear inpr acc t outpr
  p $inpr $acc.$ti
  s $acc.op$t 0
  s $acc.cc$t C
  p $acc.$to $outpr
endmacro

# CLEAR accumulator and do not (X) emit an output program pulse
defmacro clearx inpr acc t
  p $inpr $acc.$ti
  s $acc.op$t 0
  s $acc.cc$t C
endmacro

# $dummy program definition, with a given delay
defmacro dummy inpr acc t delay outpr
  p {$inpr} $acc.{$t}i
  s $acc.op{$t} 0
  s $acc.rp{$t} $delay
  p $acc.{$t}o {$outpr}
endmacro

# $discriminate
#   inp   - input program line
#   acc   - accumulator to wire for discrimination
#   dummy - accumulator to use for dummy programs
#   name  - base for transciever names on acc and dummy
#   dA,dS - data busses to use for acc.A acc.S
#   outp  - program line for acc>=0
#   outm  - program line for acc<0
defmacro discriminate inp acc dummy name dA dS outp outm

  p $inp $acc.{t-$name}i
  s $acc.op{t-$name} AS               

  # acc >= 0 -> outp
  p $dS ad.dp.{ad-disc-$name-S}.11
  p ad.dp.{ad-disc-$name-S}.11 $dummy.{t-$name-S}i
  s $dummy.op{t-$name-S} 0
  p $dummy.{t-$name-S}o $outp

  # acc < 0 -> outm
  p $dA ad.dp.{ad-disc-$name-A}.11
  p ad.dp.{ad-disc-$name-A}.11 $dummy.{t-$name-A}i
  s $dummy.op{t-$name-A} 0
  p $dummy.{t-$name-A}o $outm

endmacro


# -- ACCUMULATOR LAYOUT --
# Defines all accumulators and patches to and from data trunks
# That patching encodes the possible permutations on acc inputs and outputs,
# as well as digit-to-program triggers for discrimination and 1-of-N decoding.
# Listed centrally here to make it easier to track allocation.

# Main data bus, used for most transfers
{d-main}=1

# - Program counter -
# Layout: SS RRRR PPPP
# Current program counter PPPP and return address RRRR, plus a temp SS
# Four digit address is FFLL: FF = which ft (00=ft1, 90=ft2, 99=ft3), LL = ft line

{a-pc}=a1

p {a-pc}.A {d-main}
# A - mp steppers, op<=53
# S - mp steppers, op>53

# main input
p {d-main} {a-pc}.{i-main}i

# shiftl8-irS input: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
p {d-irS} ad.s.{ad-pc-shiftl8-irS}.8
p ad.s.{ad-pc-shiftl8-irs}.8 {a-pc}.{i-shiftl8-irS}i

# "no connection" input, used for incrementing PC
p {d-nothing} {a-pc}.{i-nothing} # d-nothing is a workaround, I'd prefer "{a-pc}.{i-nothing}=a"

# b - loadim2-irS: I1 XX XX XX XX -> 00 00 00 00 I1, used for JN/JZ/JIL
# g - shiftl4-exA, used for JSR
# d - from FT, in control cycle to load first instruction


# - Instruction Register -
# Layout: M 99-I6 99-I5 99-I4 99-I3 100-I2
# Holds up to 5 instructions queued to execute after loading from a function
# table line. Fills in 99 from the left as instructions are executed. When empty, 
# this will be 9999999999 and then +1 flips to P0, easy to detect
# So we also have a "need to fetch a line" discrimination on IR

{a-ir}=a2

# A output of IR goes to main, is also permuted for use in the control cycle
p {a-ir}.A {d-irA}
p {d-irA} {d-main}

# I6 I5 I4 I3 I2 I1 -> I1 I6 I5 I4 I3 I2
# Shift the instructions right, then we execute and clear I1, removing one from the queue
p {d-irA} ad.permute.{ad-irA}
s ad.permute.{ad-irA} 0,2,1,10,9,8,7,6,5,4,3
p ad.permute.{ad-irA} {d-main}

# S output to its own bus, unpermuted
p {a-ir}.S {d-irS}

# AS - fetch discriminate

# fetch input: from d-fetch, used for loading new line of instructions permuted from function table
p {d-fetch} {a-ir}.{i-fetch}

# fill99 input: replace top 2 digits with 99 (copy PM, so needs EX.PM = M)
p {d-main} ad.permute.{ad-fill99}
s ad.permute.{ad-fill99} 11,11,11,8,7,6,5,4,3,2,1
p ad.permute.{ad-fill99} {a-ir}.{i-fill99}

# g - fill99exS: replace top 2 digits with 99, requires EX.PM = P


# - Execution Register -
# Empty at the beginning of every opcode program
# Typically the only temp space in the machine, so used extensively to save
# contents of other accumulators while they are used functionally
# Also used to disc opcode >53

{a-ex}=a3

# A - main
p {a-ex}.A {d-exA}   # can't patch directly to d-main because we also discriminate
p {d-exA} {d-main}

# S - exS
p {a-ex}.S {d-exS}

# main
p {d-main} {a-ex}.{i-main}i

# b - clearA: XX XX XX XX XX -> 00 XX XX XX XX, used for MOV A,#X and other writes to A
# g - clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
# g - clearPC4: XX XX XX 43 21 -> XX XX XX 00 00, used for JMP
# e - shiftl4:  XX YY YY 43 32 -> XX 43 21 00 00, used for JSR


# - Register File -
# Registers A-E of the virtual machine. Use a13 so we can print it.
{a-reg}=a13


# - Load/Store -
# Registers F-J of the virtual machine. 
{a-ls}=a4



# -- CONTROL CYCLE --

# initiate button
p i.io {p-clearex-fetch}

# - A program line to jump to if ex has something in it
$clear {p-clearex-fetch} {a-ex} {t-clearex-fetch} {p-fetch}


# -- p-fetch: begin next instruction
# During this cycle:
#  - discriminate, to decide whether to fetch new instructions
#  - read out the contents of IR into EX
#  - send complement of next instruction (I1) to PC

$discriminate {p-fetch} {a-ir} a20 fetch {d-irA} {d-irS} {p-fetchline} {p-nofetch}
s {a-ir}.cc{t-fetch} C   # clear IR after transmission

# IR -> EX 
# IR permutes on A output, I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, and drops sign
# This puts the next instruction in the left of EX, ready to discriminate
$recx {p-fetch} {a-ex} {r-fetch} {i-main}

# IR -S-shiftl8-irS-> PC
# Also send first opcode to top of PC
# We use the S output to undo the existing complement when we loaded IR
$recx {p-fetch} {a-pc} {r-fetch} {i-shiftl8-irS}



# -- {p-nofetch} no fetch needed, begin instruction decode
# EX starts P 100-I1 99-I5 99-I4 99-I3 99-I2
# Begin decode by adding 53 to EX, from constant transmitter

# Send 53 from CT to d-main
p {p-nofetch} c.26i 
s c.s26 Kl
s c.k10 5
s c.k9  3 
p c.o {d-main} 

# EX += d-main
$rec {p-nofetch} {a-ex} {t-nofetch} {i-main} {p-disc-op}


# -- {p-disc-op} discriminate opcode I1>53, to switch between two decode pathways
# EX starts 153-I1 99-I5 99-I4 99-I3 99-I2
# Also store shifted instructions back to IR, this deletes just-dispatched opcode

p {p-disc-op} debug.bp7

$discriminate {p-disc-op} {a-ex} a20 disc-op {d-exA} {d-exS} {p-ople53} {p-opgt53}
s {a-ex}.cc{t-disc-op} C  # clear EX

p {p-ople53} debug.bp8
p {p-opgt53} debug.bp9

# meanwhile, store EX back into IR, without the instruction we are now decoding
# Replace first two digits with PM; gives M99 if EX<0 at this point, P00 otherwise
$recx {p-disc-op} {a-ir} {r-disc-op} {i-fill99}

# IR += 1 to turn 99-I2 into 100-I2, prepare for next cycle
s {a-ir}.cc{r-disc-op} C

# clear master programmer steppers in anticipation of decode
p {p-disc-op} p.Acdi
p {p-disc-op} p.Bcdi
p {p-disc-op} p.Ccdi
p {p-disc-op} p.Dcdi
p {p-disc-op} p.Ecdi
p {p-disc-op} p.Fcdi
p {p-disc-op} p.Gcdi


# -- p-ople53 - begin decode of opcode which is <= 53
# EX = P 153-I1 ...
# Leftmost opcode in IR now P00
# Add M9900000001 so it resets to M but then overflows to P if no more opcodes

# M9900000001 -> d-main
p {p-ople53} c.27i 
s c.s27 Jlr
s c.jl M
s c.j10 9
s c.j9  9 
s c.j1  1

# a-ir += d-main
$rec {p-ople53} {a-ir} {t-ople53} {i-main} {p-ople53-2}


# -- p-ople53-2 - send tens digit of opcode to stepper A, ones digit to B-G
# also clear EX, to prepare for execution 

# send EX on S and clear
$sendc {p-ople53-2} {a-ex} {t-ople53-2} S {p-ople53-3}

# wire EX.S to master programmer
p {d-exS} ad.dp.{ad-ople53-tens}.10   # 10s digit of opcode
p ad.dp.{ad-ople53-tens}.10 p.Adi
p {d-exS} ad.dp.{ad-ople53-ones}.9    # 1s digit of opcode
p ad.dp.{ad-ople53-ones}.9 p.Bdi
p ad.dp.{ad-ople53-ones}.9 p.Cdi
p ad.dp.{ad-ople53-ones}.9 p.Ddi
p ad.dp.{ad-ople53-ones}.9 p.Edi
p ad.dp.{ad-ople53-ones}.9 p.Fdi
p ad.dp.{ad-ople53-ones}.9 p.Gdi

# wire A stepper outputs to inputs of B-G
p p.A1o p.Bi
p p.A2o p.Ci
p p.A3o p.Di
p p.A4o p.Ei
p p.A5o p.Fi
p p.A6o p.Gi


# -- p-ople53-3 - send input pulse to master programmer

p {p-ople53-3} p.Ai

# Now we have to wire the outputs to individual opcode programs
defmacro op-lines stepper tens
  p p.$stepper1o {p-op$tens0}
  p p.$stepper2o {p-op$tens1}
  p p.$stepper3o {p-op$tens2}
  p p.$stepper4o {p-op$tens3}
  p p.$stepper5o {p-op$tens4}
  p p.$stepper6o {p-op$tens5}
endmacro

$op-lines B 0
$op-lines C 1
$op-lines D 2
$op-lines E 3
$op-lines F 4
$op-lines G 5

p {p-op00} debug.bp0
p {p-op11} debug.bp1
p {p-op22} debug.bp2
p {p-op33} debug.bp3
p {p-op44} debug.bp4
p {p-op50} debug.bp5


# -- p-opgt53 - decode opcode which is > 53
# EX = M 153-I1 ...
# Leftmost opcode in IR is now M99
# Add 1 to cause overflow if no more opcodes (roll 9's over to 0)

p {p-opgt53} {a-ir}.{r-plusone}i 
s {a-ir}.op{r-plusone} {i-plusone} # not connected to anything
s {a-ir}.cc{r-plusone} C

# PLACEHOLDER: flip sign and send to printer
$dummy {p-opgt53} a20 {t-opgt53-printex} 1 {p-flipex-printex}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# - stimulate FT, goto {p-fetcharg} for argument
# - delay 4 then goto {p-fetchread}

# - clear IR (needed only on jumps, otherwise already zero here from overflow) and delay 4
$clear {p-fetchline} {a-ir} {t-fetchline} {p-fetchread}
s {a-ir}.rp{t-fetchline} 4    # repeat 4 to wait for FT result

# - clear EX as well, it will also receive from FT
$clearx {p-fetchline} {a-ex} {t-fetchline}

# - trigger ft
p {p-fetchline} f1.1i         
s f1.rp1 1                    # 1 repeat (neccessary?)
s f1.op1 S0                   # send complement, don't offset argument
s f1.cl1 C                    # pulse on C when done
p f1.C {p-fetcharg}           # goto when ready for argument


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)

$sendx {p-fetcharg} {a-pc} {t-fetcharg} A

p {d-main} ad.sd.{ad-fetcharg}.0     # bottom two digits of main -- needed or does FT ignore others?
p ad.sd.{ad-fetcharg}.0 f1.arg


# -- {p-fetchread} read ft line of instructions
#  - FT sends complement of A and B
#  - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = M I1 00 00 00 00  = A6A5+1 00 00 00 00
#  - PC += 1
#  - goto p-decode

# B2B1 B4B3 B6B5 A2A1 A4A3+1 -> IR
# NYI: should goto decode opcode in EX, not printex
p f1.A {d-f1A}                      # FIXME in the sim, need output T-s to avoid using extra digit tray
p {d-f1A} ad.permute.{ad-fetchA}
s ad.permute.{ad-fetchA} 0,0,0,0,0,0,0,2,1,4,3
p ad.permute.{ad-fetchA} {d-fetch}

p f1.B ad.permute.{ad-fetchB}
s ad.permute.{ad-fetchB} 11,2,1,4,3,6,5,0,0,0,0
p ad.permute.{ad-fetchB} {d-fetch}

$recinc {p-fetchread} {a-ir} {t-fetchread} {i-fetch} {p-flipex-printex} 


# A6A5+1 00 00 00 00  -> EX
p {d-f1A} ad.permute.{ad-fetch-ex}
s ad.permute.{ad-fetch-ex} 0,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-fetch-ex} {d-main}

$recincx {p-fetchread} {a-ex} {r-fetchread} {i-main} 


# PC += 1
$recincx {p-fetchread} {a-pc} {r-fetchread} {i-nothing}




# -- {p-flipex-printex} - change sign of EX from M to P, then print
# M9900000001 -> d-main, but we use an adapter to keep only the M
p {p-flipex-printex} c.28i
s c.s28 Jlr

p {p-flipex-printex} {a-ex}.{t-flipex}i
s {a-ex}.op{t-flipex} {i-flipex}
p {d-main} ad.d.{ad-flipex}.0           # keep 0 digits, i.e. sign only
p ad.d.{ad-flipex}.0 {a-ex}.{i-flipex}
p {a-ex}.{t-flipex}o {p-printex} 


# -- {p-printex} print EX and stop

# clear register file
$clear {p-printex} {a-reg} {t-decode} {p-printop}

# EX -> d-exA
p {p-printop} {a-ex}.{t-printop}i   
s {a-ex}.op{t-printop} A
p {a-ex}.{t-printop}o {p-printop2}

# mainbus -> REG
p {p-printop} {a-reg}.{r-printop}i
s {a-reg}.op{r-printop} {i-printop}
p {d-exA} ad.sd.{ad-printop}.8
p ad.sd.{ad-printop}.8 {a-reg}.{i-printop}
#p {d-exA} {a-reg}.a

# print "decoded" instruction, it's in a13
p {p-printop2} i.pi 
s pr.2 P
s pr.3 P





# ------------ DATA --------------

# function table values
s f1.RA0L6 0
s f1.RA0L5 1
s f1.RA0L4 0
s f1.RA0L3 2
s f1.RA0L2 0
s f1.RA0L1 3

s f1.RB0L6 0
s f1.RB0L5 4
s f1.RB0L4 0
s f1.RB0L3 5
s f1.RB0L2 0
s f1.RB0L1 6


s f1.RA1L6 1
s f1.RA1L5 1
s f1.RA1L4 1
s f1.RA1L3 2
s f1.RA1L2 1
s f1.RA1L1 3

s f1.RB1L6 1
s f1.RB1L5 4
s f1.RB1L4 1
s f1.RB1L3 5
s f1.RB1L2 1
s f1.RB1L1 6


s f1.RA2L6 2
s f1.RA2L5 1
s f1.RA2L4 2
s f1.RA2L3 2
s f1.RA2L2 2
s f1.RA2L1 3

s f1.RB2L6 2
s f1.RB2L5 4
s f1.RB2L4 2
s f1.RB2L3 5
s f1.RB2L2 2
s f1.RB2L1 6


s f1.RA3L6 3
s f1.RA3L5 1
s f1.RA3L4 3
s f1.RA3L3 2
s f1.RA3L2 3
s f1.RA3L1 3

s f1.RB3L6 3
s f1.RB3L5 4
s f1.RB3L4 3
s f1.RB3L3 5
s f1.RB3L2 3
s f1.RB3L1 6


s f1.RA4L6 4
s f1.RA4L5 1
s f1.RA4L4 4
s f1.RA4L3 2
s f1.RA4L2 4
s f1.RA4L1 3

s f1.RB4L6 4
s f1.RB4L5 4
s f1.RB4L4 4
s f1.RB4L3 5
s f1.RB4L2 4
s f1.RB4L1 6

