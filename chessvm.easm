s cy.op 1a

disable PRELOAD_MEMORY
if PRELOAD_MEMORY
# memory values to check that various instructions save and restore
set a4  -1144668822
set a5  -9988776655  # check that STOREACC maintains sign of DISCFTx
set a6  0606060606
set a7  0707070707
set a8  0808080808
set a9  0909090909
set a10 1010101010
set a11 1111111111
set a12 1212121212 
set a13 1313131313 
set a15 1515151515
set a16 1616161616
set a17 1717171717
#set a18 1818181818    can't do this, used to construct reset PC
set a19 1919191919
set a20 2020202020  
endif

# use 'enable' or 'disable' to condition assembly of the corresponding sequence
# - base (11 pas, 21 ts)
enable RESET_SEQUENCE #  2 pas,  2 ts
enable CONTROL_CYCLE  #  9 pas, 19 ts
# - memory (13 pas, 54 ts)
enable OP_LOADACC     #  1 pas,  1 ts
enable OP_STOREACC    #  1 pas,  5 ts
enable SUB_MEMCYC     #  7 pas, 42 ts (OP_LOADACC, OP_STOREACC)
enable OP_SWAPALL     #  4 pas,  6 ts
# - word access (14 pas, 28 ts)
enable WORD_ACCESS
disable FAST_MOV      #  0 pas,  1 ts (to fit)
disable OP_MOVXA6
disable OP_SWAP6
disable SUB_MOVSWAP
disable OP_MOVXA3
disable OP_MOVFA3
disable OP_SWAP
disable SUB_MOVAX5
disable SUB_MOVAX11
if WORD_ACCESS
if FAST_MOV
  # 3-cycle mov datapath
  enable OP_MOVXA3    #  6 pas, 14 ts (4-cycle with 5 pas, 12 ts)
  enable OP_MOVFA3    #  4 pas,  6 ts
  enable OP_SWAP      # 11 pas, 12 ts
else
  # 6-cycle mov datapath permitting shared SWAP
  enable OP_MOVXA6    #  5 pas, 14 ts
  enable OP_SWAP6     #  7 pas,  8 ts
  enable SUB_MOVSWAP  #  2 pas,  6 ts (OP_SWAP6, OP_MOVXA6)
endif
disable SUB_MOVAX5    #  7 pas, 17 ts
disable SUB_MOVAX11   # 11 pas, 11 ts
endif
# - arithmetic (15 pas, 9 ts)
enable OP_MOVIMMA     #  3 pas,  1 ts
enable OP_INC         #  0 pas,  0 ts
enable OP_DEC         #  1 pas,  0 ts
enable OP_ADD         #  4 pas,  4 ts
enable OP_SUB         #  6 pas,  3 ts
enable OP_CLRA        #  1 pas,  1 ts
# - control flow (19 pas, 26 ts)
enable OP_JMPFAR      #  1 pas,  2 ts
enable OP_JSR         #  1 pas,  2 ts
enable OP_RET         #  1 pas,  2 ts
enable OP_JMP         #  0 pas,  0 ts
enable OP_JN          #  2 pas,  2 ts
enable OP_JZ          #  1 pas,  1 ts
enable OP_JIL         #  1 pas,  1 ts
enable SUB_DISCJX     #  2 pas,  2 ts (OP_JZ, OP_JIL)
enable SUB_JX         #  3 pas,  5 ts (OP_JN, OP_JZ, OP_JIL)
enable SUB_JMP        #  1 pas,  4 ts (OP_JMP, SUB_JX)
enable SUB_FARGO      #  6 pas,  4 ts (OP_JMPFAR, OP_JSR, OP_RET)
enable SUB_DISCFT     #  0 pas,  1 ts (SUB_FARGO)
# - misc (8 pas, 13 ts)
enable OP_PRINT       #  3 pas,  4 ts
enable OP_READ        #  0 pas,  2 ts
enable SUB_CONSUME_OP #  2 pas,  3 ts (OP_MOVIMMA, SUB_JX)
enable SUB_CLEARA     #  3 pas,  1 ts (OP_MOVXA6, OP_CLRA, OP_MOVIMMA)
# loadpc              #  0 pas,  0 ts
# loadex              #  0 pas,  0 ts
# loadex-clearA       #  0 pas,  0 ts
# storeex             #  0 pas,  1 ts
# rf-selBA*           #  0 pas,  0 ts (* if OP_MOVXA3)
# rf-selCA*           #  0 pas,  0 ts (* if OP_MOVXA3)
# rf-selDA            #  0 pas,  0 ts
# rf-selEA            #  0 pas,  0 ts
# send-rf             #  0 pas,  1 ts
# sendc-rf            #  0 pas,  1 ts
# loadrf*             #  0 pas,  0 ts (1 if OP_MOVXA3)
# clearls*            #  0 pas,  0 ts (1 if SUB_MOVAX5)
# sendc-ls*           #  0 pas,  0 ts (1 if SUB_MOVAX11)


# ENIAC-VM for playing chess
# Jonathan Stray and Jered Wierzbicki
# created 2020-3-30 
#
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute,
# and implements all the opcodes. The control cycle design is adapted from 
# "Central Control for ENIAC", Adele Goldstine, 1947
#
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

include macros.easm

# -- ACCUMULATOR LAYOUT --
# Defines all accumulators and patches to and from data trunks
# That patching encodes the possible permutations on acc inputs and outputs,
# as well as digit-to-program triggers for discrimination and 1-of-N decoding.
# Listed centrally here to make it easier to track allocation.

# Main data bus, used for most transfers
{d-main}=1

# macro to setup main bus connections - no "a-" before acc
defmacro acc-main acc
  p {a-$acc}.A {d-main}
  p {d-main} {a-$acc}.{i-main}
endmacro

# main bus connections for acc used for discrimination. We need to remove sign,
# and create another bus for the S output. Otherwise any sign pulse on d-main would
# trigger one of our discrimination programs. 
defmacro acc-disc-main acc
  p {a-$acc}.A {d-$accA}
  # XXX does a.d.{x}.-0 delete sign?
  p {d-$accA} ad.permute.{ad-drop-$acc-sign}
  s ad.permute.{ad-drop-$acc-sign} 0,10,9,8,7,6,5,4,3,2,1
  p ad.permute.{ad-drop-$acc-sign} {d-main}

  p {a-$acc}.S {d-$accS}

  p {d-main} {a-$acc}.{i-main}
endmacro


# - Program counter -
# Layout: SS RRRR PPPP
# Current program counter PPPP and return address RRRR, plus a temp SS used for op decode
# Four digit address is FFLL: FF = which ft (09=ft1, 90=ft2, 99=ft3), LL = ft line

{a-pc}=a1
$acc-main pc

# A - mp steppers, op<=55
# S - mp steppers, op>55
# Decode needs the digits of the SS field to be swapped.
p {a-pc}.S ad.permute.{ad-swap-pc-ss-digits}
s ad.permute.{ad-swap-pc-ss-digits} 11,9,10,8,7,6,5,4,3,2,1
p ad.permute.{ad-swap-pc-ss-digits} {d-main}

# shiftl8 input: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
p {d-main} ad.s.{ad-pc-shiftl8}.8
p ad.s.{ad-pc-shiftl8}.8 {a-pc}.{i-shiftl8}

# clear A input: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
p {d-exS} ad.permute.{ad-exS-clearA}
s ad.permute.{ad-exS-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-exS-clearA} {a-pc}.{i-exS-clearA}

# loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
p {d-main} ad.d.{ad-pc-loadPC2}.-8
p ad.d.{ad-pc-loadPC2}.-8 {a-pc}.{i-loadPC2}

# fetch input: from d-fetch-i1, used for loading I1 into SS field
p {d-fetch-i1} {a-pc}.{i-fetch-i1}

# shared programs
$recx {p-loadpc} {a-pc} {r-loadpc} {i-main}

# helper macros
defmacro loadpc prog
  $pulseamp $prog {p-loadpc}
endmacro


# - Instruction Register -
# Layout: P I6 I5 I4 I3 I2
# Holds up to 5 instructions queued to execute after loading from a function
# table line. Fills in 99 from the left as instructions are executed. When empty, 
# this will be 9999999999 and then +1 flips to M0, easy to detect
# So we use the sign of IR to decide whether we need to fetch (discriminate on IR)

{a-ir}=a2
$acc-disc-main ir

# fetch input: from d-fetch, used for loading new line of instructions permuted from function table
p {d-fetch} {a-ir}.{i-fetch}

# fill99 input: replace top 2 digits of IR with 99, clear P/M
# the 99 comes from a constant M00000, the rest from EX sent on main
p {d-main} ad.permute.{ad-fill99-main}
s ad.permute.{ad-fill99-main} 0,11,11,8,7,6,5,4,3,2,1
p ad.permute.{ad-fill99-main} {a-ir}.{i-fill99}


# - Execution Register -
# Empty at the beginning of every opcode program
# Typically the only temp space in the machine, so used extensively to save
# contents of other accumulators while they are used functionally
# Also used to disc opcode >55

{a-ex}=a3
$acc-disc-main ex

# rotate-ir input: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2 for control cycle
# Shift the instructions right, then we execute and clear I1, removing one from the queue
p {d-main} ad.permute.{ad-ir}
s ad.permute.{ad-ir} 11,2,1,10,9,8,7,6,5,4,3
p ad.permute.{ad-ir} {a-ex}.{i-rotate-ir}

# clearA input: S aa bb cc dd ee -> 0 00 bb cc dd ee, used in control cycle and MOV
p {d-main} ad.permute.{ad-ex-clearA}
s ad.permute.{ad-ex-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-ex-clearA} {a-ex}.{i-clearA}

# clearPC2: SS RRRR PPPP -> SS RRRR PP00, used for JMP/JN/JZ/JIL
p {d-main} ad.permute.{ad-clearPC2}
s ad.permute.{ad-clearPC2} 11,10,9,8,7,6,5,4,3,0,0
p ad.permute.{ad-clearPC2} {a-ex}.{i-clearPC2}

# fetch input: from d-fetch-i1, used for loading I1 into left two digits
p {d-fetch-i1} {a-ex}.{i-fetch-i1}

# shared programs
$recx {p-loadex} {a-ex} {r-loadex} {i-main}
$recx {p-loadex-clearA} {a-ex} {r-loadex-clearA} {i-clearA}
# EX.PM must be P for storeex or we will misfire opcode discrimination
$assert {p-storeex} {a-ex}~Pxxxxxxxxxx
$sendcx {p-storeex} {a-ex} {t-storeex} A

# load EX from main
defmacro loadex prog
  $pulseamp $prog {p-loadex}
endmacro

# loads EX with A field (sign=P, digits 10 and 9) clear
defmacro loadex-clearA prog
  $pulseamp $prog {p-loadex-clearA}
endmacro

# sends EX to main and clears
defmacro storeex prog
  $pulseamp $prog {p-storeex}
endmacro


# - Register File -
# Registers A-E of the virtual machine. A is our accumulator.
{a-rf}=a4
$acc-main rf

# RF.S is used to negate fields of RF for arithmetic.  Discard sign to avoid
# setting EX.PM to M, which might misfire discrimination.  A 1'p on digit 1
# might cause the E field to carry into D; we don't need -E so just don't
# connect digit 1.
p {a-rf}.S ad.permute.{ad-drop-rf-sign}
s ad.permute.{ad-drop-rf-sign} 0,10,9,8,7,6,5,4,3,2,0
p ad.permute.{ad-drop-rf-sign} {d-main}

if OP_MOVXA6
# i-selectA input: aa 00 XX XX XX -> aa 00 00 00 00
p {d-main} ad.permute.{ad-rf-selectA}
s ad.permute.{ad-rf-selectA} 0,10,9,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selectA} {a-rf}.{i-selectA}
endif

if OP_MOVXA3
# i-selBA input: XX aa XX XX XX -> aa 00 00 00 00, used for MOV BG,A
p {d-main} ad.permute.{ad-rf-selBA}
s ad.permute.{ad-rf-selBA} 0,8,7,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selBA} {a-rf}.{i-selBA}

# i-selCA input: XX XX aa XX XX -> aa 00 00 00 00, used for MOV CH,A
p {d-main} ad.permute.{ad-rf-selCA}
s ad.permute.{ad-rf-selCA} 0,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selCA} {a-rf}.{i-selCA}
endif

# i-selDA input: XX XX XX aa XX -> aa 00 00 00 00, used for MOV DI,A
p {d-main} ad.permute.{ad-rf-selDA}
s ad.permute.{ad-rf-selDA} 0,4,3,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selDA} {a-rf}.{i-selDA}

# i-selEA input: XX XX XX XX aa -> aa 00 00 00 00, used for MOV EJ,A/MOV #X,A
p {d-main} ad.permute.{ad-rf-selEA}
s ad.permute.{ad-rf-selEA} 0,2,1,0,0,0,0,0,0,0,0
p ad.permute.{ad-rf-selEA} {a-rf}.{i-selEA}

# shared programs
if OP_MOVXA3
$recx {p-rf-selBA} {a-rf} {r-rf-selBA} {i-selBA}
$recx {p-rf-selCA} {a-rf} {r-rf-selCA} {i-selCA}
endif
$recx {p-rf-selDA} {a-rf} {r-rf-selDA} {i-selDA}
$recx {p-rf-selEA} {a-rf} {r-rf-selEA} {i-selEA}

$sendx {p-send-rf} {a-rf} {t-send-rf} A
$sendcx {p-sendc-rf} {a-rf} {t-sendc-rf} A

if OP_MOVXA3
$recx {p-loadrf} {a-rf} {t-loadrf} {i-main}
else
$recx {p-loadrf} {a-rf} {r-loadrf} {i-main}
endif

# helper macros
# receive rf from main
defmacro loadrf prog
  $pulseamp $prog {p-loadrf}
endmacro

# send rf on main
defmacro send-rf prog
  $pulseamp $prog {p-send-rf}
endmacro

# send rf on main and clear
defmacro sendc-rf prog
  $pulseamp $prog {p-sendc-rf}
endmacro


# - Load/Store -
# Registers F-J of the virtual machine. 
{a-ls}=a5
$acc-main ls

# Load only the sign. used in STOREACC to preserve DISCFT acc signs
p {d-main} ad.permute.{ad-ls-signonly}
s ad.permute.{ad-ls-signonly} 11,0,0,0,0,0,0,0,0,0,0
p ad.permute.{ad-ls-signonly} {a-ls}.{i-signonly}

if SUB_MOVAX11
# selectA input: aa bb cc dd ee -> aa 00 00 00 00, used in MOV A,F
p {d-main} ad.permute.{ad-movaf-selectA}
s ad.permute.{ad-movaf-selectA} 0,10,9,0,0,0,0,0,0,0,0
p ad.permute.{ad-movaf-selectA} {a-ls}.{i-selectA}
endif

# shared programs
if SUB_MOVAX5
$clearx {p-clearls} {a-ls} {r-clear}
endif
if SUB_MOVAX11
$sendcx {p-sendc-ls} {a-ls} {t-sendc-ls} A
endif

# helper macros
if SUB_MOVAX5
# clear ls
defmacro clearls prog
  $pulseamp $prog {p-clearls}
endmacro
endif

if SUB_MOVAX11
# send on main and clear
defmacro sendc-ls prog
  $pulseamp $prog {p-sendc-ls}
endmacro
endif


# - MEM0 -
# Discriminate memory cycle 0-9 vs. 10-14
{a-mem0}=a6
{a-discmemcyc}=a6
$acc-disc-main discmemcyc

# splitA: Prepare A for disc A<10, and lookup in FT. A1 -> PM, A2 -> digit 1
p {d-main} ad.permute.{ad-discmemcyc}
s ad.permute.{ad-discmemcyc} 10,0,0,0,0,0,0,0,0,0,9
p ad.permute.{ad-discmemcyc} {a-discmemcyc}.{i-splitA}

# drop sign, used to clear LS sign in STOREACC
p {d-main} ad.permute.{ad-discmemcyc-dropsign}
s ad.permute.{ad-discmemcyc-dropsign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-discmemcyc-dropsign} {a-discmemcyc}.{i-dropsign}


# - MEM1 -
# Trigger mem cycle 10-14 on S outputs
{a-mem1}=a7
{a-memcyc1014}=a7
$acc-main mem1

p {a-memcyc1014}.S {d-memcyc1014S}

# i-ftselacc: get 10 digits from FT, for loadacc/storeacc
p {d-ftselacc} {a-memcyc1014}.{i-ftselacc}


# - MEM2 -
# MEM2 is used as a temporary for ops involving RF which can be negative, so it
# must not have any discrimination programs.
{a-mem2}=a8
{a-rftmp}=a8
$acc-main mem2


# - MEM3 -
{a-mem3}=a9
$acc-main mem3


# - MEM4 -
{a-mem4}=a10
{a-swapBCDE}=a10
$acc-main mem4

if OP_SWAP
# Used for swap A,BCDE; OP_SWAP6 shares with MOV instead.

p {d-main} ad.permute.{ad-swapAB}
s ad.permute.{ad-swapAB} 11,8,7,10,9,6,5,4,3,2,1
p ad.permute.{ad-swapAB} {a-swapBCDE}.{i-swapAB}

p {d-main} ad.permute.{ad-swapAC}
s ad.permute.{ad-swapAC} 11,6,5,8,7,10,9,4,3,2,1
p ad.permute.{ad-swapAC} {a-swapBCDE}.{i-swapAC}

p {d-main} ad.permute.{ad-swapAD}
s ad.permute.{ad-swapAD} 11,4,3,8,7,6,5,10,9,2,1
p ad.permute.{ad-swapAD} {a-swapBCDE}.{i-swapAD}

p {d-main} ad.permute.{ad-swapAE}
s ad.permute.{ad-swapAE} 11,2,1,8,7,6,5,4,3,10,9
p ad.permute.{ad-swapAE} {a-swapBCDE}.{i-swapAE}
endif


# - MEM5 -
{a-mem5}=a11
$acc-main mem5


# - MEM6 -
# Programs to compute new PC for JMP FAR/JSR/RET.
{a-mem6}=a12
{a-newpc}=a12

$acc-main mem6

# extract-pc input: XX XXXX PPPP -> 00 0000 PPPP
p {d-main} ad.permute.{ad-extract-pc}
s ad.permute.{ad-extract-pc} 0,0,0,0,0,0,0,4,3,2,1
p ad.permute.{ad-extract-pc} {a-newpc}.{i-extract-pc}

# keep-r input: XX RRRR XXXX -> 00 RRRR 0000
p {d-main} ad.permute.{ad-keep-r}
s ad.permute.{ad-keep-r} 0,0,0,8,7,6,5,0,0,0,0
p ad.permute.{ad-keep-r} {a-newpc}.{i-keep-r}

# shiftr4-pc input: shift XX RRRR PPPP to 00 0000 RRRR
p {d-main} ad.permute.{ad-shiftr4-pc}
s ad.permute.{ad-shiftr4-pc} 0,0,0,0,0,0,0,8,7,6,5
p ad.permute.{ad-shiftr4-pc} {a-newpc}.{i-shiftr4-pc}

# shiftl4-pc input: shift XX XXXX PPPP to XX PPPP 0000
p {d-main} ad.permute.{ad-shiftl4-pc}
s ad.permute.{ad-shiftl4-pc} 0,0,0,4,3,2,1,0,0,0,0
p ad.permute.{ad-shiftl4-pc} {a-newpc}.{i-shiftl4-pc}


# - MEM7 - 
# MEM7 is a13 and is used for printing, has an input that shifts AB into printing position
{a-mem7}=a13
{a-print}=a13
$acc-main mem7

p {d-main} ad.permute.{ad-printAB}
s ad.permute.{ad-printAB} 11,0,10,9,8,7,0,0,0,0,0
p ad.permute.{ad-printAB} {a-mem7}.{i-printAB}


# - MEM8 -
{a-mem8}=a14
$acc-main mem8


# - MEM9 -
# Used for JN/JZ/JIL
{a-mem9}=a15
{a-discjx}=a15
$acc-disc-main discjx

# i-shiftA: Used to shift RF A into digits 1+2 for ft arg
p {d-main} ad.permute.{ad-discjx-shiftA}
s ad.permute.{ad-discjx-shiftA} 0,0,0,0,0,0,0,0,0,10,9
p ad.permute.{ad-discjx-shiftA} {a-discjx}.{i-shiftA}

# i-ftjzsign: get sign for jz discrimination
p f2.A ad.permute.{ad-ftjzsign}
s ad.permute.{ad-ftjzsign} 11,0,0,0,0,0,0,0,0,0,0
p ad.permute.{ad-ftjzsign} {d-ftjzsign}
p {d-ftjzsign} {a-discjx}.{i-ftjzsign}

# i-ftjilsign: get sign for jil discrimination
p f2.B ad.permute.{ad-ftjilsign}
s ad.permute.{ad-ftjilsign} 11,0,0,0,0,0,0,0,0,0,0
p ad.permute.{ad-ftjilsign} {d-ftjilsign}
p {d-ftjilsign} {a-discjx}.{i-ftjilsign}


# - MEM10 -
# Trigger mem cycle 0-9 on S outputs
{a-mem10}=a16
{a-memcyc09}=a16
$acc-main mem10

p {a-memcyc09}.S {d-memcyc09S}

# i-ftselacc: get 10 digits from FT, for loadacc/storeacc
p {d-ftselacc} {a-memcyc09}.{i-ftselacc}



# - MEM11 -
{a-mem11}=a17
{a-movswap}=a17
{a-movfa}=a17
$acc-main mem11

if OP_MOVFA3
# clearA input: S aa bb cc dd ee -> P 00 bb cc dd ee, used in MOV F,A
p {d-main} ad.permute.{ad-movfa-clearA}
s ad.permute.{ad-movfa-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-movfa-clearA} {a-movfa}.{i-clearA}

# selectA input: aa bb cc dd ee -> aa 00 00 00 00, used in MOV F,A
p {d-main} ad.permute.{ad-movfa-selectA}
s ad.permute.{ad-movfa-selectA} 0,10,9,0,0,0,0,0,0,0,0
p ad.permute.{ad-movfa-selectA} {a-movfa}.{i-selectA}
endif

if SUB_MOVSWAP
p {d-main} ad.permute.{ad-movAB}
s ad.permute.{ad-movAB} 11,8,7,10,9,6,5,4,3,2,1
p ad.permute.{ad-movAB} {a-movswap}.{i-movAB}

p {d-main} ad.permute.{ad-movAC}
s ad.permute.{ad-movAC} 11,6,5,8,7,10,9,4,3,2,1
p ad.permute.{ad-movAC} {a-movswap}.{i-movAC}

p {d-main} ad.permute.{ad-movAD}
s ad.permute.{ad-movAD} 11,4,3,8,7,6,5,10,9,2,1
p ad.permute.{ad-movAD} {a-movswap}.{i-movAD}

p {d-main} ad.permute.{ad-movAE}
s ad.permute.{ad-movAE} 11,2,1,8,7,6,5,4,3,10,9
p ad.permute.{ad-movAE} {a-movswap}.{i-movAE}
endif

# shared programs
if SUB_MOVSWAP
$recx {p-movswapAA} {a-movswap} {t-movswapAA} {i-main}
$recx {p-movswapAB} {a-movswap} {r-movswapAB} {i-movAB}
$recx {p-movswapAC} {a-movswap} {r-movswapAC} {i-movAC}
$recx {p-movswapAD} {a-movswap} {r-movswapAD} {i-movAD}
$recx {p-movswapAE} {a-movswap} {t-movswapAE} {i-movAE}
endif


# - MEM12 -
{a-mem12}=a18
$acc-main mem12


# - MEM13 -
{a-mem13}=a19
$acc-main mem13


# - MEM14 -
{a-mem14}=a20
$acc-main mem14


# - Function table decode -
# The PM digits of a18, a19, and a20 select the current function table for
# instruction fetch -- you can think of this as the current ROM bank. 
# The Function Table Selection Group (FTSG), so named by Adele, is the upper two
# digits of the PC and R registers. We use ft1 = 09, ft2 = 90, ft3 = 99.
# This is translated by p-sub-discft using the inputs below into PM=P on the
# selected ft, M otherwise. At fetch time we send on S on all three.

{a-discft1}=a18
{a-discft2}=a19
{a-discft3}=a20

defmacro discftaccum name ftnum
  # S.PM is wired to a dummy program to trigger an FT
  p {a-$name}.S ad.dp.{ad-$name-discft$ftnum}.11
  p ad.dp.{ad-$name-discft$ftnum}.11 {p-trigger-ft$ftnum-pm}
  $dummy-exclude {p-trigger-ft$ftnum-pm} {p-trigger-ft$ftnum} -{a-discft1},{a-discft2},{a-discft3}

  # i-ftsg1 puts the ftsg1 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg1}
  s ad.permute.{ad-$name-ftsg1} 3,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg1} {a-$name}.{i-ftsg1}

  # i-ftsg2 puts the ftsg2 digit in PM
  p {d-main} ad.permute.{ad-$name-ftsg2}
  s ad.permute.{ad-$name-ftsg2} 4,0,0,0,0,0,0,0,0,0,0
  p ad.permute.{ad-$name-ftsg2} {a-$name}.{i-ftsg2}
endmacro

# Strictly speaking only discft3 needs both i-ftsg1 and i-ftsg2 inputs but we
# are not constrained on inputs for these accumulators.
if CONTROL_CYCLE
$discftaccum discft1 1
$discftaccum discft2 2
$discftaccum discft3 3
endif

# discft1 is also used to form intitial PC address on reset
# resetPC input: takes M0 from bus, sets initial PC to 0900
p {d-main} ad.permute.{ad-pc-reset}
s ad.permute.{ad-pc-reset} 0,0,0,0,0,0,0,0,11,0,0
p ad.permute.{ad-pc-reset} {a-discft1}.{i-resetPC}



# - Constant transmitter -
# So that we can use all the constant switches, connect both the left and the
# right 5 constant digits to the leftmost wires of d-main where they're needed.
# This is perhaps electrically questionable, but should work?  Provided the
# right constants are positive, there should be no bus conflicts - if they were
# negative, the constant transmitter would also drive 9s onto the same wires
# for sign extension.
p c.o ad.permute.{ad-constant-left}
s ad.permute.{ad-constant-left} 11,10,9,8,7,6,0,0,0,0,0
p ad.permute.{ad-constant-left} {d-main}
p c.o ad.permute.{ad-constant-right}
# (Delete sign so that eniacsim doesn't send two copies of the sign pulses...)
s ad.permute.{ad-constant-right} 0,5,4,3,2,1,0,0,0,0,0
p ad.permute.{ad-constant-right} {d-main}

# M99000 used in control cycle, DEC
s c.jl  M
s c.j10 9
s c.j9  9

# M00000 used in control cycle to fill consumed op with 99, machine reset
s c.kl  M
s c.k10 0
s c.k9  0

# whenever you need a 9 on the bus, call sendM0 (goes through a pulseamp)
defmacro sendM0 prog
  $pulseamp $prog c.25i
endmacro
s c.s25 Kl

# P43000 used in control cycle, to test opcode > 55. 43 = 99-55-1
s c.kr P
s c.k5 4
s c.k4 3

# P01000 used in control cycle, INC
s c.jr P
s c.j5 0
s c.j4 1


# - Setup MP as an opcode decoder -
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6

# This switch setting makes eniacsim disable/disassociate MP decade counters.
#
# Decade counters are a problem for decoding because they trigger a spurious
# extra step whenever they overflow, and they count in a data-dependent way on
# each program input (e.g. p.Ai, p.Bi, ...). Possibly some scheme could be
# devised to guarantee decade counters are safe before p.Ai for decode - they
# don't have an explicit clear control, but do clear on overflow.  But it's far
# simpler just to unplug the things.
#
# Associator switches on the MP front panel don't permit disconnecting decade
# counters, but the operating manual notes "To disassociate a decade from its
# stepper pull out gate tube 63 in the stepper plug-in unit. See block diagram
# PX-8-304."
s p.gate63 unplug

# Receive opcode at master programmer stepper direct inputs
p {d-main} ad.dp.{ad-opcode-10}.10   # opcode 10's digit (0x-5x)
p ad.dp.{ad-opcode-10}.10 p.Adi
p {d-main} ad.dp.{ad-opcode-9}.9     # opcode 1's digit (0x-5x)
p ad.dp.{ad-opcode-9}.9 p.Bdi
p ad.dp.{ad-opcode-9}.9 p.Cdi
p ad.dp.{ad-opcode-9}.9 p.Ddi
p ad.dp.{ad-opcode-9}.9 p.Edi
p ad.dp.{ad-opcode-9}.9 p.Fdi
p ad.dp.{ad-opcode-9}.9 p.Gdi        # opcode 1's digit (0x-5x) or 10's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Hdi      # opcode 1's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Jdi
p ad.dp.{ad-opcode-10}.10 p.Kdi

# Trigger the appropriate ones digit for opcodes <= 55
p p.A1o p.Bi
p p.A2o p.Ci
p p.A3o p.Di
p p.A4o p.Ei
p p.A5o p.Fi
p p.A6o p.Gi

if CONTROL_CYCLE
# For opcodes>55, Gi is triggered both by A6o when decoding 5x, and explicitly
# via a program control to decode the tens digit of 7x-9x.
$pulseamp {p-mp-789x} p.Gi
endif


# Wire the outputs to individual opcode programs
# outputs rotated with respect to digits as we decode I1+1
defmacro op-lines-le55 stepper tens
  p p.$stepper1o {p-op$tens5}
  p p.$stepper2o {p-op$tens0}
  p p.$stepper3o {p-op$tens1}
  p p.$stepper4o {p-op$tens2}
  p p.$stepper5o {p-op$tens3}
  p p.$stepper6o {p-op$tens4}
endmacro

$op-lines-le55 B 0
$op-lines-le55 C 1
$op-lines-le55 D 2
$op-lines-le55 E 3
$op-lines-le55 F 4
# G1o-G3o are used for 7x-9x.
p p.G4o {p-op52}
p p.G5o {p-op53}
p p.G6o {p-op54}

# Trigger the appropriate ones digit for opcodes >= 70.
p p.G1o p.Hi
p p.G2o p.Ji
p p.G3o p.Ki

# Rotated because we decode on PC.S for op>55, so this is 99-(OP+1) = 100-OP.
# TODO Confirm MP steppers increment from 6 to 1 - we're assuming so here for
# nicer opcode numbering.
defmacro op-lines-gt55 stepper tens
  p p.$stepper1o {p-op$tens2}
  p p.$stepper2o {p-op$tens1}
  p p.$stepper3o {p-op$tens0}
  p p.$stepper4o {p-op$tens5}
  p p.$stepper5o {p-op$tens4}
  p p.$stepper6o {p-op$tens3}
endmacro

$op-lines-gt55 H 9
$op-lines-gt55 J 8
$op-lines-gt55 K 7

if RESET_SEQUENCE

# -- RESET --
# Builtin clearing should first set all accumulators to 0
p i.io {p-reset}

# Reset PC, IR, and initial ft selector accumulators
# Send M00000
$sendM0 {p-reset}

# Set discft2/discft3 signs to M so that ft1 is selected via discft1.PM = P
$rec {p-reset} {a-discft2} {t-reset} {i-main} {p-reset-2}
$recx {p-reset} {a-discft3} {r-reset} {i-main}

# IR to M0 so we trigger a fetch
$recx {p-reset} {a-ir} {r-reset} {i-main}

# Set discft1 to 0900 which is the initial PC, then copy to PC (out of PC inputs)
$recx {p-reset} {a-discft1} {r-reset} {i-resetPC}

# Reset PC from discft1, clear, and fetch first instruction
$sendc {p-reset-2} {a-discft1} {t-reset-2} A {p-fetch}
$loadpc {p-reset-2}

endif # RESET_SEQUENCE


if CONTROL_CYCLE

# -- CONTROL CYCLE --

# -- p-fetch: begin next instruction
# During this cycle:
#  - discriminate, to decide whether to fetch new instructions, clear IR
#  - read out the contents of IR into EX
#  - send next instruction (I1) to PC (assume PC.SS is 0)
$assert {p-fetch} {a-ex}~P0000000000
$assert {p-fetch} {a-pc}~x00xxxxxxxx

# If more instructions are needed, IR is M0, and control proceeds to p-fetchline.
# Otherwise, IR is P I5 I4 I3 I2 I1+1 and we trigger p-nofetch-eat-op.
$discriminatec {p-fetch} {a-ir} {d-irA} {d-irS} {p-nofetch-eat-op} {p-fetchline}

# IR -> EX 
# $discriminatec sends IR=I5 I4 I3 I2 I1+1 on d-main, and EX receives it permuted
# as I1+1 I5 I4 I3 I2. This puts the next instruction in the left (first two
# digits) of EX for opcode discrimination.
$recx {p-fetch} {a-ex} {r-fetch} {i-rotate-ir}

# IR -shiftl8-> PC
# Also send first opcode to left of PC. This copy of the instruction will later be
# sent to MP steppers for decoding.
$recx {p-fetch} {a-pc} {r-fetch} {i-shiftl8}


# -- {p-nofetch} no fetch needed, begin instruction decode
$pulseamp {p-nofetch-eat-op} {p-nofetch}
# PC has I1+1 at left
# EX is P I1+1 I5 I4 I3 I2
$assert {p-nofetch} {a-ex}~Pxxxxxxxxxx

# Begin decode by adding 43 to EX, from constant transmitter

# Send 43 from CT on d-main
p {p-nofetch} c.26i 
s c.s26 Kr
p c.26o {p-disc-op}

# EX += 43 for opcode discrimination next cycle
# EX = I1+1
# If I1 <= 55 then I1+1+43 < 100, EX still P
# If I1 > 55 then I1+1+43 >= 100, EX now M
$loadex {p-nofetch}

# If we are eating an operand (removing it from IR) then we need to set
# the top digits of IR to 99 after next instruction (delay 1 cycle)
$dummy {p-nofetch-eat-op} {p-eat-op}


# -- {p-disc-op} discriminate opcode I1>55, to switch between two decode pathways
# EX starts P/M I1+44 I5 I4 I3 I2 and ends clear.
# Also store I5..I2 back to IR, replacing just-dispatched opcode with 99 if p-eat-op.
$assert {p-eat-op} {a-ir}~P0000000000

# Discriminate based on sign of EX, already set based on whether I1 > 55. Clear EX.
$discriminatec {p-disc-op} {a-ex} {d-exA} {d-exS} {p-ople55} {p-opgt55}

# If we are consuming from IR, store EX back into IR without the op we are now decoding.
# Replace first two digits with M from a constant, so the top of IR is
# P99. Finally, increment so that an empty IR, P9999999999, wraps to M0000000000.
# This also turns I2 into I2+1 at the right of IR.
$recincx {p-eat-op} {a-ir} {r-disc-op} {i-fill99}
# Send M00000 from the constant transmitter to fix IR.  EX doesn't send a sign
# on d-main so there's no bus conflict.
$sendM0 {p-eat-op}

# Clear MP prior to decode.  Clearing isn't synchronous, so this needs to
# happen "next cycle" i.e. during pulse 17 of p-disc-op.
$dummy {p-disc-op} {p-clear-mp}
p {p-clear-mp} p.Acdi
p {p-clear-mp} p.Bcdi
p {p-clear-mp} p.Ccdi
p {p-clear-mp} p.Dcdi
p {p-clear-mp} p.Ecdi
p {p-clear-mp} p.Fcdi
p {p-clear-mp} p.Gcdi
p {p-clear-mp} p.Hcdi
p {p-clear-mp} p.Jcdi
p {p-clear-mp} p.Kcdi


# -- p-ople55 - send tens digit of opcode to stepper A, ones digit to B-G
# Also PC->EX to begin clearing SS 
$assert {p-ople55} {a-ex}~P0000000000

# Send PC on main and receive in EX with SS (opcode field) clear.
$sendc {p-ople55} {a-pc} {t-ople55} A {p-ople55-2}
$loadex-clearA {p-ople55}


# -- p-ople55-2 - send input pulse to master programmer
# sign of EX must be P to avoid misfiring p-ople55
$assert {p-ople55-2} {a-pc}~P0000000000
$assert {p-ople55-2} {a-ex}~P00xxxxxxxx

# Send EX back to PC with opcode field clear to prep for instruction.
# Note that this would trigger the MP steppers, but the opcode field contains
# 00 here so this doesn't mess up decode.
$sendcx {p-ople55-2} {a-ex} {t-ople55-2} A
$loadpc {p-ople55-2}

# Trigger master programmer
p {p-ople55-2} p.Ai


# -- p-opgt55 - send tens digit to mp G stepper, ones digit to H-K
$assert {p-opgt55} {a-ex}~P0000000000

# Send PC subtractively on main, stepping the MP, and receiving in EX.
# Note that EX receives the 10's complement of PC, so will include an extra +1
# from the 1pp. This is undone when sending EX back to PC subtractively next
# cycle.
$sendc {p-opgt55} {a-pc} {t-opgt55} S {p-opgt55-2}
$loadex {p-opgt55}


# -- p-opgt55-2 - send input pulse to master programmer
# Sign of EX must be M to avoid misfiring p-ople55 (triggered from a-ex.S sign)
$assert {p-opgt55-2} {a-ex}~Mxxxxxxxxxx

# EX back to PC, with opcode field (SS) cleared
# Note #1: This is arithmetically incorrect. PC receives the 9's complement of
# EX with 0s in the opcode field, then an extra +1 from the 1pp. If PC were
# Pxx00000000, this would give P0099999999 and the 1pp would cause a carry into
# the opcode field leaving it P01... instead of P00. That can't happen because
# PC.PPPP always begins with 09, 90, or 99, so there's no possibility of a
# carry into digit 9.
# Note #2: EX.S is not connected to d-main. If it were, this would cause
# spurious MP inputs.
$sendcx {p-opgt55-2} {a-ex} {r-opgt55-2} S
$recx {p-opgt55-2} {a-pc} {r-opgt55-2} {i-exS-clearA}

# Trigger master programmer.
p {p-opgt55-2} {p-mp-789x}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# Trigger the currently selected FT to send
$sendx {p-fetchline} {a-discft1} {r-fetchline} S 
$sendx {p-fetchline} {a-discft2} {r-fetchline} S
$send {p-fetchline} {a-discft3} {t-fetchline} S {p-fetchtrig} # save r for r-memcyc 

# FT settings
defmacro triggerft num
  p {p-trigger-ft$num} f$num.1i
  s f$num.rp1 1                    # send once in p-fetchread
  # TODO switch to A+2 addressing to minimize overlap with accumulator decode
  s f$num.op1 A0                   # send uncomplemented, don't offset argument
endmacro
$triggerft 1
$triggerft 2
$triggerft 3


# -- {p-fetchtrig}
# FT is "stimulated" in this cycle, from discft1-3 S output
# Meanwhile, clear IR (needed only on jumps, otherwise already zero here from overflow)
$clear {p-fetchtrig} {a-ir} {t-fetchtrig} {p-fetcharg}


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)
$send {p-fetcharg} {a-pc} {t-fetcharg} A {p-preinc-fetch}
p {d-main} f1.arg  # only bottom two digit lines connect so no deleter is required
p {d-main} f2.arg
p {d-main} f3.arg


# -- {p-preinc-fetch} preincrement left field of EX and PC
$assert {p-preinc-fetch} {a-ex}~P0000000000
$assert {p-preinc-fetch} {a-pc}~P00xxxxxxxx

# Send P01000 from the constant transmitter
p {p-preinc-fetch} c.28i
s c.s28 Jr
p c.28o {p-await-fetchread}

# Preload P01 into EX and PC so that when the FT sends I1, EX and PC will end
# up I1+1 which is the precondition in p-nofetch.
$loadex {p-preinc-fetch}
$loadpc {p-preinc-fetch}


# -- {p-await-fetchread}
# Nothing happens, just waiting for ft
# because main is idle this cycle, use ct as a dummy, don't care what it sends
p {p-await-fetchread} c.22i
p c.22o {p-fetchread}


# -- {p-fetchread} read ft line of instructions
#  - FT sends uncomplemented instructions on A and B
#  - IR = P I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = P I1+1 00 00 00 00 = A6A5+1 00 00 00 00
#  - PC = P I1+1 xx xx xx PC+1

# B2B1 B4B3 B6B5 A2A1 A4A3 -> IR
p f1.A {d-fA}
p f2.A {d-fA}
p f3.A {d-fA}
p {d-fA} ad.permute.{ad-fetchA}
s ad.permute.{ad-fetchA} 0,0,0,0,0,0,0,2,1,4,3
p ad.permute.{ad-fetchA} {d-fetch}

p f1.B ad.permute.{ad-fetchB}
p f2.B ad.permute.{ad-fetchB}
p f3.B ad.permute.{ad-fetchB}
s ad.permute.{ad-fetchB} 0,2,1,4,3,6,5,0,0,0,0
p ad.permute.{ad-fetchB} {d-fetch}

# Increment IR to make the rightmost instruction I2+1 instead of I2
$recinc {p-fetchread} {a-ir} {t-fetchread} {i-fetch} {p-nofetch}

# A6A5 00 00 00 00 -> EX,PC
p {d-fA} ad.permute.{ad-fetch-ex}
s ad.permute.{ad-fetch-ex} 0,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-fetch-ex} {d-fetch-i1}

# Get I1+1 in the top of EX and PC, and increment PC
$recx {p-fetchread} {a-ex} {t-fetchread} {i-fetch-i1}
$recincx {p-fetchread} {a-pc} {r-fetchread} {i-fetch-i1}

endif # CONTROL_CYCLE


# -- MICRO-SUBROUTINES --
# Sequences shared between instructions

if SUB_CONSUME_OP

# - CONSUME-OP -
# Consume opcode: used to read immediate operands
# Sends IR on first cycle, I1 can be read off as needed
# Rotates IR back to EX, shifts right, places 99 at left, adds 1
# This mimics how the control cycle works in microcosm
# Always retriggers p-fetch

defmacro consume-op prog
  $pulseamp $prog {p-sub-consume-op}
endmacro

$assert {p-sub-consume-op} {a-ir}~Pxxxxxxxxxx  # so fetch/nofetch discrim does not trigger

# IR -rotate-r-> EX
$sendc {p-sub-consume-op} {a-ir} {t-consume-op} A {p-sub-consume-op-2}
$recx {p-sub-consume-op} {a-ex} {t-consume-op} {i-rotate-ir}  # out of recievers

# EX -fill99-> IR 
# Put shifted instructions back in IR, filling top with 99, +1 to detect IR empty
$storeex {p-sub-consume-op-2}
$recinc {p-sub-consume-op-2} {a-ir} {t-consume-op-2} {i-fill99} {p-fetch}

# fill99 requires an M0 on the bus
$sendM0 {p-sub-consume-op-2}

endif # SUB_CONSUME_OP


if SUB_JMP

# - JMP -
# Short jump (2 digits, no FT switch) to immediate operand

defmacro jmp prog
  $pulseamp $prog {p-sub-jmp}
endmacro

# Clear lower digits of PC (not ftsg, this is a near jump)
# PC -clearPC2-> EX
$sendc {p-sub-jmp} {a-pc} {t-sub-jmp} A {p-sub-jmp-2}
$recx {p-sub-jmp} {a-ex} {t-sub-jmp} {i-clearPC2} 

# EX -> PC
$storeex {p-sub-jmp-2}
$rec {p-sub-jmp-2} {a-pc} {t-sub-jmp-2} {i-main} {p-sub-jmp-3}

# Copy next word in IR to PC, then fetchline. Because we jump, don't need to update IR
$sendx {p-sub-jmp-3} {a-ir} {r-send} A
$rec {p-sub-jmp-3} {a-pc} {t-sub-jmp-3} {i-loadPC2} {p-fetchline} 

endif # SUB_JMP


if SUB_DISCFT

# - DISCFT -
# The common receive portion of the sequence to select ft from PC ftsg
# Note that applying this twice is a NOP. So for far jumps (JMP FAR/JSR/RET)
# we invoke once with current PC, then update FTSG, and call again.

defmacro discft prog
  $pulseamp $prog {p-sub-discft}
endmacro

# Decode discft1 and discft2 signs
$recx {p-sub-discft} {a-discft1} {r-sub-discft} {i-ftsg2}
$rec {p-sub-discft} {a-discft2} {t-sub-discft} {i-ftsg1} {p-sub-discft-2}
$recx {p-sub-discft} {a-discft3} {r-sub-discft} {i-ftsg1}

# Finish decoding discft3 sign
$recx {p-sub-discft-2} {a-discft3} {r-sub-discft-2} {i-ftsg2}

endif # SUB_DISCFT


if SUB_FARGO
# Select a new PC and return address and go to p-fetchline
# 1. NEWPC -> EX
# 2. (JMP FAR) IR -extract-pc -> NEWPC
#    (JSR)     IR -extract-pc -> NEWPC
#    (RET)     nop
# 3. (JMP FAR) PC -keep-r     -> NEWPC  $discft-1
#    (JSR)     PC -shiftl4-pc -> NEWPC  $discft-1
#    (RET)     PC -shiftr4-pc -> NEWPC  $discft-1
# 4. (send PC)                 $discft-2
# 5. NEWPC -> PC             $discft-1
# 6. (send NEWPC)            $discft-2
#  . EX -> NEWPC             (parallel with p-fetchline)
#
# TODO investigate alternative 5-cycle sequence that moves up IR->NEWPC
# Is it worth the extra resource usage?
# 1. NEWPC -> EX
# 2. (JMP FAR) PC -keep-r     -> NEWPC  $discft-1
#    (JSR)     PC -shiftl4-pc -> NEWPC  $discft-1
#    (RET)     PC -shiftr4-pc -> NEWPC  $discft-1
# 3. (send PC)                            $discft-2
# 4. (JMP FAR) IR -extract-pc -> NEWPC  $discft-1
#    (JSR)     IR -extract-pc -> NEWPC  $discft-1
#    (RET)     send NEWPC               $discft-1
# 5. NEWPC -> PC                        $discft-2
#  . EX -> NEWPC             (parallel with p-fetchline)
defmacro fargo prog
  $pulseamp $prog {p-sub-fargo}
endmacro

# Save newpc in ex
$sendc {p-sub-fargo} {a-newpc} {t-sub-fargo} A {p-sub-fargo-2}
$loadex {p-sub-fargo}

# Set new PC from IR (JMP FAR/JSR) or nop (RET)
$rec {p-sub-fargo-2} {a-newpc} {t-sub-fargo-2} {i-extract-pc} {p-sub-fargo-3}

# Set new return address from PC (all) and deselect current FT
$sendc {p-sub-fargo-3} {a-pc} {t-sub-fargo-3} A {p-sub-fargo-5}
s {a-pc}.rp{t-sub-fargo-3} 2
$discft {p-sub-fargo-3}

# Select new function table and update PC
$sendc {p-sub-fargo-5} {a-newpc} {t-sub-fargo-5} A {p-sub-fargo-7}
s {a-newpc}.rp{t-sub-fargo-5} 2
$discft {p-sub-fargo-5}
$loadpc {p-sub-fargo-5}

# Restore newpc from ex in parallel with p-fetchline
$pulseamp {p-sub-fargo-7} {p-fetchline}
$storeex {p-sub-fargo-7}
$recx {p-sub-fargo-7} {a-newpc} {r-sub-fargo-7} {i-main}

endif # SUB_FARGO


if SUB_CLEARA

# - CLEARA -
# clear A register in RF
defmacro clearA prog
  $pulseamp $prog {p-sub-clearA}
endmacro

# RF -clearA-> EX
$sendc {p-sub-clearA} {a-rf} {t-sub-clearA} A {p-sub-clearA-2}
$loadex-clearA {p-sub-clearA}

# EX -> RF
$storeex {p-sub-clearA-2}
$loadrf {p-sub-clearA-2}

endif # SUB_CLEARA


# - Memory Cycle -
# Implements LOADACC/STOREACC by decoding memacc index in A, triggering memory cycle
# program on the appropriate accumulator. 
if SUB_MEMCYC

# Wiring to send rightmost 10 digits of f3, plus PMA, to d-ftselacc
# used for loadacc, storeacc
# PMA A4A3 A2A1 B6B5 B4B3 B2B1 -> d-ftselacc
p f3.A ad.permute.{ad-decodeA}
s ad.permute.{ad-decodeA} 11,4,3,2,1,0,0,0,0,0,0
p ad.permute.{ad-decodeA} {d-ftselacc}
p f3.B {d-ftselacc}

# Create the memory cycle program for each acc
# Start with a dummy triggered from memcyc[09|1014].S. Delays one cycle (delay=2, as delay-2 
# means very next cycle when triggered from digit pulses). Then send/clear, then receive. 
# In this way the same program can be used for both load and store operations
defmacro memcyc-prog x range
  $dummy-delay-exclude {p-memcyc$x} 2 {p-memcyc$x-2} -{a-memcyc$range}
  $sendc {p-memcyc$x-2} {a-mem$x} {t-memcyc-2} A {p-memcyc$x-3}
  $recx  {p-memcyc$x-3} {a-mem$x} {r-memcyc-3} {i-main}
endmacro

# Patch one digit of d-memcyc09S to a send reciever program on mem0..mem9
# shift to get desired digit in 2 position, then use digit select adapter
# 2 position because 1 position always generates 1'P pulse on S send. This
# means trigger for 9 is stored in PM digit
defmacro select-memcyc09-acc x
  p {d-memcyc09S} ad.s.{ad-memcyc-$x}.-$x
  p ad.s.{ad-memcyc-$x}.-$x ad.dp.{ad-memcyc-dp$x}.2
  p ad.dp.{ad-memcyc-dp$x}.2 {p-memcyc$x}
endmacro

# Decode and allocate the memcyc programs for each acc
defmacro connect-memcyc09 x 
  $select-memcyc09-acc $x
  $memcyc-prog $x 09
endmacro

$connect-memcyc09 0
$connect-memcyc09 1
$connect-memcyc09 2
$connect-memcyc09 3
if OP_SWAP6
  $connect-memcyc09 4
endif
$connect-memcyc09 5
$connect-memcyc09 6
$connect-memcyc09 7
$connect-memcyc09 8
$connect-memcyc09 9

if OP_SWAP
  # a-mem4 is also used for SWAP which needs all its t- programs, so memcyc4 must
  # use r- programs with dummies elsewhere.
  $select-memcyc09-acc 4
  $dummy-delay-exclude {p-memcyc4} 2 {p-memcyc4-2} -{a-memcyc09},{a-mem4}
  $sendcx {p-memcyc4-2} {a-mem4} {r-memcyc-2} A
  $dummy-exclude {p-memcyc4-2} {p-memcyc4-3} -{a-memcyc09},{a-mem4}
  $recx {p-memcyc4-3} {a-mem4} {r-memcyc-3} {i-main}
endif


# similar for 10-14
defmacro select-memcyc1014-acc x minus10
  p {d-memcyc1014S} ad.s.{ad-memcyc-$x}.-$minus10
  p ad.s.{ad-memcyc-$x}.-$minus10 ad.dp.{ad-memcyc-dp$x}.2
  p ad.dp.{ad-memcyc-dp$x}.2 {p-memcyc$x}
endmacro

# Decode and allocate the memcyc programs for each acc
defmacro connect-memcyc1014 x minus10
  $select-memcyc1014-acc $x $minus10
  $memcyc-prog $x 1014
endmacro

$connect-memcyc1014 10 0
$connect-memcyc1014 11 1
$connect-memcyc1014 12 2
$connect-memcyc1014 13 3
$connect-memcyc1014 14 4


# Start by saving DISCMEMCYC -> EX, clear
$sendc {p-sub-memcyc} {a-discmemcyc} {t-sub-memcyc} A {p-sub-memcyc-2}
$loadex {p-sub-memcyc}

# send A to DISCMEMCYC, first digit into sign: X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1
$send-rf {p-sub-memcyc-2}
$rec {p-sub-memcyc-2} {a-discmemcyc} {t-sub-memcyc-2} {i-splitA} {p-sub-memcyc-3}

# trigger FT this cycle
p {p-sub-memcyc-2} f3.2i
s f3.op2 A-2

# Discriminate: are we reading from 0-9 (pos) or 10-14 (neg)?
# Always triggers {p-sub-memcyc-4} next cycle, but wait 2 cycles before triggering 
# conditional branches (p-sub-memcyc09 vs p-sub-memcyc1014), as the next op is shared
# Since we're sending DISCMEMCYC.A to main anyway, ft arg is also loaded this cycle 
$discriminatec-delay-passthru {p-sub-memcyc-3} {a-discmemcyc} {d-discmemcycA} {d-discmemcycS} 2 {p-sub-memcyc-4} {p-sub-memcyc09} {p-sub-memcyc1014}

# Shared step post discriminate, executed regardless of branch taken
# EX -> DISCMEMCYC, restore it
$rec {p-sub-memcyc-4} {a-discmemcyc} {t-sub-memcyc-4} {i-main} {p-sub-memcyc-5}
$storeex {p-sub-memcyc-4}

# Now wait 5 cycles until the address is decoded, and acc memory cycle step 2
# Use RF program as it's not a memory accumulator or LS
# XXX could really be an FT dummy
$manual-dummy {p-sub-memcyc-5} {a-rf} {t-sub-memcyc5} 5 {p-sub-memcyc-6}


# POSITIVE (0-9) and NEGATIVE (10-14) branches of discriminate differ only on which acc
defmacro sub-memcyc-branch x
  # Save MEMCYC$x -> EX, clear
  $sendc {p-sub-memcyc$x} {a-memcyc$x} {t-sub-memcyc$x} A {p-sub-memcyc$x-2}
  $loadex {p-sub-memcyc$x}

  # FT -> MEMCYC$x, read FT line when it's ready
  $rec {p-sub-memcyc$x-2} {a-memcyc$x} {t-sub-memcyc$x-2} {i-ftselacc} {p-sub-memcyc$x-3}

  # MEMCYC$x -S-> trigger memXX loadstore
  # Now MEMCYC$x is all 9 except for a 0 for the accumulator we want. When we send on S,
  # it will activate the loadstore program of one accumulator. Clear as we do this,
  # so we can restore from EX later
  $sendc {p-sub-memcyc$x-3} {a-memcyc$x} {t-sub-memcyc$x-3} S {p-sub-memcyc$x-4}

  # restore MEMCYC$x
  $recx {p-sub-memcyc$x-4} {a-memcyc$x} {r-sub-memcyc$x-4} {i-main}
  $storeex {p-sub-memcyc$x-4}
endmacro

$sub-memcyc-branch 09
$sub-memcyc-branch 1014

# Now the "memory cycle" proper. Each mem acc will execute a sendc then rec
# For load we do: main -> LS, LS -> main
# For store just: LS - >main
# Therefore put just the LS -> main in this shared program, we always want it

# LS -> MEMXX, restore accumulator value, then next op
$send {p-sub-memcyc-6} {a-ls} {t-sub-memcyc-7} A {p-fetch}

endif # SUB_MEMCYC


if SUB_DISCJX
# Discriminate for conditional jump, shared by JZ and JIL
# Continues on to SUB_JX and fetch.
# 1. DISCJX -> EX, clear
# 2. RF -shiftA-> DISCJX, trigger ft2
# 3. DISCJX -> ft2.arg
# 4. wait
# 5. wait
# 6. [ft2.[AB]xxS -> DISCJX]  # sign selected by caller
# 7. p-sub-jx

# save DISCJX
$sendc {p-sub-discjx} {a-discjx} {t-sub-discjx} A {p-sub-discjx-2}
$loadex {p-sub-discjx}

# RF -shiftA-> DISCJX
$send-rf {p-sub-discjx-2}
$rec {p-sub-discjx-2} {a-discjx} {t-sub-discjx-2} {i-shiftA} {p-sub-discjx-3}

# trigger ft2
p {p-sub-discjx-2} f2.2i
s f2.rp2 1
s f2.op2 A0

# send ft arg
$sendx {p-sub-discjx-3} {a-discjx} {r-sub-discjx-3} A

# caller receives ft sign in p-sub-discjx-6
# continue to conditional jump sub in cycle 7
p f2.2o {p-sub-jx}

endif


if SUB_JX

# - JX -
# Conditional jump sequence, always ends up back at control cycle

# discriminate, and clear to ready DISCJX for restored memory value
# P = not taken, M = taken
$discriminatec {p-sub-jx} {a-discjx} {d-discjxA} {d-discjxS} {p-sub-jx-not-taken} {p-sub-jx-taken}

# if not taken, restore acc, consume and carry on
$storeex {p-sub-jx-not-taken}
$rec {p-sub-jx-not-taken} {a-discjx} {t-sub-jx-not-taken} {i-main} {p-sub-jx-eat}

# update ir and trigger p-fetch
$consume-op {p-sub-jx-eat}

# if taken, restore acc and jump
$storeex {p-sub-jx-taken}
$rec {p-sub-jx-taken} {a-discjx} {t-sub-jx-taken} {i-main} {p-sub-jmp}

endif # SUB_JX


if SUB_MOVSWAP

# - MOVSWAP -
# 1. MOVSWAP -> EX
# 2. nop          [ (RF or LS) -mov[BCDE]-> MOVSWAP ]
# 3. send MOVSWAP [ MOVSWAP -selectA-> RF  or  MOVSWAP -> RF ]
# 4. EX -> MOVSWAP, (if not SUB_MOVAX11: goto fetch)
defmacro movswap prog
  $pulseamp $prog {p-sub-movswap}
endmacro

# Save movswap
$sendcx {p-sub-movswap} {a-movswap} {t-sub-movswap} A
$loadex {p-sub-movswap}
$manual-dummy {p-sub-movswap} a18 {t-sub-movswap} 2 {p-sub-movswap-3}

# Get desired field of RF or LS in A position
# (not shared)

# Update RF
$sendc {p-sub-movswap-3} {a-movswap} {t-sub-movswap-3} A {p-sub-movswap-4}

# Restore movswap and go to fetch
$storeex {p-sub-movswap-4}
if SUB_MOVAX11
  # Do not fall through to fetch because $movswap is used for SUB_MOVAX11
  $recx {p-sub-movswap-4} {a-movswap} {t-sub-movswap-4} {i-main}
else
  $rec {p-sub-movswap-4} {a-movswap} {t-sub-movswap-4} {i-main} {p-fetch}
endif

endif # SUB_MOVSWAP


if SUB_MOVAX11

# The idea here is to build mov A,F which is cheap, reuse SUB_MOVSWAP to get
# SWAP F,[GHIJ], and then implement mov A,GHIJ as
#   swap F,[GHIJ] ; 4
#   mov A,F       ; 3
#   swap F,[GHIJ] ; 4
#
# This still isn't cheap, though:  we need 10 dummies for the outer sequence, 8
# of which trigger the right exchange for swap twice.  mov A,F and swap F take
# at least 3 t's, $movswap can no longer fall through to p-fetch so we need
# dummies for its other callers.  We also need a bunch of pas since we run out
# of t's on LS.
#
# TODO We could also do something like
#   swapall       ; 3
#   swap A,[BCDE] ; 4
#   mov F,A       ; 6
#   swap A,[BCDE] ; 4
#   swapall       ; 3
# and could then reuse existing ops.  But we'd still need to modify those ops to
# dummy back to fetch, would need long dummies around mov F,A and for sequencing,
# and this costs 20 cycles...

# - MOV A,F -
# 1. LS -clearA-> EX
# 2. EX -> LS
# 3. RF -selectA-> LS
defmacro movaf prog
  $pulseamp $prog {p-sub-movAF}
endmacro

# send LS FGHIJ and receive in EX with F clear
$sendc-ls {p-sub-movAF}
$loadex {p-sub-movAF}
$dummy {p-sub-movAF} {p-sub-movAF-2}

# get LS 0GHIJ back in LS
$i-dummy {p-sub-movAF} {p-storeex}
$rec {p-sub-movAF-2} {a-ls} {t-sub-movAF-2} {i-main} {p-sub-movAF-3}

# read RF A into F position in LS
$i-dummy {p-sub-movAF-2} {p-send-rf}
$recx {p-sub-movAF-3} {a-ls} {t-sub-movAF-3} {i-selectA}


# - SWAP F,[GHIJ] -
#  1. MOVSWAP -> EX
#  2. LS -mov[BCDE]-> MOVSWAP
#  3. MOVSWAP -> LS
#  4. EX -> MOVSWAP
defmacro swapf prog
  $pulseamp $prog {p-sub-swapf}
endmacro

$movswap {p-sub-swapf}
$dummy-exclude {p-sub-swapf} {p-sub-swapf-2} -a8,a18,{a-movswap}

$sendc-ls {p-sub-swapf-2}
# trigger p-movswapAX
$dummy-exclude {p-sub-swapf-2} {p-sub-swapf-3} -a8,a18,{a-movswap}

$recx {p-sub-swapf-3} {a-ls} {t-sub-swapf-3} {i-main}


# - MOV A,[GHIJ] -
# 1-4.  swap F,[GHIJ]
# 5-7.  mov A,F
# 8-11. swap F,[GHIJ]

$pulseamp {p-sub-movAG} {p-sub-movAX}
$pulseamp {p-sub-movAH} {p-sub-movAX}
$pulseamp {p-sub-movAI} {p-sub-movAX}
$pulseamp {p-sub-movAJ} {p-sub-movAX}

$manual-dummy {p-sub-movAX} a8 {t-sub-movAX} 4 {p-sub-movAX-5}
p {p-sub-movAX} f2.11i
s f2.rp11 3
p f2.11o {p-sub-movAX-8}

$i-dummy {p-sub-movAG} {p-movswapAB}
$i-dummy {p-sub-movAH} {p-movswapAC}
$i-dummy {p-sub-movAI} {p-movswapAD}
$i-dummy {p-sub-movAJ} {p-movswapAE}

p {p-sub-movAG} f3.11i
s f3.rp11 3
p f3.11o {p-movswapAB}
p {p-sub-movAH} f3.10i
s f3.rp10 3
p f3.10o {p-movswapAC}
p {p-sub-movAI} f3.9i
s f3.rp9 3
p f3.9o {p-movswapAD}
p {p-sub-movAJ} f3.8i
s f3.rp8 3
p f3.8o {p-movswapAE}

$swapf {p-sub-movAX}
$movaf {p-sub-movAX-5}
$swapf {p-sub-movAX-8}

endif # SUB_MOVAX11


if SUB_MOVAX5

# - MOVAX -
# To use trigger p-sub-movAX e.g. p-sub-movAG moves A to G
# XXX doesn't fit
# 1. MOVAX -> EX
# 2. LS -notX-> MOVAX
# 3. RF -AtoX-> MOVAX
# 4. MOVAX -> LS
# 5. EX -> MOVAX

# This sequence relies on 2 accumulator inputs per target register, one to
# select everything but that register "notX" and one to move A into the X
# position "AtoX". Spread these 2 * 5 = 10 inputs across 3 accums.
# X          which target reg inputs being defined
# YX         FG, HI or J (which target registers on this accum)
# AtoXwiring permute adapter wiring for AtoX input
# notXwiring permute adapter wiring for notX input
defmacro acc-movax acc X YX AtoXwiring notXwiring
{a-movA$YX}=$acc

# AtoX input: select digits 10,9 in X register position
p {d-main} ad.permute.{ad-Ato$X}
s ad.permute.{ad-Ato$X} $AtoXwiring
p ad.permute.{ad-Ato$X} {a-movA$YX}.{i-Ato$X}

# notX input: select digits besides X register
p {d-main} ad.permute.{ad-not$X}
s ad.permute.{ad-not$X} $notXwiring
p ad.permute.{ad-not$X} {a-movA$YX}.{i-not$X}

# 2-step sequence receive on notX then AtoX
# 1. -
# 2.     -notX-> MOVAX
# 3.     -AtoX-> MOVAX
$i-dummy {p-sub-movA$X} {p-sub-movA$X-2}
$rec {p-sub-movA$X-2} {a-movA$YX} {t-movA$X-2} {i-not$X} {p-sub-movA$X-3}
$recx {p-sub-movA$X-3} {a-movA$YX} {r-movA$X-3} {i-Ato$X}
endmacro

#          acc X YX AtoXwiring             notXwiring
$acc-movax a8  F FG 0,10,9,0,0,0,0,0,0,0,0 0,0,0,8,7,6,5,4,3,2,1
$acc-movax a8  G FG 0,0,0,10,9,0,0,0,0,0,0 0,10,9,0,0,6,5,4,3,2,1
$acc-movax a9  H HI 0,0,0,0,0,10,9,0,0,0,0 0,10,9,8,7,0,0,4,3,2,1
$acc-movax a9  I HI 0,0,0,0,0,0,0,10,9,0,0 0,10,9,8,7,6,5,0,0,2,1
$acc-movax a10 J J  0,0,0,0,0,0,0,0,0,10,9 0,10,9,8,7,6,5,4,3,0,0

# Shared sequence to save and restore temp accums. Only one instance is needed
# per accumulator.
# 1. MOVAX ->    
# 2. -
# 3. -
# 4. MOVAX ->    
# 5.     ->  MOVAX
defmacro acc-movax-save-restore YX rt
$sendcx {p-movA$YX} {a-movA$YX} {r-movA$YX} A
$dummy-delay-exclude {p-movA$YX} 3 {p-movA$YX-4} -{a-movA$YX}

$sendc {p-movA$YX-4} {a-movA$YX} {t-movA$YX-4} A {p-movA$YX-5}
$recx {p-movA$YX-5} {a-movA$YX} {$rt-movA$YX-5} {i-main}
endmacro

$acc-movax-save-restore FG t
$acc-movax-save-restore HI t
# FG and HI each use two r- programs for $acc-movax, and one for memcycle, so
# can fit only one more. But J can fit 2 more r- programs.
$acc-movax-save-restore J r

# Used to trigger save/restore for the accum used for this mov.
$pulseamp {p-sub-movAF} {p-sub-movAFG}
$pulseamp {p-sub-movAG} {p-sub-movAFG}
$pulseamp {p-sub-movAH} {p-sub-movAHI}
$pulseamp {p-sub-movAI} {p-sub-movAHI}

# A single shared sequence for all the movs
# register and accum specific parts are triggered by pulse amps
# 1.       -> EX
# 2. LS ->     
# 3. RF ->      
# 4.       -> LS
# 5. EX ->      
$rec {p-sub-movAX} {a-ex} {t-sub-movAX} {i-main} {p-sub-movAX-2}
$sendc {p-sub-movAX-2} {a-ls} {t-sub-movAX-2} A {p-sub-movAX-3}
$send {p-sub-movAX-3} {a-rf} {t-sub-movAX-3} A {p-sub-movAX-4}
$rec {p-sub-movAX-4} {a-ls} {t-sub-movAX-4} {i-main} {p-sub-movAX-5}
$i-dummy {p-sub-movAX-4} {p-storeex}

# Used to trigger the common sequence for all the movs.
$pulseamp {p-sub-movAFG} {p-sub-movAX}
$pulseamp {p-sub-movAHI} {p-sub-movAX}
$pulseamp {p-sub-movAJ} {p-sub-movAX}

endif # SUB_MOVAX5


# -- OPCODE IMPLEMENTATIONS --

#$break {p-op00}  # NOP
#$break {p-op01}  # SWAP A,B
#$break {p-op02}  # SWAP A,C
#$break {p-op03}  # SWAP A,D
#$break {p-op04}  # SWAP A,E
#$break {p-op10}  # LOADACC
#$break {p-op11}  # STOREACC
#$break {p-op12}  # SWAPALL
#$break {p-op20}  # MOV B,A
#$break {p-op21}  # MOV C,A
#$break {p-op22}  # MOV D,A
#$break {p-op23}  # MOV E,A
#$break {p-op30}  # MOV G,A
#$break {p-op31}  # MOV H,A
#$break {p-op32}  # MOV I,A
#$break {p-op33}  # MOV J,A
#$break {p-op34}  # MOV F,A
#$break {p-op40}  # MOV #xx,A
#$break {p-op52}  # INC A
#$break {p-op53}  # DEC A
#$break {p-op70}  # ADD D,A
#$break {p-op72}  # SUB D,A
#$break {p-op73}  # JMP xx
#$break {p-op74}  # JMP xxxx
#$break {p-op80}  # JN xx
#$break {p-op84}  # JSR xxxx
#$break {p-op85}  # RET
#$break {p-op90}  # CLR A
#$break {p-op92}  # PRINT
#$break {p-op93}  # MOV F,A
#$break {p-op95}  # HALT


# - NOP -
p {p-op00} {p-fetch}


if OP_SWAP

# - SWAP A,[BCDE] -
# First two cycles of each instruction is per-op, last two cycles shared
# 1. per-op: swapBCDE->EX
# 2. per-op: RF-swapA[BCDE]->swapBCDE, this is where the actual swap is
# 3. shared: swapBCDE->RF  $memcyc4-2
# 4. shared: EX->swapBCDE  $memcyc4-3
# This uses 10 programs total, rather than 16 if we do all sequences separately

p {p-op01} {p-opswapAB}
p {p-op02} {p-opswapAC}
p {p-op03} {p-opswapAD}
p {p-op04} {p-opswapAE}

defmacro swapBCDE-op reg
  # swapBCDE->EX, save swapBCDE
  $sendc {p-opswapA$reg} {a-swapBCDE} {t-swapA$reg} A {p-opswapA$reg-2}
  $loadex {p-opswapA$reg}

  # RF->swapBCDE, on swap input -- actually does the swap
  $sendc-rf {p-opswapA$reg-2}
  $rec {p-opswapA$reg-2} {a-swapBCDE} {t-opswapA$reg-2} {i-swapA$reg} {p-opswapBCDE}
endmacro
$swapBCDE-op B
$swapBCDE-op C
$swapBCDE-op D
$swapBCDE-op E

# The rest of the swap sequence has to done with dummies, we used 8 transcievers
# We need to send+clear swapBCDE, and then restore it from d-main, but this is
# exactly the memory cycle sequence so reuse that (a-swapBCDE == a-mem4).
$pulseamp {p-opswapBCDE} {p-memcyc4-2}

# swapBCDE->RF, saves swapped values back to RF
$dummy-exclude {p-opswapBCDE} {p-opswapBCDE-2} -{a-swapBCDE}
# p-memcyc4-2 sends a-swapBCDE
$loadrf {p-opswapBCDE}

# EX->swapBCDE, restore swapBCDE
$dummy-exclude {p-opswapBCDE-2} {p-fetch} -{a-swapBCDE}
$storeex {p-opswapBCDE-2}
# p-memcyc4-3 receives a-swapBCDE

endif # OP_SWAP



# - LOADACC -
if OP_LOADACC
# LOADACC is identical to STOREACC except 
# - clear LS at the start of the cycle
# - run main->LS in accumulator memory cycle, to read the value coming out

p {p-op10} {p-oploadacc}

$pulseamp {p-oploadacc} {p-sub-memcyc} # XXX pa not currently needed but maybe on word access?

# clear LS, we'll want that empty to recieve acc value
if SUB_MOVAX5
  $clearls {p-oploadacc}
else
  $clearx {p-oploadacc} {a-ls} {r-clear}
endif

# XXX good for FT dummy
$dummy-delay {p-oploadacc} 8 {p-oploadacc-2}

# MEMXX-> LS, receive accumulator value
$recx {p-oploadacc-2} {a-ls} {r-oploadacc-2} {i-main}

endif # OP_LOADACC


# - STOREACC -
# Basic memory cycle subprogram is already a store
if OP_STOREACC

p {p-op11} {p-opstoreacc}

# Start by saving DISCMEMCYC -> EX, clear
$sendc {p-opstoreacc} {a-discmemcyc} {t-opstoreacc} A {p-opstoreacc-2}
$loadex {p-opstoreacc}

# clear sign of LS by ping-pong to DISCMEMCYC through i-dropsign
# this is necessary to preserve sign of DISsCFTx when storing there
$sendc {p-opstoreacc-2} {a-ls} {t-opstoreacc-2} A {p-opstoreacc-3}
$recx {p-opstoreacc-2} {a-discmemcyc} {r-opstoreacc-2} {i-dropsign}

$sendc {p-opstoreacc-3} {a-discmemcyc} {t-opstoreacc-3} A {p-opstoreacc-4}
$recx {p-opstoreacc-3} {a-ls} {t-opstoreacc-3} {i-main} # ran out of r's

# Wait until accumulator outputs a value, save only the sign
# XXX good for FT dummy
$dummy-delay {p-opstoreacc-3} 8 {p-opstoreacc-5}

# Jump into sub-memcyc - no pulseamp needed because p-opstoreacc-4 triggers nothing else
p {p-opstoreacc-4} {p-sub-memcyc-2}

# Receive only sign on mem->LS, preserve sign when LS->mem next cycle
$recx {p-opstoreacc-5} {a-ls} {r-opstoreacc-4} {i-signonly}


endif # OP_STOREACC



if OP_SWAPALL

# - SWAPALL -
# Exchange RF and LS through RFTMP (RF may be negative).
p {p-op12} {p-opswapall}

# RFTMP->EX
$sendc {p-opswapall} {a-rftmp} {t-sub-rftmp} A {p-opswapall-2}
$loadex {p-opswapall}

# RF->RFTMP, clear
$sendc-rf {p-opswapall-2}
$rec {p-opswapall-2} {a-rftmp} {t-opswapall-2} {i-main} {p-opswapall-3}

# LS->RF
if SUB_MOVAX11
  $dummy {p-opswapall-2} {p-sendc-ls}
  $dummy {p-opswapall-3} {p-opswapall-4}
else
  $sendc {p-opswapall-3} {a-ls} {t-opswapall-2} A {p-opswapall-4}
endif
$loadrf {p-opswapall-3}

# RFTMP->LS
$sendc {p-opswapall-4} {a-rftmp} {t-opswapall-4} A {p-opswapall-5}
$recx {p-opswapall-4} {a-ls} {t-opswapall-4} {i-main}

# EX->RFTMP, goto fetch
$storeex {p-opswapall-5}
$rec {p-opswapall-5} {a-rftmp} {t-opswapall-5} {i-main} {p-fetch}

endif # OP_SWAPALL


# Common to OP_MOVXA3 + OP_MOVXA6 wiring
defmacro mov-decoding
  # All mov opcodes for A with RF are encoded as 2x, and all mov opcodes for A
  # with LS are encoded as 3x to conserve pulse amplifiers.  There is nothing
  # happening on d-main during decode, so use spare constant transceivers as
  # dummies, don't care what they send.
  # FIXME this is dodgy unless we decide to initialize ct to 0!
  p p.A3o c.23i
  p c.23o {p-opmovRFA}
  p p.A4o c.24i
  p c.24o {p-opmovLSA}

  p {p-op20} {p-opmovBA}
  p {p-op21} {p-opmovCA}
  p {p-op22} {p-opmovDA}
  p {p-op23} {p-opmovEA}
  p {p-op30} {p-opmovGA}
  p {p-op31} {p-opmovHA}
  p {p-op32} {p-opmovIA}
  p {p-op33} {p-opmovJA}

  # all the mov ops
  $pulseamp {p-opmovRFA} {p-opmovXA}
  $pulseamp {p-opmovLSA} {p-opmovXA}
endmacro


if OP_MOVXA6

# - MOV [BCDEFGHIJ],A -
# 1. $clearA-1
# 2. $clearA-2
# 3. MOVSWAP -> EX
# 4. (RF or LS) -mov[BCDE]-> MOVSWAP
# 5. MOVSWAP -selectA-> RF
# 6. EX -> MOVSWAP
$mov-decoding
p {p-op34} {p-opmovFA}

# Manually placed so they don't overlap with the multicycle sel dummies.
$manual-dummy {p-opmovXA} a19 {t-opmovXA} 2 {p-opmovXA-3}
$manual-dummy {p-opmovXA-3} a19 {t-opmovXA-3} 2 {p-opmovXA-5}
if SUB_MOVAX11
$manual-dummy {p-opmovXA-5} a19 {t-opmovXA-5} 2 {p-fetch}
endif
# NB only one of these two may be active so fine if same accum
$manual-dummy {p-opmovRFA} a20 {t-opmovRFA} 3 {p-opmovRFA-4}
$manual-dummy {p-opmovLSA} a20 {t-opmovLSA} 3 {p-opmovLSA-4}

# Decode which swap inputs to use, only one can be active so fine if same accum
$dummy-delay-exclude {p-opmovBA} 3 {p-movswapAB} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovCA} 3 {p-movswapAC} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovDA} 3 {p-movswapAD} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovEA} 3 {p-movswapAE} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovFA} 3 {p-movswapAA} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovGA} 3 {p-movswapAB} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovHA} 3 {p-movswapAC} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovIA} 3 {p-movswapAD} -a20,a19,a18,{a-movswap}
$dummy-delay-exclude {p-opmovJA} 3 {p-movswapAE} -a20,a19,a18,{a-movswap}

# clear A
$clearA {p-opmovXA}

# invoke mov/swap sequence
$movswap {p-opmovXA-3}

# Get desired field of RF or LS in A position
$send-rf {p-opmovRFA-4}
$sendx {p-opmovLSA-4} {a-ls} {r-opmovLSA-4} A
# dummy triggers p-movswapAX

# Update A in RF
$recx {p-opmovXA-5} {a-rf} {t-opmovXA-6} {i-selectA}

endif


if OP_SWAP6

# Shared sequence with OP_MOVXA6
# 1. MOVSWAP -> EX
# 2. (RF) -mov[BCDE]-> MOVSWAP
# 3. MOVSWAP -> RF
# 4. EX -> MOVSWAP
p {p-op01} {p-opswapAB}
p {p-op02} {p-opswapAC}
p {p-op03} {p-opswapAD}
p {p-op04} {p-opswapAE}

# TODO All swap ops start with 0x, so we could try the same trick as with MOV
# ops, but this would break nop... do we want to renumber nop?
# FIXME this is dodgy unless we decide to initialize ct to 0!
#p p.A1o c.21i
#p c.21o {p-opswap}
$pulseamp {p-opswapAB} {p-opswap}
$pulseamp {p-opswapAC} {p-opswap}
$pulseamp {p-opswapAD} {p-opswap}
$pulseamp {p-opswapAE} {p-opswap}

# Manually placed so they don't overlap with the multicycle sel dummies.
$manual-dummy {p-opswap} a20 {t-opswap} 1 {p-opswap-2}
$manual-dummy {p-opswap-2} a20 {t-opswap-2} 1 {p-opswap-3}
if SUB_MOVAX11
$manual-dummy {p-opswap-3} a20 {t-opswap-3} 2 {p-fetch}
endif
$dummy-exclude {p-opswapAB} {p-movswapAB} -a20,a18,{a-movswap}
$dummy-exclude {p-opswapAC} {p-movswapAC} -a20,a18,{a-movswap}
$dummy-exclude {p-opswapAD} {p-movswapAD} -a20,a18,{a-movswap}
$dummy-exclude {p-opswapAE} {p-movswapAE} -a20,a18,{a-movswap}

$movswap {p-opswap}

# Swap desired words of RF
$sendc-rf {p-opswap-2}
# dummy triggers p-movswapAX

# Update RF
$loadrf {p-opswap-3}

endif


if OP_MOVXA3

# - MOV [BCDEGHIJ],A -
# Four inputs on RF let us share almost the same sequence for most MOVs, except
# MOV F,A which needs an extra input.  We could get 2-cycle MOVs for [BCD] by
# wiring movBA, movCA, movDA inputs on RF instead.
# 1. RF -clearA-> EX
# 2. EX -> RF, don't clear
# 3. EX -sel[BCDE]A-> RF, clear
#    (or: LS -sel[BCDE]A -> RF, clear EX)
$mov-decoding

# Manually placed so they don't overlap with the multicycle sel dummies.
$manual-dummy {p-opmovXA} a19 {t-opmovXA} 1 {p-opmovXA-2}
# NB only one of these two may be active so fine if same accum
$manual-dummy {p-opmovRFA} a20 {t-opmovRFA} 2 {p-opmovRFA-3}
$manual-dummy {p-opmovLSA} a20 {t-opmovLSA} 2 {p-opmovLSA-3}

# Decode which select inputs to use, e.g. mov B,A and mov G,A each select the
# same field to move into A. only one sel dummy can be active so fine if same
# accum
$dummy-delay-exclude {p-opmovBA} 2 {p-rf-selBA} -a20,a19
$dummy-delay-exclude {p-opmovCA} 2 {p-rf-selCA} -a20,a19
$dummy-delay-exclude {p-opmovDA} 2 {p-rf-selDA} -a20,a19
$dummy-delay-exclude {p-opmovEA} 2 {p-rf-selEA} -a20,a19
$dummy-delay-exclude {p-opmovGA} 2 {p-rf-selBA} -a20,a19
$dummy-delay-exclude {p-opmovHA} 2 {p-rf-selCA} -a20,a19
$dummy-delay-exclude {p-opmovIA} 2 {p-rf-selDA} -a20,a19
$dummy-delay-exclude {p-opmovJA} 2 {p-rf-selEA} -a20,a19

# RF -clearA-> EX
$sendc-rf {p-opmovXA}
$loadex-clearA {p-opmovXA}

# EX -> RF, don't clear
$send {p-opmovXA-2} {a-ex} {t-opmovXA-2} A {p-opmovXA-3}
$loadrf {p-opmovXA-2}

# EX -sel[BCDE]A-> RF, clear
$storeex {p-opmovRFA-3}
# Alternatively LS -sel[BCDE]A->RF, clear EX
$sendx {p-opmovLSA-3} {a-ls} {r-opmovLSA-3} A
$clearx {p-opmovLSA-3} {a-ex} {t-opmovLSA-3}
$dummy {p-opmovXA-3} {p-fetch}

endif # OP_MOVXA3


if OP_MOVFA3

# - MOV F,A -
# Separate from other MOVs because RF doesn't have enough inputs to select A.
# TODO This is kinda expensive but seems important... is there a cheaper way?
# 1. MOVFA -> EX
# 2. RF -clearA-> MOVFA
# 3. LS -selectA-> MOVFA
# 4. MOVFA -> RF
# 5. EX -> MOVFA
p {p-op93} {p-opmovFA}

# Stash MOVFA in EX
$sendc {p-opmovFA} {a-movfa} {t-opmovFA} A {p-opmovFA-2}
$loadex {p-opmovFA}

# Get 0BCDE in MOVFA and clear RF
$sendc-rf {p-opmovFA-2}
$rec {p-opmovFA-2} {a-movfa} {t-opmovFA-2} {i-clearA} {p-opmovFA-3}

# Get F0000 in MOVFA
$sendx {p-opmovFA-3} {a-ls} {t-opmovFA-3} A
$rec {p-opmovFA-3} {a-movfa} {t-opmovFA-3} {i-selectA} {p-opmovFA-4}

# Replace RF with FBCDE and clear MOVFA
$sendc {p-opmovFA-4} {a-movfa} {t-opmovFA-4} A {p-opmovFA-5}
$loadrf {p-opmovFA-4}

# Restore stashed MOVFA
$storeex {p-opmovFA-5}
$rec {p-opmovFA-5} {a-movfa} {t-opmovFA-5} {i-main} {p-fetch}

endif # OP_MOVFA3


if OP_CLRA

# - CLR A -
p {p-op90} {p-opclrA}

# Use clear A subroutine
$clearA {p-opclrA}
$dummy-delay {p-opclrA} 2 {p-fetch}

endif # OP_CLRA


if OP_MOVIMMA

# - MOV #XX,A -
p {p-op40} {p-opmovimmA}

# First clear A
$clearA {p-opmovimmA}
$dummy-delay {p-opmovimmA} 2 {p-opmovimmA-3}

# Consume the next word in IR, saving it into A, and then trigger p-fetch
$consume-op {p-opmovimmA-3}
$pulseamp {p-opmovimmA-3} {p-rf-selEA}  # save lowest word into A

endif # OP_MOVIMMA


if OP_INC

# - INC -
p {p-op52} {p-opinc}

# Send P01000 on d-main
p {p-opinc} c.29i
s c.s29 Jr
p c.29o {p-fetch}

# Increment A field of RF
if FAST_MOV
  $recx {p-opinc} {a-rf} {t-opinc} {i-main}
else
  $recx {p-opinc} {a-rf} {r-opinc} {i-main}
endif

endif # OP_INC


if OP_DEC

# - DEC -
p {p-op53} {p-opdec}

# Send M99000 on d-main
p {p-opdec} c.30i
s c.s30 Jl
p c.30o {p-fetch}

# Decrement A field of RF
$loadrf {p-opdec}

endif # OP_DEC


if OP_ADD

# - ADD D,A -
# 1. RFTMP -> EX
# 2. RF -> RFTMP
# 3. RFTMP -selDA-> RF
# 4. EX -> RFTMP
p {p-op70} {p-opadd}

# RFTMP -> EX
$sendc {p-opadd} {a-rftmp} {t-opadd} A {p-opadd-2}
$loadex {p-opadd}

# RF -> RFTMP
$send-rf {p-opadd-2}
$rec {p-opadd-2} {a-rftmp} {t-opadd-2} {i-main} {p-opadd-3}

# RFTMP -selDA-> RF
$sendc {p-opadd-3} {a-rftmp} {t-opadd-3} A {p-opadd-4}
$pulseamp {p-opadd-3} {p-rf-selDA}

# EX -> RFTMP
$storeex {p-opadd-4}
$recx {p-opadd-4} {a-rftmp} {r-opadd-4} {i-main}
# XXX out of dummies!
#$dummy-exclude {p-opadd-4} {p-fetch} -{a-rftmp}
$manual-dummy {p-opadd-4} {a-rf} {t-opadd-4} 1 {p-fetch}

endif # OP_ADD


if OP_SUB

# - SUB D,A -
# 1. RF.S -> EX  # NB does not send sign!
# 2. EX -> selDA -> RF
# 3. P01 -> RF
# 4. M00 -> RF  # ideally we'd send M01, but don't have it
p {p-op72} {p-opsub}

# RF.S -> EX
$send {p-opsub} {a-rf} {t-opsub} S {p-opsub-2}
$loadex {p-opsub}

# EX -selDA-> RF
$storeex {p-opsub-2}
$pulseamp {p-opsub-2} {p-rf-selDA}
$dummy {p-opsub-2} {p-opsub-3}

# P01 -> RF
$loadrf {p-opsub-3}
p {p-opsub-3} c.27i
s c.s27 Jr
p c.27o {p-opsub-4}

# M00 -> RF
$loadrf {p-opsub-4}
$sendM0 {p-opsub-4}
$dummy {p-opsub-4} {p-fetch}

endif # OP_SUB


if OP_JMP

# - JMP XX -
p {p-op73} {p-sub-jmp}

endif # OP_JMP


if OP_JMPFAR

# - JMP XXXX -
p {p-op74} {p-opjmpfar}

$fargo {p-opjmpfar}
$dummy {p-opjmpfar} {p-opjmpfar-2}

# Set new PC from IR
$assert {p-opjmpfar-2} {a-ir}~Pxxxxxxxxxx
$send {p-opjmpfar-2} {a-ir} {t-opjmpfar-2} A {p-opjmpfar-3}

# Preserve return address from PC
$recx {p-opjmpfar-3} {a-newpc} {r-opjmpfar-3} {i-keep-r}

endif # OP_JMPFAR


if OP_JSR

# - JSR XXXX -
p {p-op84} {p-opjsr}

$fargo {p-opjsr}
$dummy {p-opjsr} {p-opjsr-2}

# Set new PC from IR
$assert {p-opjsr-2} {a-ir}~Pxxxxxxxxxx
$send {p-opjsr-2} {a-ir} {t-opjsr-2} A {p-opjsr-3}

# Shift old PC into return address
$recx {p-opjsr-3} {a-newpc} {r-opjsr-3} {i-shiftl4-pc}

endif # OP_JSR


if OP_RET

# - RET -
p {p-op85} {p-opret}

$fargo {p-opret}
$dummy-delay {p-opret} 2 {p-opret-3}

# Shift return address into new PC
$recx {p-opret-3} {a-newpc} {t-opret-3} {i-shiftr4-pc}

endif # OP_RET


if OP_JN

# - JN XX -
p {p-op80} {p-opjn}

# save DISCJX
$sendc {p-opjn} {a-discjx} {t-opjn} A {p-opjn-2}
$loadex {p-opjn}

# RF->DISCJX, this puts sign of A into DISCJX PM
$send-rf {p-opjn-2}
$rec {p-opjn-2} {a-discjx} {t-opjn-2} {i-main} {p-opjn-3}

# conditional jump
p {p-opjn-3} {p-sub-jx}

endif # OP_JN


if OP_JZ

# - JZ XX -
# XXX Note that this treats M00 as P00.  A somewhat insane way to fix M00 might
# be to wire RF PM to discjx i-shiftA.1, but this has unclear electrical
# implications, and would complicate jil.
p {p-op81} {p-opjz}

# reuse discjx sequence
$pulseamp {p-opjz} {p-sub-discjx}

# TODO use dummy on ft1 or ft3?
$dummy-delay-exclude {p-opjz} 5 {p-opjz-6} -{a-discjx}

# receive ft2 sign for jz
$recx {p-opjz-6} {a-discjx} {r-opjz-6} {i-ftjzsign}

endif # OP_JZ


if OP_JIL

# - JIL XX -
p {p-op82} {p-opjil}

# reuse discjx sequence
$pulseamp {p-opjil} {p-sub-discjx}

# TODO use dummy on ft1 or ft3?
$dummy-delay-exclude {p-opjil} 5 {p-opjil-6} -{a-discjx}

# receive ft2 sign for jil
$recx {p-opjil-6} {a-discjx} {r-opjil-6} {i-ftjilsign}

endif # OP_JIL


if OP_PRINT

# - PRINT - 
# Save a-print, RF-printAB->a-print, restore
# Really the only trick here is that we can only print from a13,
# and during the transfer we shift RF right so we print 0AABB not AABBC
p {p-op92} {p-opprint}

# PRINT->EX, clear
$sendc {p-opprint} {a-print} {t-opprint} A {p-opprint-2}
$loadex {p-opprint}

# RF-printAB->a13. Puts AB in lower 4 digits of upper half of accumulator
$send-rf {p-opprint-2}
$rec {p-opprint-2} {a-print} {t-printAB} {i-printAB} i.pi # trigger print

# prints high half accumulator 13
s pr.2 P
p i.po {p-opprint-3}

# restore contents of MEM13
$clear {p-opprint-3} {a-print} {t-opprint-3} {p-opprint-4}

$storeex {p-opprint-4}
$rec {p-opprint-4} {a-print} {t-opprint-4} {i-main} {p-fetch}

endif # OP_PRINT


if OP_READ

# - READ -
p {p-op91} {p-opread}

# read in a new card into constant transmitter
p {p-opread} i.Ri
# clear LS to receive card data
if SUB_MOVAX5
  $clearls {p-opread}
else
  $clear {p-opread} {a-ls} {t-opread} {p-opread-2}
endif

# wait for card to read
p {p-opread-2} i.Rl

# when data is ready, read Al into LS (FFGGH)
# XXX It'd make sense to read 10 digits and replace LS, but ct output wiring
# crosses over the right 5 digits to the left 5 so that we can get four
# constants out of JK switches.  If we were willing to rely on initializing
# constants from a card at reset time, we could get rid of that hack and be
# able to read 10 digits at once here.
p i.Ro c.1i
s c.s1 Al
p c.1o {p-fetch}
$recx i.Ro {a-ls} {t-opread-n} {i-main}

endif


# - HALT -
# Wire halt to quit the simulator so we can run programs and exit when they're
# done.
# p {p-op95} debug.quit


# -- JUMP DISCRIMINATION --
# PM digits of FT2 are a lookup table for jz and jil discrimination
s f2.mpm1 T
s f2.mpm2 T

# jz uses A signs, with 00 -> M, other rows -> P
s f2.RA0S M

# jil uses B signs, with xy -> M when x or y is 0 or 9, otherwise P.
defmacro jil-rank0 x01 x02 x03 x04 x05 x06 x07 x08 x09 x10
  s f2.RB0S $x01
  s f2.RB1S $x02
  s f2.RB2S $x03
  s f2.RB3S $x04
  s f2.RB4S $x05
  s f2.RB5S $x06
  s f2.RB6S $x07
  s f2.RB7S $x08
  s f2.RB8S $x09
  s f2.RB9S $x10
endmacro
defmacro jil-rank rank x01 x02 x03 x04 x05 x06 x07 x08 x09 x10
  s f2.RB$rank0S $x01
  s f2.RB$rank1S $x02
  s f2.RB$rank2S $x03
  s f2.RB$rank3S $x04
  s f2.RB$rank4S $x05
  s f2.RB$rank5S $x06
  s f2.RB$rank6S $x07
  s f2.RB$rank7S $x08
  s f2.RB$rank8S $x09
  s f2.RB$rank9S $x10
endmacro
$jil-rank0  M M M M M M M M M M
$jil-rank 1 M P P P P P P P P M
$jil-rank 2 M P P P P P P P P M
$jil-rank 3 M P P P P P P P P M
$jil-rank 4 M P P P P P P P P M
$jil-rank 5 M P P P P P P P P M
$jil-rank 6 M P P P P P P P P M
$jil-rank 7 M P P P P P P P P M
$jil-rank 8 M P P P P P P P P M
$jil-rank 9 M M M M M M M M M M

# -- ACCUMULATOR DECODE --
# lookup table used to trigger accumulators on loadacc / storeacc
# This is on FT3 but doesn't conflict with FTL values on I1 since it uses 10 of 12 digits
defmacro acc-decode-line line x01 x02 x03 x04 x05 x06 x07 x08 x09 x10
  s f3.RA$lineS  $x01
  s f3.RA$lineL4 $x02
  s f3.RA$lineL3 $x03
  s f3.RA$lineL2 $x04
  s f3.RA$lineL1 $x05
  s f3.RB$lineL6 $x06
  s f3.RB$lineL5 $x07
  s f3.RB$lineL4 $x08
  s f3.RB$lineL3 $x09
  s f3.RB$lineL2 $x10
  s f3.RB$lineL1 9      # use 2-10 + sign, digit 1 is not usable on S due to 1'P
endmacro

s f3.mpm1 T             # send individual line signs through

# These are the 9s complements of 000..9..00 (we send from memcyc09/memcyc1014 on S)
# Use rows -2..7 with A-2 addressing to minimize program overlap.
$acc-decode-line -2 M 9 9 9 9 9 9 9 9 0
$acc-decode-line -1 M 9 9 9 9 9 9 9 0 9
$acc-decode-line  0 M 9 9 9 9 9 9 0 9 9
$acc-decode-line  1 M 9 9 9 9 9 0 9 9 9
$acc-decode-line  2 M 9 9 9 9 0 9 9 9 9
$acc-decode-line  3 M 9 9 9 0 9 9 9 9 9
$acc-decode-line  4 M 9 9 0 9 9 9 9 9 9
$acc-decode-line  5 M 9 0 9 9 9 9 9 9 9
$acc-decode-line  6 M 0 9 9 9 9 9 9 9 9
$acc-decode-line  7 P 9 9 9 9 9 9 9 9 9


# -- DUMMIES --
# Reserved after other all other accumulator programs are configured.
insert-deferred


# -- CURRENT PROGRAM --
include vmtest.e
# ibm cards (one card per line, 80 cols)
f r vmtest.deck

# To run tic tac toe, comment out vmtest, uncomment this, and use runtic.py
#include tic.e

# Start the machine
b i
