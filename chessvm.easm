s cy.op 1a
# ftsg fields of PC are 99 (ft1), 09 (ft2), or 90 (ft3), and must be nonzero
# for correct operation
# TODO figure out how to reset this way
set a1 0099009900
#set a2 -9999999904
set a4  0075000000  # A=00, B=75
set a13 1234567890 # memory value, check that print saves and restores


# ENIAC-VM for playing chess
# created 2020-3-30 by Jonathan Stray
#
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute,
# and implements all the opcodes. The control cycle design is adapted from 
# "Central Control for ENIAC", Adele Goldstine, 1947
#
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

include macros.easm

# -- ACCUMULATOR LAYOUT --
# Defines all accumulators and patches to and from data trunks
# That patching encodes the possible permutations on acc inputs and outputs,
# as well as digit-to-program triggers for discrimination and 1-of-N decoding.
# Listed centrally here to make it easier to track allocation.

# Main data bus, used for most transfers
{d-main}=1

# - Program counter -
# Layout: SS RRRR PPPP
# Current program counter PPPP and return address RRRR, plus a temp SS
# Four digit address is FFLL: FF = which ft (00=ft1, 90=ft2, 99=ft3), LL = ft line

{a-pc}=a1

# A - mp steppers, op<=55
p {a-pc}.A {d-main}

# S - mp steppers, op>55
# Decode needs the digits of the SS field to be swapped.
p {a-pc}.S ad.permute.{ad-swap-pc-ss-digits}
s ad.permute.{ad-swap-pc-ss-digits} 11,9,10,8,7,6,5,4,3,2,1
p ad.permute.{ad-swap-pc-ss-digits} {d-main}

# Note there is no discrimination on PC

# main input
p {d-main} {a-pc}.{i-main}

# shiftl8-irS input: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
p {d-irS} ad.s.{ad-pc-shiftl8-irS}.8
p ad.s.{ad-pc-shiftl8-irS}.8 {a-pc}.{i-shiftl8-irS}

# clear A input: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
p {d-exS} ad.permute.{ad-exS-clearA}
s ad.permute.{ad-exS-clearA} 0,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-exS-clearA} {a-pc}.{i-exS-clearA}

# sendi1 input: from FT, first instruction only
p {d-exS} {a-pc}.{i-sendi1}

# loadim2-irS: I1 XX XX XX XX -> 00 00 00 00 I1, used for JN/JZ/JIL
# shiftl4-exA, used for JSR


# - Instruction Register -
# Layout: M 99-I6 99-I5 99-I4 99-I3 100-I2
# Holds up to 5 instructions queued to execute after loading from a function
# table line. Fills in 99 from the left as instructions are executed. When empty, 
# this will be 9999999999 and then +1 flips to P0, easy to detect
# So we also have a "need to fetch a line" discrimination on IR

{a-ir}=a2

# A(11) - discrimination, A(10-1) main
p {a-ir}.A {d-irA}
p {d-irA} ad.permute.{ad-drop-ir-sign}
s ad.permute.{ad-drop-ir-sign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-drop-ir-sign} {d-main}

# S output to its own bus, unpermuted
p {a-ir}.S {d-irS}

# AS - fetch discriminate

# fetch input: from d-fetch, used for loading new line of instructions permuted from function table
p {d-fetch} {a-ir}.{i-fetch}

# fill99 input: replace top 2 digits of IR with 99
# the 99 comes from a constant M00000, the rest from EX sent on main
p {d-main} ad.permute.{ad-fill99-main}
s ad.permute.{ad-fill99-main} 11,11,11,8,7,6,5,4,3,2,1
p ad.permute.{ad-fill99-main} {a-ir}.{i-fill99}


# - Execution Register -
# Empty at the beginning of every opcode program
# Typically the only temp space in the machine, so used extensively to save
# contents of other accumulators while they are used functionally
# Also used to disc opcode >55

{a-ex}=a3

# A(11) - discrimination, A(10-1) main
p {a-ex}.A {d-exA}
p {d-exA} ad.permute.{ad-drop-ex-sign}
s ad.permute.{ad-drop-ex-sign} 0,10,9,8,7,6,5,4,3,2,1
p ad.permute.{ad-drop-ex-sign} {d-main}

# S - exS
p {a-ex}.S {d-exS}

# AS - discriminate opcode > 55

# main
p {d-main} {a-ex}.{i-main}

# rotate-irA input: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2 for control cycle
# Shift the instructions right, then we execute and clear I1, removing one from the queue
p {d-irA} ad.permute.{ad-irA}
s ad.permute.{ad-irA} 11,2,1,10,9,8,7,6,5,4,3
p ad.permute.{ad-irA} {a-ex}.{i-rotate-irA}

# clearA input: XX XX XX XX XX -> 00 XX XX XX XX, used for MOV A,#X and other writes to A
p {d-main} ad.permute.{ad-clearA}
s ad.permute.{ad-clearA} 11,0,0,8,7,6,5,4,3,2,1
p ad.permute.{ad-clearA} {a-ex}.{i-clearA}

# clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
# clearPC4: XX XX XX 43 21 -> XX XX XX 00 00, used for JMP
# shiftl4:  XX YY YY 43 32 -> XX 43 21 00 00, used for JSR



# predefine programs that load ex from and store ex to main -- we use these everywhere
# go through pulseamps so other uses don't flow backwards
defmacro loadex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{r-loadex}i
endmacro
s {a-ex}.op{r-loadex} {i-main}

# sends EX to main and clears
defmacro storeex prog
  p $prog {pa-a-%name} 
  p {pa-b-%name} {a-ex}.{t-storeex}i
endmacro
s {a-ex}.op{t-storeex} A
s {a-ex}.cc{t-storeex} C


# - Register File -
# Registers A-E of the virtual machine. Use a13 so we can print it.
{a-rf}=a4
p {a-rf}.A {d-main}

p {d-main} {a-rf}.{i-main}

# clearA
p {d-main} ad.d.{ad-rf-clearA}.-2
p ad.d.{ad-rf-clearA}.-2 {a-rf}.{i-clearA}

# - Load/Store -
# Registers F-J of the virtual machine. 
{a-ls}=a5

# - M13 - 
# M13 is used for printing, has an input that shifts AB into printing position
{a-mem13}=a13
p {a-mem13}.A {d-main}

p {d-main} {a-mem13}.{i-main}

p {d-main} ad.permute.{ad-printAB}
s ad.permute.{ad-printAB} 11,0,10,9,8,7,0,0,0,0,0
p ad.permute.{ad-printAB} {a-mem13}.{i-printAB}


# - Constant transmitter -
# So that we can use all the constant switches, connect both the left and the
# right 5 constant digits to the leftmost wires of d-main where they're needed.
# This is perhaps electrically questionable, but should work?  Provided the
# right constants are positive, there should be no bus conflicts - if they were
# negative, the constant transmitter would also drive 9s onto the same wires
# for sign extension.
p c.o ad.permute.{ad-constant-left}
s ad.permute.{ad-constant-left} 11,10,9,8,7,6,0,0,0,0,0
p ad.permute.{ad-constant-left} {d-main}
p c.o ad.permute.{ad-constant-right}
# (Delete sign so that eniacsim doesn't send two copies of the sign pulses...)
s ad.permute.{ad-constant-right} 0,5,4,3,2,1,0,0,0,0,0
p ad.permute.{ad-constant-right} {d-main}

# M99000 used in control cycle
s c.jl  M
s c.j10 9
s c.j9  9

# M00000 used in control cycle
s c.kl  M
s c.k10 0
s c.k9  0

# P55000 used in control cycle
s c.kr P
s c.k5 5
s c.k4 5

# P01000 used in control cycle
s c.jr P
s c.j5 0
s c.j4 1


# - Setup MP as an opcode decoder -
# Steppers use all 6 positions.
s p.cA 6
s p.cB 6
s p.cC 6
s p.cD 6
s p.cE 6
s p.cF 6
s p.cG 6
s p.cH 6
s p.cJ 6
s p.cK 6

# This switch setting makes eniacsim disable/disassociate MP decade counters.
#
# Decade counters are a problem for decoding because they trigger a spurious
# extra step whenever they overflow, and they count in a data-dependent way on
# each program input (e.g. p.Ai, p.Bi, ...). Possibly some scheme could be
# devised to guarantee decade counters are safe before p.Ai for decode - they
# don't have an explicit clear control, but do clear on overflow.  But it's far
# simpler just to unplug the things.
#
# Associator switches on the MP front panel don't permit disconnecting decade
# counters, but the operating manual notes "To disassociate a decade from its
# stepper pull out gate tube 63 in the stepper plug-in unit. See block diagram
# PX-8-304."
s p.gate63 unplug

# Shared program used to clear master programmer steppers in anticipation of
# decode.  Triggered via pulse amplifier because it is necessary for this to
# happen directly in the cycle prior to decode, which may occur in a few
# different places in the fetch sequence.
p {p-clear-mp} p.Acdi
p {p-clear-mp} p.Bcdi
p {p-clear-mp} p.Ccdi
p {p-clear-mp} p.Dcdi
p {p-clear-mp} p.Ecdi
p {p-clear-mp} p.Fcdi
p {p-clear-mp} p.Gcdi
p {p-clear-mp} p.Hcdi
p {p-clear-mp} p.Jcdi
p {p-clear-mp} p.Kcdi

# Receive opcode at master programmer stepper direct inputs
p {d-main} ad.dp.{ad-opcode-10}.10   # opcode 10's digit (0x-5x)
p ad.dp.{ad-opcode-10}.10 p.Adi
p {d-main} ad.dp.{ad-opcode-9}.9     # opcode 1's digit (0x-5x)
p ad.dp.{ad-opcode-9}.9 p.Bdi
p ad.dp.{ad-opcode-9}.9 p.Cdi
p ad.dp.{ad-opcode-9}.9 p.Ddi
p ad.dp.{ad-opcode-9}.9 p.Edi
p ad.dp.{ad-opcode-9}.9 p.Fdi
p ad.dp.{ad-opcode-9}.9 p.Gdi        # opcode 1's digit (0x-5x) or 10's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Hdi      # opcode 1's digit (7x-9x)
p ad.dp.{ad-opcode-10}.10 p.Jdi
p ad.dp.{ad-opcode-10}.10 p.Kdi

# Trigger the appropriate ones digit for opcodes <= 55
p p.A1o p.Bi
p p.A2o p.Ci
p p.A3o p.Di
p p.A4o p.Ei
p p.A5o p.Fi
p p.A6o {p-mp-5x}

# For opcodes>55, Gi is triggered both by A6o when decoding 5x, and explicitly via a program
# control to decode the tens digit of 7x-9x.
$pulseamp {p-mp-5x} p.Gi
$pulseamp {p-mp-789x} p.Gi

# Trigger the appropriate ones digit for opcodes >= 70.
p p.G1o p.Hi
p p.G2o p.Ji
p p.G3o p.Ki

# Wire the outputs to individual opcode programs
defmacro op-lines-le55 stepper tens
  p p.$stepper1o {p-op$tens0}
  p p.$stepper2o {p-op$tens1}
  p p.$stepper3o {p-op$tens2}
  p p.$stepper4o {p-op$tens3}
  p p.$stepper5o {p-op$tens4}
  p p.$stepper6o {p-op$tens5}
endmacro

$op-lines-le55 B 0
$op-lines-le55 C 1
$op-lines-le55 D 2
$op-lines-le55 E 3
$op-lines-le55 F 4
# G1o-G3o are used for 7x-9x.
p p.G4o {p-op53}
p p.G5o {p-op54}
p p.G6o {p-op55}

defmacro op-lines-gt55 stepper tens
  p p.$stepper1o {p-op$tens9}
  p p.$stepper2o {p-op$tens8}
  p p.$stepper3o {p-op$tens7}
  p p.$stepper4o {p-op$tens6}
  p p.$stepper5o {p-op$tens5}
  p p.$stepper6o {p-op$tens4}
endmacro

$op-lines-gt55 H 9
$op-lines-gt55 J 8
$op-lines-gt55 K 7



# -- CONTROL CYCLE --

# initiate button
p i.io {p-clearex-fetch}

# - A program line to jump to if ex has something in it
$clear {p-clearex-fetch} {a-ex} {t-clearex-fetch} {p-fetch}


# -- p-fetch: begin next instruction
# During this cycle:
#  - discriminate, to decide whether to fetch new instructions
#  - read out the contents of IR into EX
#  - send next instruction (I1) to PC (assume PC.SS is 0)
$assert {p-fetch} {a-ex}~P0000000000
$assert {p-fetch} {a-pc}~x00xxxxxxxx

# If more instructions are needed, IR is P 0, and control proceeds to p-fetchline.
# Otherwise, IR is M 99-I5 99-I4 99-I3 99-I2 100-I1 and we trigger p-nofetch-eat-op.
$discriminate {p-fetch} {a-ir} a20 fetch {d-irA} {d-irS} {p-fetchline} {p-nofetch-eat-op}
s {a-ir}.cc{t-fetch} C   # clear IR after transmission

# IR -> EX 
# $discriminate sends IR on d-main, and EX receives it permuted I5 I4 I3 I2 I1
# -> I1 I5 I4 I3 I2.  This puts the next instruction in the left (first two
# digits) of EX.  NB preserves the sign of IR, so will be M in p-nofetch.
$recx {p-fetch} {a-ex} {r-fetch} {i-rotate-irA}

# IR -S-shiftl8-irS-> PC
# Also send first opcode to left of PC (using the S output to undo the existing
# complement when we loaded IR). This copy of the instruction will later be
# sent to MP steppers for decoding.
$recx {p-fetch} {a-pc} {r-fetch} {i-shiftl8-irS}



# -- {p-nofetch} no fetch needed, begin instruction decode
$pulseamp {p-nofetch-eat-op} {p-nofetch}
# PC has I1 at left
# EX starts M 100-I1 99-I5 99-I4 99-I3 99-I2
$assert {p-nofetch} {a-ex}~Mxxxxxxxxxx

# Begin decode by adding 55 to EX, from constant transmitter

# Send 55 from CT on d-main
p {p-nofetch} c.26i 
s c.s26 Kr

# EX += d-main (55) for discrimination next cycle.  For example,
# - If I1 is 01, EX will contain M (100-01) = M 99...
#   Adding 55 to 99 will wrap and set EX to P 54...
# - If I1 is 71, EX will contain M (100-71) = M 29...
#   Adding 55 to 29 will set EX to M 84...
$rec {p-nofetch} {a-ex} {t-nofetch} {i-main} {p-disc-op}

# If we are eating an operand (removing it from IR) then we need to set
# top top digits of IR to 99 after next instruction (delay 1 cycle)
$dummy {p-nofetch-eat-op} a20 {t-eat-op} 1 {p-eat-op}


# -- {p-disc-op} discriminate opcode I1>55, to switch between two decode pathways
# EX starts P/M 155-I1 99-I5 99-I4 99-I3 99-I2 and ends clear.
# Also store shifted instructions back to IR, deleting just-dispatched opcode.
$assert {p-eat-op} {a-ir}~P0000000000

# Discriminate based on sign of EX, already set based on whether I1 > 55.
$discriminate {p-disc-op} {a-ex} a20 disc-op {d-exA} {d-exS} {p-ople55} {p-opgt55}
s {a-ex}.cc{t-disc-op} C  # clear EX

# If we are consuming from IR, store EX back into IR without the op we are now decoding.
# Replace the sign and first two digits with M from a constant, so the top of IR is
# M99. Finally, increment so that an empty IR, M9999999999, wraps to P0000000000.
# This also turns 99-I2 into 100-I2 at the right of IR.
$recincx {p-eat-op} {a-ir} {t-disc-op} {i-fill99}
# Send M00000 from the constant transmitter to fix IR.  EX doesn't send a sign
# on d-main so there's no bus conflict.
p {p-eat-op} c.25i
s c.s25 Kl

# Clear MP prior to decode.  Clearing isn't synchronous, so this needs to
# happen "next cycle" i.e. during pulse 17 of p-disc-op.
$dummy {p-disc-op} a20 {t-disc-op} 1 {p-clear-mp}


# -- p-ople55 - send tens digit of opcode to stepper A, ones digit to B-G
# Also PC->EX to begin clearing SS 
$assert {p-ople55} {a-ex}~P0000000000

# Send PC on main and receive in EX with SS (opcode field) clear.
$sendc {p-ople55} {a-pc} {t-ople55} A {p-ople55-2}
$recx {p-ople55} {a-ex} {r-ople55} {i-clearA}


# -- p-ople55-2 - send input pulse to master programmer
# sign of EX must be P to avoid misfiring p-ople55
$assert {p-ople55-2} {a-ex}~P00xxxxxxxx
$assert {p-ople55-2} {a-pc}~P0000000000

# Send EX back to PC with opcode field clear to prep for instruction.
# Note that this would trigger the MP steppers, but the opcode field contains
# 00 here so this doesn't mess up decode.
$sendcx {p-ople55-2} {a-ex} {t-ople55-2} A
$recx {p-ople55-2} {a-pc} {t-ople55-2} {i-main}

# Trigger master programmer
p {p-ople55-2} p.Ai


# -- p-opgt55 - send tens digit to mp G stepper, ones digit to H-K
$assert {p-opgt55} {a-ex}~P0000000000

# Send PC subtractively on main, stepping the MP, and receiving in EX.
# Note that EX receives the 10's complement of PC, so will include an extra +1
# from the 1pp. This is undone when sending EX back to PC subtractively next
# cycle.
$sendc {p-opgt55} {a-pc} {t-opgt55} S {p-opgt55-2}
$loadex {p-opgt55}


# -- p-opgt55-2 - send input pulse to master programmer
# Sign of EX must be M to avoid misfiring p-ople55 (triggered from a-ex.S sign)
$assert {p-opgt55-2} {a-ex}~Mxxxxxxxxxx

# EX back to PC, with opcode field (SS) cleared
# Note #1: This is arithmetically incorrect. PC receives the 9's complement of
# EX with 0s in the opcode field, then an extra +1 from the 1pp. If PC were
# Pxx00000000, this would give P0099999999 and the 1pp would cause a carry into
# the opcode field leaving it P01... instead of P00. That can't happen because
# PC.RRRR always begins with 09, 90, or 99, so there's no possibility of a
# carry into digit 9.
# Note #2: EX.S is not connected to d-main. If it were, this would cause
# spurious MP inputs.
$sendcx {p-opgt55-2} {a-ex} {r-opgt55-2} S
$recx {p-opgt55-2} {a-pc} {r-opgt55-2} {i-exS-clearA}

# Trigger master programmer.
p {p-opgt55-2} {p-mp-789x}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# - stimulate FT, goto {p-fetcharg} for argument
# - delay 4 then goto {p-fetchread}

# - clear IR (needed only on jumps, otherwise already zero here from overflow) and delay 4
$clear {p-fetchline} {a-ir} {t-fetchline} {p-fetchread}
s {a-ir}.rp{t-fetchline} 4    # repeat 4 to wait for FT result

# - clear EX as well, it will also receive from FT
$clearx {p-fetchline} {a-ex} {t-fetchline}

# - trigger ft
p {p-fetchline} f1.1i         
s f1.rp1 1                    # send once in r-fetchread
s f1.op1 S0                   # send complement, don't offset argument
s f1.cl1 C                    # pulse on C when done
s f1.A6s S                    # transmit extra +1 on A5 to get 100-I1
p f1.C {p-fetcharg}           # goto when ready for argument


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)
$sendx {p-fetcharg} {a-pc} {r-fetcharg} A
p {d-main} f1.arg  # only bottom two digit lines connect so no deleter is required


# -- {p-fetchread} read ft line of instructions
#  - FT sends complement of A and B
#  - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = M I1 00 00 00 00  = A6A5+1 00 00 00 00
#  - PC is unchanged

# B2B1 B4B3 B6B5 A2A1 A4A3+1 -> IR
p f1.A {d-f1A}                      # FIXME in the sim, need output T-s to avoid using extra digit tray
p {d-f1A} ad.permute.{ad-fetchA}
s ad.permute.{ad-fetchA} 0,0,0,0,0,0,0,2,1,4,3
p ad.permute.{ad-fetchA} {d-fetch}

p f1.B ad.permute.{ad-fetchB}
s ad.permute.{ad-fetchB} 11,2,1,4,3,6,5,0,0,0,0
p ad.permute.{ad-fetchB} {d-fetch}

# Increment IR to make the rightmost instruction 100-I2 instead of 99-I2.
$recinc {p-fetchread} {a-ir} {t-fetchread} {i-fetch} {p-fetchread-2}

# A6A5 00 00 00 00  -> EX
p {d-f1A} ad.permute.{ad-fetch-ex}
s ad.permute.{ad-fetch-ex} 11,6,5,0,0,0,0,0,0,0,0
p ad.permute.{ad-fetch-ex} {d-main}

# Get 100-I1 in the top of EX.
$loadex {p-fetchread}


# -- p-fetchread-2: Move first opcode into top of PC to begin execution, inc PC
#  - PC = P I1 xx xx xx pc+1
# Send EX subtractively, as the FT sent I1 subtractively
# then go to p-nofetch to begin execution
$sendx {p-fetchread-2} {a-ex} {t-fetchread-2} S  # t because ran out of r
$recinc {p-fetchread-2} {a-pc} {t-fetchread-2} {i-sendi1} {p-nofetch}


# -- OPCODE IMPLEMENTATIONS --

# XXX debug
defmacro traceop opcode
  $pulseamp {p-op$opcode} {p-clearex-fetch}
  $dump {p-op$opcode} {a-pc}
endmacro


# - HALT -
# Wire halt to quit the simulator so we can run programs and exit when they're
# done.
p {p-op99} debug.quit

# - CLR A -
# RF -> EX
$sendc {p-op35} {a-rf} {t-op35} A {p-op35-2}
$loadex {p-op35}

# EX -clearA-> RF
$storeex {p-op35-2}
$rec {p-op35-2} {a-rf} {t-op35-2} {i-clearA} {p-fetch}


# - INC -
# Send P01000 on d-main
p {p-op53} c.29i
s c.s29 Jr

# Increment A field of RF
# XXX should probably use pulseamp
$rec {p-op53} {a-rf} {t-op53} {i-main} {p-fetch}


# - DEC -
# Send M99000 on d-main
p {p-op55} c.30i
s c.s30 Jl

# Decrement A field of RF
# XXX should probably use pulseamp
$rec {p-op55} {a-rf} {t-op55} {i-main} {p-fetch}


# - PRINT - 
# Save MEM13, RF-printAB->MEM13, restore
# Really the only trick here is that we can only print from a13,
# and during the transfer we shift RF right so we print 0AABB not AABBC

# MEM13->EX, clear
$sendc {p-op96} {a-mem13} {t-op96} A {p-op96-2}
$loadex {p-op96}

# RF-printAB-MEM13. Puts AB in lower 4 digits of upper half of accumulator
$sendx {p-op96-2} {a-rf} {t-op96-2} A    
$rec {p-op96-2} {a-mem13} {t-printAB} {i-printAB} i.pi # trigger print

# prints high half accumulator 13 
s pr.2 P            
p i.po {p-op96-3}

# restore contents of MEM13
$clear {p-op96-3} {a-mem13} {t-mem13} {p-op96-4}

$storeex {p-op96-4}
$rec {p-op96-4} {a-mem13} {t-op96-4} {i-main} {p-fetch}



# -- CURRENT PROGRAM --
include ftdata.easm

# Start the machine
b i
