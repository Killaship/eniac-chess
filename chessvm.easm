# ENIAC-VM for playing chess
# created 2020-3-30 by Jonathan Stray
# This file assembles to a .e suitable file for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

# Accumulator layout

{a-pc}=a1
#    Program counter. A three level stack of 3 digit addresses, current PC on right. 

{a-ir}=a2
#    Instruction register. Holds up to 5 instructions queued to execute after
#    loading from a function table line. Rightmost instruction is next.
#    Instructions are stored in 9's complement form, to make it easy to detect
#    when the register is empty (adding 1 to 9999999999 flips the sign)

{a-ex}=a3
#   "Execution" register. Holds instruction to be executed and sends to decode.
#   Cleared before instruction execute starts, can be used as temp for instruction

{a-reg}=a13
#   (Register File) Registers A-E of the virtual machine. Use a13 so we can print it.

{a-ls}=a4
#   (Load/Store) Registers F-J of the virtual machine.

# Main data bus, used for most transfers
{d-main}=1

# Control cycle
# -------------
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute. 
# The basic pattern is from "Central Control for ENIAC", Adele Goldstine, 1947
# Control lines as follows:
#
# {p-fetch} begin fetch cycle
#      - clear EX
# {p-fetchcheck} do we need to fetch?
#      - discriminate on IR: M to nofetch, P to fetchline
#      - EX = IR
# {p- nofetch} no fetch needed, consume instruction
#      - IR(a2) = EX(a3)>>2 + 1
#      - goto 2-1
# {p-fetchline} no more instructons in IR, load new line from ft
#      - stimulate FT
#      - clear IR (should already be, but we may go to 1-4 after loading PC in jump instructions )
#      - clear EX
#      - delay 4 then goto {p-fetchread}
# {p-fetcharg} ft argument request
#      - FT <- bottom two digits of PC
# {p-fetchread} read ft line of instructions
#      FT sends complement of A and B
#      - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#      - EX = M 99 99 99 99 I1 = 99 99 99 99 A6A5 +1?
#      - PC += 1
#      - goto execute

# define a macro "clear" to clear accumulator acc,
# triggered on inp and emitting outp when done (via transceiver t)
defmacro clear inp acc t outp
p {$inp} {$acc}.{$t}i
s {$acc}.op{$t} 0
s {$acc}.cc{$t} C
p {$acc}.{$t}o {$outp}
endmacro

# -- {p-fetch} begin fetch cycle

# initiate button
p i.io {p-fetch}

# - clear a-ex
$clear {p-fetch} {a-ex} {t-fetch} {p-fetchcheck}

# -- p-fetchcheck: discriminate on IR: M to nofetch, P to fetchline
# During this cycle we both discriminate and read out the contents of IR into EX

# - Send on both ir.A and ir.S so one of two programs gets a pulse
p {p-fetchcheck} {a-ir}.{t-fetchcheck}i
s {a-ir}.op{t-fetchcheck} AS               
s {a-ir}.cc{t-fetchcheck} C   # clear IR after transmission
p {a-ir}.A {d-irA}
p {a-ir}.S {d-irS}

# IR < 0  -> {p-nofetch} via dummy program on a20
p {d-irA} ad.dp.{ad-irA}.11
p ad.dp.{ad-irA}.11 {p-irA}
p {p-irA} a20.{t-irA}i
p a20.{t-irA}o {p-nofetch}

# IR > 0 -> {p-fetchline} via dummy program on a20
p {d-irS} ad.dp.{ad-irS}.11
p ad.dp.{ad-irS}.11 {p-irS}
p {p-irS} a20.{t-irS}i
p a20.{t-irS}o {p-fetchline}

# EX = IR
p {p-fetchcheck} {a-ex}.{r-load-ir}i
s {a-ex}.op{r-load-ir} {i-load-ir}
p {d-irA} {a-ex}.{i-load-ir}



# -- {p-nofetch} no fetch needed, consume instruction
# - IR = EX>>2 + 1
# EX < 0 here so shift will sign-extend 99 into left of IR
# If no more instructions then EX=M 99 99 99 99 99 and adding 1 will overflow
# then goto decode at 5-1

# EX -> main bus
p {p-nofetch} {a-ex}.{t-nofetch}i
s {a-ex}.op{t-nofetch} A
p {a-ex}.A {d-main} 
p {a-ex}.{t-nofetch}o {p-decode}   # goto decode instruction in EX

# main bus >> 2 -> IR
# store shifted instructions back to IR, this deletes just-dispatched opcode
p {p-nofetch} {a-ir}.{r-shifted}i   
p {d-main} ad.s.{ad-irshift}.-2  
p ad.s.{ad-irshift}.-2 {a-ir}.{i-shifted} 
s {a-ir}.op{r-shifted} {i-shifted} 
s {a-ir}.cc{r-shifted} C    # add 1, this is key to detecting no more opcodes



# -- {p-fetchline} no more instructons in IR, load new line from ft
# - stimulate FT, goto {p-fetcharg} for argument
# - delay 4 then goto {p-fetchread}

# - clear IR (not needed? already zero here from overflow?) and delay 4
$clear {p-fetchline} {a-ir} {t-fetchline} {p-fetchread}
s {a-ir}.rp{t-fetchline} 4    # repeat 4 to wait for FT result

# - clear EX as well, it will also receive from FT
p {p-fetchline} {a-ex}.{t-fetchline}i  
s {a-ex}.op{t-fetchline} 0
s {a-ex}.cc{t-fetchline} C

p {p-fetchline} f1.1i         # trigger ft
s f1.rp1 1                    # 1 repeat (neccessary?)
s f1.op1 S0                   # send complement, don't offset argument
s f1.cl1 C                    # pulse on C when done
p f1.C {p-fetcharg}           # goto when ready for argument


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)

# PC -> d2
p {p-fetcharg} {a-pc}.{t-fetcharg}i   
s {a-pc}.op{t-fetcharg} A
p {a-pc}.A 2                  # use d2 not mainbus because we're going through adapter (needed?)
p 2 ad.sd.{ad-fetcharg}.0     # bottom two digits of d2
p ad.sd.{ad-fetcharg}.0 f1.arg


# -- {p-fetchread} read ft line of instructions
#  - FT sends complement of A and B
#  - IR (a2) = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX (a3) = M 99 99 99 99 I1 = 99 99 99 99 A6A5+1
#  - PC (a1) += 1
#  - goto p-decode

p f1.A {d-f1A}
p f1.B {d-f1B}

# build up the re-ordered IR on d5, then d5 -> IR(a2)
# use deleters to prevent sign extension of 9s when isolating opcodes
# Simulator makes this a lot harder than it needs to be... in reality, 
# all this is a single adapter with the pins soldered in permuted order.

p {d-f1A} ad.d.{ad-fr1}.-6          # A4A3
p ad.d.{ad-fr1}.-6 ad.s.{ad-fr2}.-2
p ad.s.{ad-fr2}.-2 {d-main}

p {d-f1A} ad.d.{ad-fr3}.-8          # A2A1
p ad.d.{ad-fr3}.-8 ad.s.{ad-fr4}.2 
p ad.s.{ad-fr4}.2 {d-main}

p {d-f1B} ad.d.{ad-fr5}.-4          # B6B5 digits don't move but must delete other digits
p ad.d.{ad-fr5}.-4 ad.s.{ad-fr6}.-4
p ad.s.{ad-fr6}.-4 ad.s.{ad-fr7}.4
p ad.s.{ad-fr7}.4 {d-main}

p {d-f1B} ad.d.{ad-fr8}.-6          # B4B3
p ad.d.{ad-fr8}.-6 ad.s.{ad-fr9}.-2
p ad.s.{ad-fr9}.-2 ad.s.{ad-fr10}.6
p ad.s.{ad-fr10}.6 {d-main}

p {d-f1B} ad.s.{ad-fr11}.8          # B2B1, don't need to delete left digits b/c we want M sign
p ad.s.{ad-fr11}.8 {d-main}

# B2B1 B4B3 B6B5 A2A1 A4A3+1 -> IR
p {p-fetchread} {a-ir}.{t-fetchread}i   
p {d-main} {a-ir}.{i-fetchread}     
s {a-ir}.op{t-fetchread} {i-fetchread}
s {a-ir}.cc{t-fetchread} C    # +1
p {a-ir}.{t-fetchread}o {p-decode}        # decode

# 99 99 99 99 A6A5+1 -> EX(a3)
p {p-fetchread} {a-ex}.{r-fetchread}i   
p {d-f1A} ad.s.{ad-fr12}.-4         # A>>4 to select first instruction, and pad with 9s
p ad.s.{ad-fr12}.-4 {a-ex}.{i-fetchread}
s {a-ex}.op{r-fetchread} {i-fetchread}
s {a-ex}.cc{r-fetchread} C    # +1

# PC += 1
p {p-fetchread} {a-pc}.{r-increment}i
s {a-pc}.op{r-increment} {i-nothing}    # nothing connected
s {a-pc}.cc{r-increment} C    # +1


# {p-decode} decode instruction in low two digits of EX

# decode magic here

# clear register file
$clear {p-decode} {a-reg} {t-decode} {p-printop}

# EX -> mainbus
p {p-printop} {a-ex}.{t-printop}i   
s {a-ex}.op{t-printop} A
p {a-ex}.{t-printop}o {p-printop2}

# mainbus -> REG
p {p-printop} {a-reg}.{r-printop}i
s {a-reg}.op{r-printop} {i-printop}
p {d-main} ad.d.{ad-printop}.-8 
p ad.d.{ad-printop}.-8 {a-reg}.{i-printop}
#p {d-main} {a-reg}.a

# print "decoded" instruction, it's in a13
p {p-printop2} i.pi 
s pr.2 P
s pr.3 P





# ------------ DATA --------------

# function table values
s f1.RA0L6 0
s f1.RA0L5 1
s f1.RA0L4 0
s f1.RA0L3 2
s f1.RA0L2 0
s f1.RA0L1 3

s f1.RB0L6 0
s f1.RB0L5 4
s f1.RB0L4 0
s f1.RB0L3 5
s f1.RB0L2 0
s f1.RB0L1 6


s f1.RA1L6 1
s f1.RA1L5 1
s f1.RA1L4 1
s f1.RA1L3 2
s f1.RA1L2 1
s f1.RA1L1 3

s f1.RB1L6 1
s f1.RB1L5 4
s f1.RB1L4 1
s f1.RB1L3 5
s f1.RB1L2 1
s f1.RB1L1 6


s f1.RA2L6 2
s f1.RA2L5 1
s f1.RA2L4 2
s f1.RA2L3 2
s f1.RA2L2 2
s f1.RA2L1 3

s f1.RB2L6 2
s f1.RB2L5 4
s f1.RB2L4 2
s f1.RB2L3 5
s f1.RB2L2 2
s f1.RB2L1 6


s f1.RA3L6 3
s f1.RA3L5 1
s f1.RA3L4 3
s f1.RA3L3 2
s f1.RA3L2 3
s f1.RA3L1 3

s f1.RB3L6 3
s f1.RB3L5 4
s f1.RB3L4 3
s f1.RB3L3 5
s f1.RB3L2 3
s f1.RB3L1 6


s f1.RA4L6 4
s f1.RA4L5 1
s f1.RA4L4 4
s f1.RA4L3 2
s f1.RA4L2 4
s f1.RA4L1 3

s f1.RB4L6 4
s f1.RB4L5 4
s f1.RB4L4 4
s f1.RB4L3 5
s f1.RB4L2 4
s f1.RB4L1 6

