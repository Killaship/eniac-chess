# ENIAC-VM for playing chess
# created 2020-3-30 by Jonathan Stray
# This file assembles with easm to a .e file suitable for use with the ENIAC simulator,
# after appending the function table switch settings which contain the chess code.

# Accumulator layout

{a-pc}=a1
#    Program counter. A three level stack of 3 digit addresses, current PC on right. 

{a-ir}=a2
#    Instruction register. Holds up to 5 instructions queued to execute after
#    loading from a function table line. Rightmost instruction is next.
#    Instructions are stored in 9's complement form, to make it easy to detect
#    when the register is empty (adding 1 to 9999999999 flips the sign)

{a-ex}=a3
#   "Execution" register. Holds instruction to be executed and sends to decode.
#   Cleared before instruction execute starts, can be used as temp for instruction

{a-reg}=a13
#   (Register File) Registers A-E of the virtual machine. Use a13 so we can print it.

{a-ls}=a4
#   (Load/Store) Registers F-J of the virtual machine.

# Main data bus, used for most transfers
{d-main}=1

# Control cycle
# -------------
# This is the setup that turns the ENIAC into a CPU: fetch, decode, execute. 
# The basic pattern is from "Central Control for ENIAC", Adele Goldstine, 1947
# Control lines as follows:
#
# {p-fetch} begin fetch cycle
#      - clear EX
# {p-fetchcheck} do we need to fetch?
#      - discriminate on IR: M to nofetch, P to fetchline
#      - EX = IR
# {p-nofetch} no fetch needed, consume instruction
#      - IR(a2) = EX(a3)>>2 + 1
#      - goto 2-1
# {p-fetchline} no more instructons in IR, load new line from ft
#      - stimulate FT
#      - clear IR (should already be, but we may go to 1-4 after loading PC in jump instructions )
#      - clear EX
#      - delay 4 then goto {p-fetchread}
# {p-fetcharg} ft argument request
#      - FT <- bottom two digits of PC
# {p-fetchread} read ft line of instructions
#      FT sends complement of A and B
#      - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#      - EX = M 99 99 99 99 I1 = 99 99 99 99 A6A5 +1?
#      - PC += 1
#      - goto execute

# define a macro "clear" to clear accumulator acc,
# triggered on inp and emitting outp when done (via transceiver t)
defmacro clear inp acc t outp
p {$inp} {$acc}.{$t}i
s {$acc}.op{$t} 0
s {$acc}.cc{$t} C
p {$acc}.{$t}o {$outp}
endmacro

# dummy program definition, with a given delay
defmacro dummy inp acc t delay outp
p {$inp} $acc.{$t}i
s $acc.op{$t} 0
s $acc.rp{$t} $delay
p $acc.{$t}o {$outp}
endmacro


# -- {p-fetch} begin fetch cycle

# initiate button
p i.io {p-fetch}

# - clear a-ex
$clear {p-fetch} {a-ex} {t-fetch} {p-fetchcheck}

# -- p-fetchcheck: discriminate on IR: M to nofetch, P to fetchline
# During this cycle we both discriminate and read out the contents of IR into EX

# - Send on both ir.A and ir.S so one of two programs gets a pulse
p {p-fetchcheck} {a-ir}.{t-fetchcheck}i
s {a-ir}.op{t-fetchcheck} AS               
s {a-ir}.cc{t-fetchcheck} C   # clear IR after transmission
p {a-ir}.A {d-irA}
p {a-ir}.S {d-irS}

# IR < 0  -> {p-nofetch} via dummy program on a20
p {d-irA} ad.dp.{ad-irA}.11
p ad.dp.{ad-irA}.11 a20.{t-irA}i
p a20.{t-irA}o {p-nofetch}

# IR > 0 -> {p-fetchline} via dummy program on a20
p {d-irS} ad.dp.{ad-irS}.11
p ad.dp.{ad-irS}.11 a20.{t-irS}i
p a20.{t-irS}o {p-fetchline}

# EX = IR permuted, I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, assembled on d-ir-to-ex
# This puts the next instruction in the left of EX, ready to discriminate
p {p-fetchcheck} {a-ex}.{r-ir-to-ex}i   
s {a-ex}.op{r-ir-to-ex} {i-ir-to-ex}

# extract IR2,1 and shift to far left. 
p {d-irA} ad.s.{ad-ir-to-ex1}.8
p ad.s.{ad-ir-to-ex1}.8 {d-ir-to-ex}

# Shift the rest right, then drop the first two digits so the sign extend doesn't give 99
p {d-irA} ad.s.{ad-ir-to-ex2}.-2
p ad.s.{ad-ir-to-ex2}.-2 ad.d.{ad-ir-to-ex3}.-2 
p ad.d.{ad-ir-to-ex3}.-2 {d-ir-to-ex}

p {d-ir-to-ex} {a-ex}.{i-ir-to-ex}


# -- {p-nofetch} no fetch needed, begin instruction decode
# EX is now 100-I1 99-I5 99-I4 99-I3 99-I2
# Begin decode by adding 53 to EX, from constant transmitter

# Send 53 from CT to d-main
p {p-nofetch} c.26i 
s c.s26 Klr
s c.k10 5
s c.k9  3 
p c.o {d-main} 

# EX += d-main
p {p-nofetch} {a-ex}.{t-nofetch}i
s {a-ex}.op{t-nofetch} {i-nofetch}
p {d-main} {a-ex}.{i-nofetch}
p {a-ex}.{t-nofetch}o {p-disc-op}


# -- {p-disc-op} discriminate opcode I1>53, to switch between two decode pathways
# EX is now 153-I1 99-I5 99-I4 99-I3 99-I2
# Also store shifted instructions back to IR, this deletes just-dispatched opcode

p {p-disc-op} {a-ex}.{t-disc-op}i
s {a-ex}.op{t-disc-op} AS
p {a-ex}.A {d-exA}
p {a-ex}.S {d-exS}
# no use of transciever output atm

# < 0  -> {p-opgt53}
p {d-exA} ad.dp.{ad-exA}.11
p ad.dp.{ad-exA}.11 a20.{t-exA}i
p a20.{t-exA}o {p-opgt53}

# > 0 -> {p-ople53} via dummy program on a20
p {d-exS} ad.dp.{ad-exS}.11
p ad.dp.{ad-exS}.11 a20.{t-exS}i
p a20.{t-exS}o {p-ople53}

# meanwhile, store EX back into IR, without the instruction we are now decoding
p {p-disc-op} {a-ir}.{r-disc-op}i   
s {a-ir}.op{r-disc-op} {i-disc-op}

# Delete first two digits by shifting EX left 2 then right 2
# This gives M99 if EX<0 at this point, P00 otherwise
p {d-exA} ad.s.{ad-disc-op1}.2   
p ad.s.{ad-disc-op1}.2 ad.s.{ad-disc-op2}.-2 
p ad.s.{ad-disc-op2}.-2 {a-ir}.{i-disc-op}


# -- p-ople53 - decode opcode which is <= 53
# EX = P 153-I1 ...
# Leftmost opcode in IR now P00
# Add M9900000001 so it resets to M but then overflows to P if no more opcodes

p {p-ople53} c.27i 
s c.s27 Jlr
s c.jl M
s c.j10 9
s c.j9  9 
s c.j1  1

p {p-ople53} {a-ir}.{t-plusM99}i
s {a-ir}.op{t-plusM99} {i-plusM99}
p {d-main} {a-ir}.{i-plusM99}

# PLACEHOLDER: send to printer
p {a-ir}.{t-plusM99}o {p-printex}


# -- p-opgt53 - decode opcode which is > 53
# EX = M 153-I1 ...
# Leftmost opcode in IR is now M99
# Add 1 to cause overflow if no more opcodes (roll 9's over to 0)

p {p-opgt53} {a-ir}.{r-plusone}i 
s {a-ir}.op{r-plusone} {i-plusone} # not connected
s {a-ir}.cc{r-plusone} C

# PLACEHOLDER: flip sign and send to printer
$dummy {p-opgt53} a20 {t-opgt53-printex} 1 {p-flipex-printex}


# -- {p-fetchline} no more instructons in IR, load new line from ft
# - stimulate FT, goto {p-fetcharg} for argument
# - delay 4 then goto {p-fetchread}

# - clear IR (not needed? already zero here from overflow?) and delay 4
$clear {p-fetchline} {a-ir} {t-fetchline} {p-fetchread}
s {a-ir}.rp{t-fetchline} 4    # repeat 4 to wait for FT result

# - clear EX as well, it will also receive from FT
p {p-fetchline} {a-ex}.{t-fetchline}i  
s {a-ex}.op{t-fetchline} 0
s {a-ex}.cc{t-fetchline} C

p {p-fetchline} f1.1i         # trigger ft
s f1.rp1 1                    # 1 repeat (neccessary?)
s f1.op1 S0                   # send complement, don't offset argument
s f1.cl1 C                    # pulse on C when done
p f1.C {p-fetcharg}           # goto when ready for argument


# -- {p-fetcharg} ft argument request
# - FT <- bottom two digits of PC (a1)

# PC -> d2
p {p-fetcharg} {a-pc}.{t-fetcharg}i   
s {a-pc}.op{t-fetcharg} A
p {a-pc}.A 2                  # use d2 not mainbus because we're going through adapter (needed?)
p 2 ad.sd.{ad-fetcharg}.0     # bottom two digits of d2
p ad.sd.{ad-fetcharg}.0 f1.arg


# -- {p-fetchread} read ft line of instructions
#  - FT sends complement of A and B
#  - IR = M I6 I5 I4 I3 I2+1 = B2B1 B4B3 B6B5 A2A1 A4A3+1
#  - EX = M I1 00 00 00 00  = A6A5+1 00 00 00 00
#  - PC += 1
#  - goto p-decode

p f1.A {d-f1A}
p f1.B {d-f1B}

# build up the re-ordered IR on d-main
# use deleters to prevent sign extension of 9s when isolating opcodes
# Simulator makes this a lot harder than it needs to be... in reality, 
# all this would be a single adapter with the pins soldered in permuted order.

p {d-f1A} ad.d.{ad-fr1}.-6          # A4A3
p ad.d.{ad-fr1}.-6 ad.s.{ad-fr2}.-2
p ad.s.{ad-fr2}.-2 {d-main}

p {d-f1A} ad.d.{ad-fr3}.-8          # A2A1
p ad.d.{ad-fr3}.-8 ad.s.{ad-fr4}.2 
p ad.s.{ad-fr4}.2 {d-main}

p {d-f1B} ad.d.{ad-fr5}.-4          # B6B5 digits don't move but must delete other digits
p ad.d.{ad-fr5}.-4 ad.s.{ad-fr6}.-4
p ad.s.{ad-fr6}.-4 ad.s.{ad-fr7}.4
p ad.s.{ad-fr7}.4 {d-main}

p {d-f1B} ad.d.{ad-fr8}.-6          # B4B3
p ad.d.{ad-fr8}.-6 ad.s.{ad-fr9}.-2
p ad.s.{ad-fr9}.-2 ad.s.{ad-fr10}.6
p ad.s.{ad-fr10}.6 {d-main}

p {d-f1B} ad.s.{ad-fr11}.8          # B2B1, don't need to delete left digits b/c we want M sign
p ad.s.{ad-fr11}.8 {d-main}

# B2B1 B4B3 B6B5 A2A1 A4A3+1 -> IR
p {p-fetchread} {a-ir}.{t-fetchread}i   
p {d-main} {a-ir}.{i-fetchread}     
s {a-ir}.op{t-fetchread} {i-fetchread}
s {a-ir}.cc{t-fetchread} C    # +1
p {a-ir}.{t-fetchread}o {p-flipex-printex} # should be: goto decode

# A6A5+1 00 00 00 00  -> EX
p {p-fetchread} {a-ex}.{r-fetchread}i   
p {d-f1A} ad.s.{ad-fr12}.-4              # A>>4 to select first instruction
p ad.s.{ad-fr12}.-4 ad.s.{ad-fr13}.8     # then <<8
p ad.s.{ad-fr13}.8 {a-ex}.{i-fetchread}
s {a-ex}.op{r-fetchread} {i-fetchread}
s {a-ex}.cc{r-fetchread} C    # +1

# PC += 1
p {p-fetchread} {a-pc}.{r-increment}i
s {a-pc}.op{r-increment} {i-nothing}    # nothing connected
s {a-pc}.cc{r-increment} C    # +1



# -- {p-flipex-printex} - change sign of EX from M to P, then print
# M9900000001 -> d-main, but we use an adapter to keep only the M
p {p-flipex-printex} c.28i
s c.s28 Jlr

p {p-flipex-printex} {a-ex}.{t-flipex}i
s {a-ex}.op{t-flipex} {i-flipex}
p {d-main} ad.d.{ad-flipex}.0           # keep 0 digits, i.e. sign only
p ad.d.{ad-flipex}.0 {a-ex}.{i-flipex}
p {a-ex}.{t-flipex}o {p-printex} 


# -- {p-printex} print EX and stop

# clear register file
$clear {p-printex} {a-reg} {t-decode} {p-printop}

# EX -> d-exA
p {p-printop} {a-ex}.{t-printop}i   
s {a-ex}.op{t-printop} A
p {a-ex}.{t-printop}o {p-printop2}

# mainbus -> REG
p {p-printop} {a-reg}.{r-printop}i
s {a-reg}.op{r-printop} {i-printop}
p {d-exA} ad.sd.{ad-printop}.8
p ad.sd.{ad-printop}.8 {a-reg}.{i-printop}
#p {d-exA} {a-reg}.a

# print "decoded" instruction, it's in a13
p {p-printop2} i.pi 
s pr.2 P
s pr.3 P





# ------------ DATA --------------

# function table values
s f1.RA0L6 0
s f1.RA0L5 1
s f1.RA0L4 0
s f1.RA0L3 2
s f1.RA0L2 0
s f1.RA0L1 3

s f1.RB0L6 0
s f1.RB0L5 4
s f1.RB0L4 0
s f1.RB0L3 5
s f1.RB0L2 0
s f1.RB0L1 6


s f1.RA1L6 1
s f1.RA1L5 1
s f1.RA1L4 1
s f1.RA1L3 2
s f1.RA1L2 1
s f1.RA1L1 3

s f1.RB1L6 1
s f1.RB1L5 4
s f1.RB1L4 1
s f1.RB1L3 5
s f1.RB1L2 1
s f1.RB1L1 6


s f1.RA2L6 2
s f1.RA2L5 1
s f1.RA2L4 2
s f1.RA2L3 2
s f1.RA2L2 2
s f1.RA2L1 3

s f1.RB2L6 2
s f1.RB2L5 4
s f1.RB2L4 2
s f1.RB2L3 5
s f1.RB2L2 2
s f1.RB2L1 6


s f1.RA3L6 3
s f1.RA3L5 1
s f1.RA3L4 3
s f1.RA3L3 2
s f1.RA3L2 3
s f1.RA3L1 3

s f1.RB3L6 3
s f1.RB3L5 4
s f1.RB3L4 3
s f1.RB3L3 5
s f1.RB3L2 3
s f1.RB3L1 6


s f1.RA4L6 4
s f1.RA4L5 1
s f1.RA4L4 4
s f1.RA4L3 2
s f1.RA4L2 4
s f1.RA4L1 3

s f1.RB4L6 4
s f1.RB4L5 4
s f1.RB4L4 4
s f1.RB4L3 5
s f1.RB4L2 4
s f1.RB4L1 6

