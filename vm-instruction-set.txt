


51 ORDER CODE (v4, extended registers)

00 - nop          ; NB opcodes chosen for indexswap
01 - swap A,B
02 - swap A,C
03 - swap A,D
04 - swap A,E
05 - swap A,F     ? imeplementable??

10 - loadacc A    ; acc A -> FGHIJ
11 - storeacc A   ; FGHIJ -> acc A
12 - swapall      ; ABCDE <-> FGHIJ
13 - scanall      ; destructively search FGHIJ for index of A, to A, -1 if not found
14 - ftload A     ; FGHIJ = ft3[A] first 10 digits
15 - ftlookup A,#XX ; A <- ft3[A+XX] last 2 digits

20 - mov A,B
21 - mov A,C
22 - mov A,D
23 - mov A,E
24 - mov A,F
25 - mov A,G

30 - mov A,H 
31 - mov A,I
32 - mov A,J
33 - 
34 - indexswap    ; next instruction = G%5
35 - clr A

40 - mov A,#XX
41 - mov D,#XX   
42 - mov A,[#XX]
43 - mov A,[B]
44 - mov [#XX],A
45 - indexacc     ; A = 2*B2 + B1>4

50 - inc A
51 - inc B
52 - dec A

70 - add A,D
71 - neg A
72 - sub A,D      ; aka compare
73 - jmp XX       ; within current function table
74 - jmp far XXXX ; to any function table
75 - jmp +A

80 - jn XX        ; jump if A<0 
81 - jz XX        ; jump if A==0
82 - jil XX       ; jump if A is an illegal board square: D2 or D1 is 0 or 9
83 - loop XX      ; dec C; jump if C!=0
84 - jsr XXXX     ; always far
85 - ret

90 - 
91 - read AB
92 - print AB
93 - 
94 - nextline     ; go immediately to line fetch
95 - halt



ACCUMULATOR LAYOUT 
------------------
Typical contents, plus wiring for inputs and outputs


PC:
Current program counter PPPP and return address RRRR, plus a temp SS
layout: SS RRRR PPPP

A - mp steppers, main minus top 2 to clear opcode
S - mp steppers
a - from exA
b - loadim2-irS: I1 XX XX XX XX -> 00 00 00 00 I1, used for JN/JZ/JIL
g - shiftl4-exA, used for JSR
d - from FT, first instruction only
e - shiftl8-irS: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle


IR:
Up to five next instructions, stored as complement so 99 fills in from the left
P0 if empty, otherwise M 99-I6 99-I5 99-I4 99-I3 100-I2

A - d-irA, I6 I5 I4 I3 I2 I1 -> I1 I6 I5 I4 I3 I2, used in control cycle
S - d-irS, I6 I5 I4 I3 I2 I1 -> I1 I6 I5 I4 I3 I2, used in control cycle
AS - fetch discriminate
a - from FT
b - fill99exA: replace top 2 digits with 99, requires EX.PM = M
d - fill99exS: replace top 2 digits with 99, requires EX.PM = P


EX:
General purpose execture register, also used to disc opcode >53
typically: 100-I1 XX XX XX XX 

A - main
S - exS
AS - op discriminate
a - nop
b - clearA: XX XX XX XX XX -> 00 XX XX XX XX, used for MOV A,#X and other writes to A
g - clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
g - clearPC4: XX XX XX 43 21 -> XX XX XX 00 00, used for JMP
e - shiftl4:  XX YY YY 43 32 -> XX 43 21 00 00, used for JSR


RF:
Main register file - use a13 so we can print
layout: PM AA BB CC DD EE

A - main
S - main
a - nop
b - movAB 
g - movAC 
d - movAD
e - clearA: PM XX XX XX XX XX -> P 00 XX XX XX XX, for NEG A


LS:
Secondary register file / load/store accumulator 
layout: FF GG HH II JJ

A - main
S - select A
a-e select?


MEM6:
Discriminate LOADACC
A - main
a - nop
b - A2toPM: move digit 10 into sign, all others zero

MEM7:
load 0-9 / far jump
A - main
S - load 0-9
a - main
b - exA
g - loadim4-irS:  I1 XX XX XX I2 -> 00 00 00 I1 I2

MEM8:
DISCJN:
A = disc JN
S = disc JN
S1-S5 load acc 10-14
a = nop

MEM9:
Discriminate STOREACC
a - main
b - A2toPM: move digit 10 into sign, all others zero

MEM10:
SWAPAX:
A - main
S - store 0-9
a - nop
b-e - SWAP A,x. Always sets PM=P

MEM11:
DISCJZ1
A - main, disc JZ1
S - disc JZ1
S1 - S5 to store 10-14
a - nop
* additional inputs available here 

MEM12:
DISCJZ2:
A - main, disc JZ2
S - disc JZ2
a - main
b - selA (preserve sign)

no MEM13 because RF=a13 so it can be printed

14/15/16 used for MOV A,[FGHIJ]

MEM14:
A - main
S - main, selA, XX XX XX XX XX -> XX 00 00 00 00, used for NEG A
a - nop 
b - clearA: XX XX XX XX XX -> 00 XX XX XX XX
g - selAF: select A/F - select A/F, AA BB CC DD EE -> AA 00 00 00 00
d - selBG: select B/G - select B/G, AA BB CC DD EE -> BB 00 00 00 00

MEM15:
* could discriminate
a - nop
b - clearA: XX XX XX XX XX -> 00 XX XX XX XX
g - selCH: select C/H, AA BB CC DD EE -> CC 00 00 00 00
d - selDI: select D/I, AA BB CC DD EE -> DD 00 00 00 00


MEM16:
* could discriminate
a - main 
b - clearA: XX XX XX XX XX -> 00 XX XX XX XX
g - selEJ: select E/J, AA BB CC DD EE -> EE 00 00 00 00
d - movAE: AA BB CC DD EE -> EE BB CC DD EE


MEM17:
DISCJIL1:
A - main, disc JIL1
S - main, disc JIL1
a - main

MEM18: 
DISCJIL2:
A - main, disc JIL2
S - main, disc JIL2
a - main
b - exA

MEM19:
DISCJIL3:
A - main, disc JIL3
S - main, disc JIL3
a - main
b - exA

MEM20:
DISCJIL4:
A - main, disc JIL4
S - main, disc JIL4


CONTROL CYCLE
-------------

1. clear EX
2. IR -> EX, IR-S-shiftl8->PC, disriminate IR   
  (IR < 0)
  3. EX += 53
  4. EX -fill99exA-> IR, IR+=1, disc EX, clear EX, clear master programmer
    (EX>=0, op<=53)
    5. PC -clearA-> EX, PC-A->master programmer, IR += 99 00 00 00 00 
    6. EX -> PC, PC +=1
    7. operation begins in this add time
  else
    (EX<0, op>53)
    5. PC += offset<<8
    6. PC-S-clearA->EX, PC-S->master programmer 
    7. EX-S->PC, clear EX, PC +=1
    8. operation begins in this add time
else
  3. stim FT
  4. PC->FT
  5. PC += 01 << 8
  6.
  7. FT -> IR,PC,EX
  8. EX += 53
  9. clear mp, IR+=1, clear EX, disc EX (goto 5)


OPCODE MICROPROGRAMS
--------------------

MOV A,[BCD]
1. RF -x-> EX
2. EX -> RF

MOV A,E
1. MEM16 -> EX, clear
2. RF -movAE-> MEM16, clear
3. MEM16 -> RF, clear
4. EX -> MEM16, clear


SWAP A,[BCDE]
1. SWAPAX -> EX, clear
2. RF -x-> SWAPAX, clear
3. SWAPAX -> RF, clear
4. EX->SWAPAX, clear


MOV A,[FGHIJ]
1. MEM14/15/16 -> EX
2. RF -clearA-> MEM14/15/16, clear
3. LS ->selX-> MEM14/15/16
4. MEM14/15/16 -> RF, clear
5. EX -> MEM14/15/16, clear


SWAP A,F
??
M -> EX, clear
LS -sel A-> PC, LS -mask A-> M, clear  ?? PC sel A?
M -> LS, clear
RF -mask A-> M, RF -sel A->LS, clear
M -> RF, PC ->sel A-> RF ?? PC sel A?
EX->M, clear


MOV A,#X
?? need selA input on RF
1. RF -clearA-> EX, clear   
2. EX -> RF, clear
3. IR -S-> EX, clear      # assumes IR<0 so disc is not triggered
4. EX -S-selA-> RF, EX -S-fill99exS-> IR, clear   

The +1 from EX->S both advances 99-I2 to 100-I2 in IR, and converts 100-I1 to I1 in RF
MOV A,#0 will fail because it will overflow a +1 to I2 on previous fetch cycle (100-0 = 100)


CLR A
1. RF -clearA-> EX, clear   
2. EX -> RF, clear


INC A
CT sends P 01 00 00 00 00 -> RF


INC B
?? works unless B=99, then changes sign of A!
1. MEM12 -> EX, clear
2. RF -swapB-> MEM12, clear
3. MEM12 += CT P 01 00 00 00 00
4. MEM12 -> RF, clear
2. RF -swapB-> MEM12, clear
4. MEM12 -> RF, clear
1. EX->MEM12, clear


DEC A
CT sends M 99 00 00 00 00 -> RF


ADD A,D
1. MEM15 -> EX, clear
2. RF -selDI-> MEM15
3. MEM15 -> RF, clear
4. EX->MEM15, clear


SUB A,D
1. MEM15 -> EX, clear
2. RF -S-selDI-> MEM15
3. constant M 01 00 00 00 00 -> MEM15
4. MEM15 -> RF, clear   # movAD must preserve sign!
5. EX->MEM15, clear

{p-subad1}={p-op72}
$tc subad1  mem15  A   nop    ex      subad2
$tc subad2  rf     S   selDI  mem15   subad3
constant M 01 00 00 00 00 -> MEM15, subad4
$tc subad4  mem15  A   nop    rf      subad5
$tc subad5  ex     A   nop    mem15   fetch


NEG A
1. MEM14 -> EX, clear
2. RF -> MEM14, clear
3. MEM14 -clearA-> RF         # clearA must clear sign
4. MEM14 -S-> RF, clear       # S keeps only A and sign
5. RF += P 01 00 00 00 00, EX->MEM14, clear


JMP XXXX 
1. PC ->clearPC4-> EX, clear    # zero current FT,PC
2. EX -> PC, clear
3. MEM7 -> EX, clear
4. IR -S-loadim4-> MEM7         # load next PC
5. MEM7 -> PC, clear
6. EX -> MEM7, clear
goto fetchline


JMP XX
nearjump:                    # maybe an opcode, used as subprogram for conditionals
1. PC -clearPC2-> EX         # zero current PC
2. EX -> PC, clear
3. IR -S-loadim2-irS-> PC    # load next PC
   goto fetchline


JN XX
1. DISCJN->EX, clear
2. RF->DISCJN
3. disc DISCJN, clear
  (A>=0)
  4. EX->DISCJN, clear
  4. IR -S-> EX, clear      # consume operand; assumes IR<0 so disc not triggered
  6. EX -S-fill99exS-> IR, clear 
  (A<0)
  4. EX->DISCJN, clear
     goto nearjump

JZ XX
1. DISCJZ1 -> EX, clear
2. RF -> DISCJZ1
3. disc DISCJZ1, clear
  (X<0)
  4. EX -> DISCJZ1, clear
  goto fetch
  (X>0)
  4. EX -> DISCJZ1, clear
  5. DISCJZ2 -> EX, clear
  6. RF -S-selA-> DISCJZ2
  7  DISCJZ2 += P 01 00 00 00 00
  8. disc DISCJZ2, clear
    (X<0)
    9. EX->DISCJZ2, clear
    goto fetch
    (x>=0)
    9. EX->DISCJZ2, clear
    goto nearjump


JNZ for unsigned values
negate
jump if negative - use subprogram


JIL XX
# Basic idea: both digits need to be not 0 and not 9
# In other words they both need to send a pulse both normally and complemented
# Simplest implementation is to use four discriminate stages, on four accs

1. jump if A1=0 = set PM to P, 9-complement, inc, jump if N
  0 -> 9 -> M0
  1..8 -> 9..2
  9 -> 0 -> 1

2. jump if A1=9 = set PM to M, inc, then jump if P
  0 -> M0 -> M1
  1..8 -> M1..M8 -> M2..M9
  9 -> M9 -> 0

1. JIL1 -> EX
2. RF -S-extendA2Right-inc-> JIL1   ; check A2=0: set PM to P, 9-complement, inc, jump if M
3. discriminate JIL1, clear
  (JIL1<0)
  4. EX -> JIL1, clear
     goto localjmp
(JIL1>=0)
4. EX -> JIL1
5. JIL2 -> EX
6. RF -extendA2Right -> JIL2   ; check A2=9: set PM to M, inc, jump if P
7. constant M0100000000 -> JIL2
8. discriminate JIL2, clear
  (JIL2>=0)
  9. EX -> JIL2, clear
  goto localjmp
(JIL2<0)
10. EX -> JIL2, clear
11. JIL3 -> EX, clear
12. RF -S-extendA1Right-inc-> JIL3   ; check A1=0: set PM to P, 9-complement, inc, jump if M
13. discriminate JIL3, clear
  (JIL3<0)
  14. EX -> JIL3, clear
     goto localjmp
(JIL3>=0)
14. EX -> JIL3, clear
15. JIL4 -> EX , clear
16. RF -extendA1Right -> JIL4   ; check A1=9: set PM to M, inc, jump if P
17. constant M0100000000 -> JIL4
18. discriminate JIL4, clear
  (JIL2>=0)
  19. EX -> JIL4, clear
  goto localjmp
(JIL2<0)
19. EX -> JIL4, clear
goto fetch


JSR XXXX
1. PC ->shiftl4 -> EX, clear    # save current PC
2. EX -> PC, clear
3. MEM7 -> EX, clear
4. IR -S-loadim4-> MEM7         # load next PC
5. MEM7 -> PC, clear
6. EX -> MEM7, clear
goto fetchline


RET
PC -> EX    
EX -shiftr4-> PC      # restore prev PC
goto fetchline



NEXTLINE
goto fetchline


LOADACC A
---------
# accumulator index in A, store result in LS

# start the FT lookup on A1 immediately, setup condition on A2

1. stim FT3, send A2 to MEM9 PM, clear LS
2. send A1 to FT3, discriminate MEM9
  (PM=M, meaning A>=10)
  3. add M0 to MEM9 to restore PM=P, MEM7 -> EX, clear MEM7
  4.
  5. receive A,B into MEM7
  6. transmit MEM7 via S, clear MEM7
  7  main -> LS, EX -> MEM7 via ex-A, clear EX
or 
  (PM=P, meaning A<10)
  3. MEM6 -> EX, clear MEM6
  4.
  5. receive A,B into MEM6
  6. transmit MEM6 via S, clear MEM6
  7. main -> LS, EX -> MEM7 via ex-A, clear EX



STOREACC A
----------
# accumulator index in A, accumulator contents to write in SAVE

# start the FT lookup on A1 immediately, setup condition on A2
1 - ping FT3, send A2 to MEM9 PM, clear LS

2 - send A1 to ft3, discriminate MEM10

# case MEM10 PM=M, meaning A>=10. Control via MEM11
if A2>0 
  3 - add M0 to MEM9 to restore PM=P, EX=MEM11, clear MEM11
  5 - receive A,B into MEM10
  6 - transmit MEM11 via S, clear MEM11
  7 - listen on LS, MEM11=EX

# case MEM10 PM=P, meaning A<10. Control via MEM10
else 
  3 - EX=MEM10, clear MEM10
  5 - receive A,B into MEM10
  6 - transmit MEM10 via S
  7 - listen on LS, MEM10=EX







SAMPLE CODE

; [XX] += [YY]
mov A,[XX]        ; 01
swap A,D          ; 2
mov A,[YY]        ; 34
add A,D           ; 5
mov [XX],A        ; 67


FIND IN ARRAY
; val to find in D
; base addr in B
; array len in C
; return address or -1 in A
top:
 mov a,[b]  ; 00
 sub a,d    ; 11
 jz found   ; 22 33
 inc b      ; 44
 nop        ; 55
 loop top   ; 00 11
 clr a      ; 22
 dec a      ; 33
 ret        ; 44
 nop        ; 55
found:  
 mov a,b    ; 00 
 ret        ; 11



