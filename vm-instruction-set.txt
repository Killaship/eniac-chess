51 ORDER CODE (v4, extended registers)

00 - nop          ; NB opcodes chosen for indexswap
01 - swap A,B
02 - swap A,C
03 - swap A,D
04 - swap A,E
05 - swap A,F     ? imeplementable??

10 - loadacc A    ; acc A -> FGHIJ
11 - storeacc A   ; FGHIJ -> acc A
12 - swapall      ; ABCDE <-> FGHIJ
13 - scanall      ; destructively search FGHIJ for index of A, to A, -1 if not found
14 - ftload A     ; FGHIJ = ft3[A] first 10 digits
15 - ftlookup A,#XX ; A <- ft3[A+XX] last 2 digits

20 - mov B,A
21 - mov C,A
22 - mov D,A
23 - mov E,A
24 - mov F,A
25 - mov G,A

30 - mov H,A 
31 - mov I,A
32 - mov J,A
33 - indexacc     ; A = 2*B2 + B1>4
34 - indexswap    ; next instruction = G%5
35 - clr A

40 - mov XX,A
41 - mov XX,D   
42 - mov [XX],A
43 - mov [B],A
44 - mov A,[XX]
45 - mov A,[B]

50 - (reserved for 9x decode)
51 - (reserved for 8x decode)
52 - inc A
53 - dec A
54 - inc B
55 - (reserved for 7x decode)

70 - add D,A
71 - neg A
72 - sub D,A      ; aka compare
73 - jmp XX       ; within current function table
74 - jmp far XXXX ; to any function table
75 - jmp +A

80 - jn XX        ; jump if A<0 
81 - jz XX        ; jump if A==0
82 - jil XX       ; jump if A is an illegal board square: D2 or D1 is 0 or 9
83 - loop XX      ; dec C; jump if C!=0
84 - jsr XXXX     ; always far
85 - ret

90 - 
91 - read AB
92 - print AB
93 - 
94 - nextline     ; go immediately to line fetch
95 - halt



ACCUMULATOR LAYOUT 
------------------
Typical contents, plus wiring for inputs and outputs


PC:
Current program counter PPPP and return address RRRR, plus a temp SS
layout: SS RRRR PPPP

A - main (to mp steppers, op<=55)
S - main (to mp steppers, op>55; SS field digits swapped)
a - main
b - shiftl8-ir: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
g - clearA: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
d - loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
e - loadPC4: SS RRRR PPPP -> 00 0000 PPPP, used for JMP FAR/JSR


IR:
Up to five next instructions. M0 if empty, otherwise P I6 I5 I4 I3 I2.
99 fills in from the left as instructions are consumed so we can easily detect
an empty IR by adding 1, giving P999... + 1 = M0.

A - d-irA, I6 I5 I4 I3 I2 I1 -> I1 I6 I5 I4 I3 I2, used in control cycle
    also main (digits but not sign)
S - d-irS, I6 I5 I4 I3 I2 I1 -> I1 I6 I5 I4 I3 I2, used in control cycle
AS - fetch discriminate
a - main
b - from FT
g - fill99: replace top 2 digits with 99


EX:
General purpose execution register, also used to disc opcode >55
typically: 100-I1 XX XX XX XX 

A - main
S - exS
AS - op discriminate
a - main
b - rotate irA: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, used in control cycle
g - clearA: XX XX XX XX XX -> 00 XX XX XX XX, used for MOV A,#X and other writes to A
d - clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
e - clearPC4: XX XX XX 43 21 -> XX XX XX 00 00, used for JMP
? - shiftl4:  XX YY YY 43 32 -> XX 43 21 00 00, used for JSR


RF:
Main register file
layout: PM AA BB CC DD EE

A - main
S - main
a - nop
b - selA
g - movAB 
d - movAC
e - clearA: PM XX XX XX XX XX -> P 00 XX XX XX XX, for CLR A, NEG A


LS:
Secondary register file / load/store accumulator 
layout: FF GG HH II JJ

A - main
S - select A
a-e select?


A6
MEM0:
DISCLOADACC:
AS - Discriminate LOADACC
A - main
a - nop
b - loadAccIdx: move digit 10 into sign, digit 9 into 1, all others zero
c - addrToAccIdx: XX B2 B1 XX XX XX -> B2 0 00 00 00 0 B1, used to calc 2*B2 + (B1>4)


A7
MEM1:
DISCSTOREACC:
A - main
AS - Discriminate STOREACC
a - main


A8
MEM2:
LOAD1014:
A - main
S1-S5 load acc 10-14
a = main
b - loadAB: read from FT output


A9
MEM3:
STORE1014:
A - main
S - store acc 10-14
a - main
b - loadAB: read from FT output


A10
MEM4:
SWAPBCD:
a - nop
b-e - swapA[BCDE]


A11
MEM5:
DISCJZ1:
A - main
AS = disc JZ1
a - main


A12
MEM6:
DISCJZ2:
SHIFTPC:
A - main
AS = disc JZ2
a - main
b - extract-pc: XX XX XX PP PP -> 00 00 00 PP PP
g - shiftr4-pc: XX RRRR PPPP -> 00 0000 RRRR
d - shiftl4-pc: XX XXXX PPPP -> XX PPPP 0000


A13
MEM7:
a - main
b - printAB: AA BB CC DD EE -> 0A AB B 0 00 00 for printing AB with leading 0
g - selAF: select A/F, AA BB CC DD EE -> AA 00 00 00 00, used MOV F,A
d - selBG: select B/G, AA BB CC DD EE -> BB 00 00 00 00, used MOV G,A
b - selCH: select C/H, AA BB CC DD EE -> CC 00 00 00 00, used MOV H,A


A14
MEM8:
A - main
a - main
b - selDI: select D/I, AA BB CC DD EE -> DD 00 00 00 00, used MOV I,A
g - selEJ: select E/J, AA BB CC DD EE -> EE 00 00 00 00, used MOV J,A


A15
MEM9:
DISCJN:
AS - disc JN
A - main
S - main, selA, PM XX XX XX XX XX -> PM XX 00 00 00 00, used for NEG A
a - nop 
b - clearA: XX XX XX XX XX -> 00 XX XX XX XX


A16
MEM10:
LOAD09:
load acc 0-9
a - main 
b - loadAB: read from FT output
g - clearA: XX XX XX XX XX -> 00 XX XX XX XX
d - movAE: AA BB CC DD EE -> EE BB CC DD EE


A17
MEM11:
STORE09:
A - main
S - store 0-9
a - main
b - loadAB: read from FT output
e - selA (preserve sign)


A18
MEM12: 
DISCFT1:
A - main
S - discft1
a - main
b - resetPC: sign digit to ftsg1, used to load initial PC
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


A19
MEM13:
DISCFT2:
A - main
S - discft2
a - main
b - exA
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


A20
MEM14:
DISCFT3:
A - main
S - discft3
a - main
b - exA
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


CONTROL CYCLE
-------------
The control loop usually resumes from cycle 1.  It takes 6 cycles to dispatch
instructions from the IR, and 12 cycles to dispatch instructions when we must
load IR from an FT, ignoring the actual instruction time.  NOP takes 0 cycles,
so a program consisting entirely of NOPs takes 6*5+12*1 cycles per 6 NOPs, or 7
cpi.  With 5kHz add cycles this would be about 714 instructions/second.

0. clear EX
1. [p-fetch] IR -> EX, IR-shiftl8->PC,
             discriminate IR (P->p-nofetch-eat-op, M->p-fetchline)
  (IR>=0, p-nofetch-eat-op: triggers both p-nofetch and p-eat-op via pulse amps)
  2. [p-nofetch] EX += 43                     [p-nofetch-eat-op] nop
  3. [p-disc-op] disc EX,                     [p-eat-op] M00000 -fill99-> IR,
                 clear EX,                               EX -fill99-> IR,
                 clear mp                                IR += 1
    (EX>=0, op<=55)                           
    4. [p-oplt55] PC -clearA-> EX,
                  PC-A->master programmer
    5. [p-oplt55] EX -> PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
  else
    (EX<0, op>55)
    4. [p-opgt55] PC-S->EX,
                  PC-S->master programmer
    5. [p-opgt55] EX-S-clearA->PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
else
  2. [p-fetchline]  MEM17-S->dummy, MEM18-S->dummy, MEM19-S->dummy
  3. [p-fetchtrig]  stim FT
  4. [p-fetcharg]   PC->FT
  5. [p-preinc-fetch]  EX += P01..., PC += P01...
  6. wait
  7. [p-fetchread]   FT -> IR,EX,PC, IR += 1, PC += 1
                     goto p-nofetch*

* note this does not trigger p-eat-op so the top of IR is preserved.


CHANGE FT:

The current ft for instruction fetch is selected by the signs of MEM17/18/19,
where P means to fetch from the corresponding ft. Signs are decoded from PC
ftsg only for instructions which may change it,

MEM17.S = P+ftsg2 -> ft 1 (09)  # disable for 90 or 99
MEM18.S = P+ftsg1 -> ft 2 (90)  # disable for 09 or 99
MEM19.S = P+ftsg1+ftsg2 -> ft 3 (99)  # disable for 09 or 90

[p-decode-ftsg]
  1. PC-ftsg2->MEM17, PC-ftsg1->MEM18, PC-ftsg1->MEM19
  2. PC-ftsg2->MEM19

p-decode-ftsg relies on having signs at P initially, and will toggle signs for
disabled fts. So the sequence for changing ft should be:

  A. -> p-decode-ftsg  # (using old ftsg) reset all signs to P
  B. set new ftsg
  C. -> p-decode-ftsg  # select the new ftsg


OPCODE MICROPROGRAMS
--------------------

LOADACC A
# accumulator index in A, store result in LS
# Use function table as a 1-of-10 decoder on A1 (ones digit)
# Use A2 (tens digit) to place ft result in LOAD09 or LOAD1014
# Then S outputs of LOAD09/LOAD1014 trigger a single accumulator to transmit its value

1. DISCLOADACC -> EX, clear, clear LS
2. RF ->loadAccIdx -> DISCLOADACC, stim FT3
3. disc DISCLOADACC, DISCLOADACC -> FT3, clear ; discriminate and send ft arg
  (PM=P, meaning A<10)
  4. EX -> DISCLOADACC, clear
  5. LOAD09 -> EX, clear
  6. receive A,B into LOAD09
  7. send LOAD09 on S, clear                  ; trigger one acc to transmit
  8  main -> LS
  9. EX -> LOAD09, clear                      ; could parallelize with another bus
or 
  (PM=M, meaning A>=10)
  4. EX -> DISCLOADACC, clear
  5. LOAD1014 -> EX, clear
  6. receive A,B into LOAD1014
  7. send LOAD1014 on S, clear
  8. main -> LS,
  9. EX -> LOAD1014, clear 


STOREACC A
# accumulator index in A, accumulator contents to write in SAVE
# Use function table as a 1-of-10 decoder on A1 (ones digit)
# Use A2 (tens digit) to place ft result in STORE09 or STORE1014
# Then S outputs of STORE09/STORE1014 trigger a single accumulator to recieve a value

1. DISCSTOREACC -> EX, clear
2. RF ->storeAccIdx -> DISCSTOREACC, stim FT3
3. send DISCSTOREACC on AS, clear              ; discriminate and send ft arg
  (PM=P, so A<10)
  4. EX -> DISCSTOREACC, clear
  5. STORE09 -> EX, clear
  6. receive A,B into STORE09
  7. send STORE09 on S, clear                  ; trigger one acc to transmit
  8  LS -> main
  9. EX -> STORE09, clear                      ; could parallelize with another bus
or 
  (PM=M, so A>=10)
  4. EX -> DISCSTOREACC, clear
  5. STORE1014 -> EX, clear
  6. receive A,B into STORE1014
  7. send STORE1014 on S, clear
  8. LS -> main
  9. EX -> STORE1014, clear 


LOADNEXT
# acc:word in B:C

# if C1>=4, time to load
RF -checkWord-> LN     ; x xx xx C2C1 xx xx -> C1 00 00 00 00 00
LN += constant P 60 00 00 00 00
disc LN, clear
(LN<0 so C1>=4)                 ; load now
  RF -checkWord2-> LN           ; x xx xx C2C1 xx xx -> C2 00 00 00 00 00
  disc LN, clear
  (LN<0 so C2!=0)               ; this is first load, C2 is +5
    RF -loadC2->LN              ; x xx xx C2C1 xx xx -> 0 00 00 00 00 0C1
    LN += constant P 00 00 00 00 05
    ?? save back to C
  (LN>0 so C2=0)
    RF -loadC2-inc->LN          ; x xx xx C2C1 xx xx -> 0 00 00 00 00 0C1+1
    RF += 00 00 01 00 00        ; faster than storing C1+1 back

  ...
  sub program loadacc
  ...

  RF -> EX, clear                   ; clear A in RF
  EX -clearA-> RF, clear

  # index the word of LS we want, using S outputs of LN
  LN -> EX,clear
  RF -selC1-> LN, stim FT3     ; use B1 to index FT
  LN -> FT3, clear             
  .
  .
  FT3 -loadAB-> LN             
  send LN on S, clear               ; trigger appropriate receive program
  EX -> LOADSEL



MOV A,[B]
# Linearized memory is a riot

# calculate A = 2*B2 + B1>4
RF -> EX, clear                   ; clear A 
EX -clearA-> RF, clear
INDEXACC -> EX, clear
RF -addrToAccIdx-> INDEXACC       ; double B2 in low digits,
RF -addrToAccIdx-> INDEXACC       ; double B1 in digit 10 to overflow if >4
disc INDEXACC
  (M so B1>4)
  inc INDEXACC                    ; result += 1 if B1>4
INDEXACC -shiftL8-> RF, clear     ; store result in A
EX -> INDEXACC

# load the accumulator containing the value
subprogram LOADACC

RF -> EX, clear                   ; clear A in
EX -clearA-> RF, clear

# index the word of LS we want, using S outputs of LOADSEL
LOADSEL -> EX,clear
RF -selB1-> LOADSEL, stim FT3     ; use B1 to index FT
LOADSEL -> FT3, clear             
.
.
FT3 -loadAB-> LOADSEL             
send LOADSEL, clear               ; trigger appropriate receive program
EX -> LOADSEL

# at this point we have one of five different active programs executing
# We have to distribute the reads of ABCDE positions over at least two accs
# because each acc needs a nop input so max 4
# Each program chooses a specific accumulator to work with
LOADSEL_X -> EX
LS -selX-> LOADSEL_X              ; masks and shifts to A position
LOADSEX_X -> RF, clear
EX -> LOADSEL_X, xclear




send LS                           ; value now in A of SELECTREG

LS -> RF, clear                   ; save value

EX -> SELECTREG, clear







  indexacc    ; A = accumulator# with address B
  loadacc A   ; LS = accumulator[A]
  swapall     ; stash RF (in the process, setting G=B)
  indexswap   ; A = ABCDE[G%5]
  swapall     ; restore RF
  mov A, F    ; A = the selected value
  ret


MOV [XX], A
# This is big one, the most complex microprogram in the machine



MOV A,[BCD]
1. RF -x-> EX
2. EX -> RF


MOV A,E
1. MEM16 -> EX, clear
2. RF -movAE-> MEM16, clear
3. MEM16 -> RF, clear
4. EX -> MEM16, clear


SWAP A,[BCDE]
1. SWAPAX -> EX, clear
2. RF -x-> SWAPAX, clear
3. SWAPAX -> RF, clear
4. EX->SWAPAX, clear


MOV A,[FGHIJ]
1. MEM14/15/16 -> EX
2. RF -clearA-> MEM14/15/16, clear
3. LS ->selX-> MEM14/15/16
4. MEM14/15/16 -> RF, clear
5. EX -> MEM14/15/16, clear


SWAP A,F
??
M -> EX, clear
LS -sel A-> PC, LS -mask A-> M, clear  ?? PC sel A?
M -> LS, clear
RF -mask A-> M, RF -sel A->LS, clear
M -> RF, PC ->sel A-> RF ?? PC sel A?
EX->M, clear


MOV A,#X
?? need selA input on RF
1. RF -clearA-> EX, clear   
2. EX -> RF, clear
3. IR -S-> EX, clear      # assumes IR<0 so disc is not triggered
4. EX -S-selA-> RF, EX -S-fill99exS-> IR, clear   

The +1 from EX->S both advances 99-I2 to 100-I2 in IR, and converts 100-I1 to I1 in RF
MOV A,#0 will fail because it will overflow a +1 to I2 on previous fetch cycle (100-0 = 100)


CLR A
1. RF -clearA-> EX, clear   
2. EX -> RF, clear


INC A
CT sends P 01 00 00 00 00 -> RF


INC B
?? works unless B=99, then changes sign of A!
1. MEM12 -> EX, clear
2. RF -swapB-> MEM12, clear
3. MEM12 += CT P 01 00 00 00 00
4. MEM12 -> RF, clear
2. RF -swapB-> MEM12, clear
4. MEM12 -> RF, clear
1. EX->MEM12, clear


DEC A
CT sends M 99 00 00 00 00 -> RF


ADD A,D
1. MEM15 -> EX, clear
2. RF -selDI-> MEM15
3. MEM15 -> RF, clear
4. EX->MEM15, clear


SUB A,D
1. MEM15 -> EX, clear
2. RF -S-selDI-> MEM15
3. constant M 01 00 00 00 00 -> MEM15
4. MEM15 -> RF, clear   # movAD must preserve sign!
5. EX->MEM15, clear

{p-subad1}={p-op72}
$tc subad1  mem15  A   nop    ex      subad2
$tc subad2  rf     S   selDI  mem15   subad3
constant M 01 00 00 00 00 -> MEM15, subad4
$tc subad4  mem15  A   nop    rf      subad5
$tc subad5  ex     A   nop    mem15   fetch


NEG A
1. MEM14 -> EX, clear
2. RF -> MEM14, clear
3. MEM14 -clearA-> RF         # clearA must clear sign
4. MEM14 -S-> RF, clear       # S keeps only A and sign
5. RF += P 01 00 00 00 00, EX->MEM14, clear


JMP XXXX 
1. PC -clearPC4-> EX  $discft-1
2. send PC            $discft-2
3. EX -> PC
4. IR -loadPC4-> PC   $discft-1
5. send IR            $discft-2
goto fetchline


JMP XX
nearjump:                    # maybe an opcode, used as subprogram for conditionals
1. PC -clearPC2-> EX         # zero current PC
2. EX -> PC, clear
3. IR -S-loadim2-irS-> PC    # load next PC
   goto fetchline


JN XX
1. DISCJN->EX, clear
2. RF->DISCJN
3. disc DISCJN, clear
  (A>=0)
  4. EX->DISCJN, clear
  4. IR -S-> EX, clear      # consume operand; assumes IR<0 so disc not triggered
  6. EX -S-fill99exS-> IR, clear 
  (A<0)
  4. EX->DISCJN, clear
     goto nearjump


JZ XX
1. DISCJZ1 -> EX, clear
2. RF -> DISCJZ1
3. disc DISCJZ1, clear
  (X<0)
  4. EX -> DISCJZ1, clear
  goto fetch
  (X>0)
  4. EX -> DISCJZ1, clear
  5. DISCJZ2 -> EX, clear
  6. RF -S-selA-> DISCJZ2
  7  DISCJZ2 += P 01 00 00 00 00
  8. disc DISCJZ2, clear
    (X<0)
    9. EX->DISCJZ2, clear
    goto fetch
    (x>=0)
    9. EX->DISCJZ2, clear
    goto nearjump


JNZ for unsigned values
negate
jump if negative - use subprogram


JIL XX
?? could replace all of this with sign from 00-99 ft lookup

# Basic idea: both digits need to be not 0 and not 9
# In other words they both need to send a pulse both normally and complemented
# Simplest implementation is to use four discriminate stages, on four accs

1. jump if A1=0 = set PM to P, 9-complement, inc, jump if N
  0 -> 9 -> M0
  1..8 -> 9..2
  9 -> 0 -> 1

2. jump if A1=9 = set PM to M, inc, then jump if P
  0 -> M0 -> M1
  1..8 -> M1..M8 -> M2..M9
  9 -> M9 -> 0

1. JIL1 -> EX
2. RF -S-extendA2Right-inc-> JIL1   ; check A2=0: set PM to P, 9-complement, inc, jump if M
3. discriminate JIL1, clear
  (JIL1<0)
  4. EX -> JIL1, clear
     goto localjmp
(JIL1>=0)
4. EX -> JIL1
5. JIL2 -> EX
6. RF -extendA2Right -> JIL2   ; check A2=9: set PM to M, inc, jump if P
7. constant M0100000000 -> JIL2
8. discriminate JIL2, clear
  (JIL2>=0)
  9. EX -> JIL2, clear
  goto localjmp
(JIL2<0)
10. EX -> JIL2, clear
11. JIL3 -> EX, clear
12. RF -S-extendA1Right-inc-> JIL3   ; check A1=0: set PM to P, 9-complement, inc, jump if M
13. discriminate JIL3, clear
  (JIL3<0)
  14. EX -> JIL3, clear
     goto localjmp
(JIL3>=0)
14. EX -> JIL3, clear
15. JIL4 -> EX , clear
16. RF -extendA1Right -> JIL4   ; check A1=9: set PM to M, inc, jump if P
17. constant M0100000000 -> JIL4
18. discriminate JIL4, clear
  (JIL4>=0)
  19. EX -> JIL4, clear
  goto localjmp
(JIL4<0)
19. EX -> JIL4, clear
goto fetch


JSR XXXX
1. SHIFTPC -> EX
2. IR -extract-pc-> SHIFTPC
3. PC -shiftl4-pc-> SHIFTPC  $discft-1
4. send PC                   $discft-2
5. SHIFTPC -> PC             $discft-1
6. send SHIFTPC              $discft-2
 . EX -> SHIFTPC             (parallel with p-fetchline)
goto fetchline


RET
1. SHIFTPC -> EX
2. PC -shiftr4-pc-> SHIFTPC  $discft-1
3. send PC                   $discft-2
4. SHIFTPC -> PC             $discft-1
5. send SHIFTPC              $discft-2
 . EX -> SHIFTPC             (parallel with p-fetchline)


NEXTLINE
goto fetchline







SAMPLE CODE

; [XX] += [YY]
mov A,[XX]        ; 01
swap A,D          ; 2
mov A,[YY]        ; 34
add A,D           ; 5
mov [XX],A        ; 67


FIND IN ARRAY
; val to find in D
; base addr in B
; array len in C
; return address or -1 in A
top:
 mov a,[b]  ; 00
 sub a,d    ; 11
 jz found   ; 22 33
 inc b      ; 44
 nop        ; 55
 loop top   ; 00 11
 clr a      ; 22
 dec a      ; 33
 ret        ; 44
 nop        ; 55
found:  
 mov a,b    ; 00 
 ret        ; 11



