51 ORDER CODE (v4, extended registers)

00 - nop
01 - swap A,B
02 - swap A,C
03 - swap A,D
04 - swap A,E
05 -

10 - loadacc A    ; acc A -> FGHIJ
11 - storeacc A   ; FGHIJ -> acc A
12 - swapall      ; ABCDE <-> FGHIJ
13 -
14 -
15 -

20 - mov B,A
21 - mov C,A
22 - mov D,A
23 - mov E,A
24 - (reserved for future RF<->RF mov)
25 - (reserved for future RF<->RF mov)

30 - mov G,A
31 - mov H,A
32 - mov I,A
33 - mov J,A
34 - mov F,A
35 - (reserved for future LS<->RF mov)

40 - mov XX,A
41 - mov [B],A
42 -
43 -
44 -
45 -

50 - (reserved for 9x decode)
51 - (reserved for 8x decode)
52 - inc A
53 - dec A
54 -
55 - (reserved for 7x decode)

70 - add D,A
71 - add XX,A
72 - sub D,A      ; aka compare
73 - jmp XX       ; within current function table
74 - jmp far XXXX ; to any function table
75 -

80 - jn XX        ; jump if A<0 
81 - jz XX        ; jump if A==0
82 - jil XX       ; jump if A is an illegal board square: D2 or D1 is 0 or 9
83 -
84 - jsr XXXX     ; always far
85 - ret

90 - clr A
91 - read         ; read 5 digits from card into LS (FFGGH)
92 - print        ; print 5 digits from RF (0AABB)
93 -
94 -
95 - halt



ACCUMULATOR LAYOUT 
------------------
Typical contents, plus wiring for inputs and outputs


PC:
Current program counter PPPP and return address RRRR, plus a temp SS which is
usually I1, the next instruction to execute.
layout: SS RRRR PPPP

A - main (to mp steppers, op<=55)
S - main (to mp steppers, op>55; SS field digits swapped)
a - main
b - shiftl8-ir: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
g - clearA: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
d - loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
e - fetch-i1: from FT for instruction fetch


IR:
Up to five next instructions. M0 if empty, otherwise P I6 I5 I4 I3 I2.
99 fills in from the left as instructions are consumed so we can easily detect
an empty IR by adding 1, giving P999... + 1 = M0.

A - d-irA (sign used in control cycle)
    main (digits but not sign)
S - d-irS, used in control cycle
AS - fetch discriminate
a - main
b - from FT
g - fill99: replace top 2 digits with 99


EX:
General purpose execution register, also used to disc opcode >55
typically: 100-I1 XX XX XX XX 

A - d-exA (sign used in control cycle)
    main (digits but not sign)
S - exS, used in control cycle
AS - op discriminate
a - main
b - rotate-ir: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, used in control cycle
g - clearA: S aa bb cc dd ee -> 0 00 bb cc dd ee, used in control cycle and MOV
d - clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
e - fetch-i1: from FT for instruction fetch


RF:
Main register file
layout: PM AA BB CC DD EE

A - main
S - main, deleting PM and digit 1, used for SUB D,A
a - main
b - selectA: X aa XX XX XX XX -> 0 aa 00 00 00 00, used for MOV X,A
g - selDA:   X XX XX XX dd XX -> 0 dd 00 00 00 00, used for ADD D,A
d - selEA:   X XX XX XX XX ee -> 0 ee 00 00 00 00, used for MOV #XX,A


LS:
Secondary register file / load/store accumulator 
layout: FF GG HH II JJ

A - main
a - main
b - signonly: delete all digits, used to preserve sign of DISCFTx in STOREACC


A6
MEM0
DISCMEMCYC
# Discriminate memory cycle 0-9 vs. 10-14
AS - Discriminate memcyc
A - main
a - main
b - splitA: Prepare A for disc A<10, X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1
g - dropsign: used to clear sign of LS in STOREACC


A7
MEM1
MEMCYC1014
A - main
S - trigger memcyc 10-14
a - main
b - ftselacc: read from FT output


A8
MEM2
LOADWORD 
A - main
S - Trigger MOV [FGHIJ],A on S outputs
a - main
b - windexB (word index): X A2A1 XX XX XX XX -> 0 00 00 00 00 0A1
b = accidxB: (acc index): X XX B2B1 XX XX XX -> 0 B2B1 00 00 00 00
g - ftselacc: read from FT output

A9
MEM3
RFTMP
A - main
a - main


A10
MEM4:
A - main
a - main


A11
MEM5:
A - main
a - main


A12
MEM6
NEWPC
A - main
a - main
b - extract-pc: XX XXXX PPPP -> 00 0000 PPPP
g - keep-r:     XX RRRR XXXX -> 00 RRRR 0000
d - shiftr4-pc: XX RRRR PPPP -> 00 0000 RRRR
e - shiftl4-pc: XX XXXX PPPP -> XX PPPP 0000


A13
MEM7
a - main
b - printAB: S aabbX XXXXX -> S 0aabb XXXXX


A14
MEM8
A - main
a - main


A15
MEM9
DISCJX
AS - disc JX
A - main
S - trigger conditional jump/taken
a - main
b - shiftA: used to shift RF A into digits 1+2 for ft arg
g - ftjzsign: get sign for jz discrimination
d - ftjilsign: get sign fo jil discrimination


A16
# Trigger mem cycle 0-9 on S outputs
MEM10
MEMCYC09
A - main
S - trigger memcyc 0-9
a - main 
b - ftselacc: assemble 10 digits from FT output


A17
MEM11:
MOVSWAP:
A - main
a - main
b - movAB: S aa bb XX XX XX -> S bb aa XX XX XX
g - movAC: S aa XX cc XX XX -> S cc XX aa XX XX
d - movAD: S aa XX XX dd XX -> S dd XX XX aa XX
e - movAE: S aa XX XX XX ee -> S ee XX XX XX aa


A18
MEM12: 
DISCFT1:
A - main
S - discft1
a - main
b - resetPC: sign digit to ftsg1, used to load initial PC
g - ftsg1: x xx xx xx xD xx -> PM
d - ftsg2: x xx xx xx Dx xx -> PM


A19
MEM13:
DISCFT2:
A - main
S - discft2
a - main
b - ftsg1: x xx xx xx xD xx -> PM
g - ftsg2: x xx xx xx Dx xx -> PM


A20
MEM14:
DISCFT3:
A - main
S - discft3
a - main
b - ftsg1: x xx xx xx xD xx -> PM
g - ftsg2: x xx xx xx Dx xx -> PM


CONTROL CYCLE
-------------
The control loop usually resumes from cycle 1.  It takes 6 cycles to dispatch
instructions from the IR, and 12 cycles to dispatch instructions when we must
load IR from an FT, ignoring the actual instruction time.  NOP takes 0 cycles,
so a program consisting entirely of NOPs takes 6*5+12*1 cycles per 6 NOPs, or 7
cpi.  With 5kHz add cycles this would be about 714 instructions/second.

1. [p-fetch] IR -> EX, IR-shiftl8->PC,
             discriminate IR (P->p-nofetch-eat-op, M->p-fetchline)
  (IR>=0, p-nofetch-eat-op: triggers both p-nofetch and p-eat-op via pulse amps)
  2. [p-nofetch] EX += 43                     [p-nofetch-eat-op] nop
  3. [p-disc-op] disc EX,                     [p-eat-op] M00000 -fill99-> IR,
                 clear EX,                               EX -fill99-> IR,
                 clear mp                                IR += 1
    (EX>=0, op<=55)                           
    4. [p-oplt55] PC -clearA-> EX,
                  PC-A->master programmer
    5. [p-oplt55] EX -> PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
  else
    (EX<0, op>55)
    4. [p-opgt55] PC-S->EX,
                  PC-S->master programmer
    5. [p-opgt55] EX-S-clearA->PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
else
  2. [p-fetchline]  MEM17-S->dummy, MEM18-S->dummy, MEM19-S->dummy
  3. [p-fetchtrig]  stim FT
  4. [p-fetcharg]   PC->FT
  5. [p-preinc-fetch]  EX += P01..., PC += P01...
  6. wait
  7. [p-fetchread]   FT -> IR,EX,PC, IR += 1, PC += 1
                     goto p-nofetch*

* note this does not trigger p-eat-op so the top of IR is preserved.


CHANGE FT:

The current ft for instruction fetch is selected by the signs of MEM18/19/20,
where P means to fetch from the corresponding ft. Signs are decoded from PC
ftsg only for instructions which may change it,

MEM18.S = P+ftsg2 -> ft 1 (09)  # disable for 90 or 99
MEM19.S = P+ftsg1 -> ft 2 (90)  # disable for 09 or 99
MEM20.S = P+ftsg1+ftsg2 -> ft 3 (99)  # disable for 09 or 90

[p-decode-ftsg]
  1. PC-ftsg2->MEM18, PC-ftsg1->MEM19, PC-ftsg1->MEM20
  2. PC-ftsg2->MEM20

p-decode-ftsg relies on having signs at P initially, and will toggle signs for
disabled fts so that applying it twice is a nop. Hence the sequence for changing is:

  A. -> p-decode-ftsg  # (using old ftsg) reset all signs to P
  B. set new ftsg
  C. -> p-decode-ftsg  # select the new ftsg


OPCODE MICROPROGRAMS
--------------------

LOADACC A
Accumulator index in A, store result in LS
Use function table as a 1-of-10 decoder on A1 (ones digit)
Use A2 (tens digit) to place ft result in MEMCYC09 or MEMCYC1014
Then S outputs of MEMCYC09/MEMCYC1014 trigger a single accumulator to transmit its value

1. DISCMEMCYC -> EX, clear, clear LS
2. RF -splitA-> DISCMEMCYC, X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1, trigger ft3
3. discriminate DISCMEMCYC, send arg, clear
4. EX -> DISCMEMCYC             (ft shadow)

DISCMEMCYC pos, A < 10
  5. MEMCYC09 -> EX, clear        (ft shadow)
  6. FT3 -> MEMCYC09
  7. send MEMCYC09.S, clear, trigger accumulator memory cycle
  8. EX -> MEMCYC09

DISCMEMCYC neg, A >= 10
  5. MEMCYC1014 -> EX, clear        (ft shadow)
  6. FT3 -> MEMCYC1014
  7. send MEMCYC1014.S, clear, trigger accumulator memory cycle
  8. EX -> MEMCYC1014

9. main -> LS
10. LS -> main


STOREACC A
Based on LOADACC. Basic idea is we ignore the memcycle sendc, then send LS for the
rec phase. This replaces accumulator value with LS, instead of vice-versa. Voilla!
Complication is we can't change the sign of destination, as M18-M20 signs
are used for FT decode ("bank switch"). To prevent changes, we store the sign only
during the sendc phase. This also requires clearing LS sign in advance.

1. DISCMEMCYC -> EX, clear
2. LS -dropsign-> DISCMEMCYC  # clears LS.PM
3. DISCMEMCYC -> LS
goto step 2 of LOADACC 
.
. wait 8 cycles
.
11. main -signonly-> LS       # leaves LS contents intact, but saves memacc PM




MOV [B],A (aka LOADWORD)


i-windex = X A2A1 XX XX XX XX -> 0 00 00 00 00 0A1

# Begin word timers
1. loadword -> EX
2. RF -windex-> loadword, trigger ft3
3. loadword -> ft2=3.arg        # usual 10 entry lookup table

4. LS -dropsign-> loadword      # use shadow to clear LS.PM to preserve signs of disftX
5. loadword -> LS

6. ft3 -> loadword
7. send loadword.S              # begin word timers, mod 5 wired
8. EX -> loadword

# Discriminate acc 09 vs 1014
# disclw can't be loadword because loadword S.PM already used
# maybe get around this with mod5 table? but then can't share disclw & accidx arg send
# this sequence very similar to LOADACC/STOREACC, sharable after disc?

9. disclw -> EX               
10. RF -selA-> disclw
11. RF -selA-> disclw, trigger ft3
12. disc disclw, disclw -S-> ft.arg # S: D AW 00 00 00 00 -> X XX XX XX XX 0 9-A
13. EX -> disclw
14. memcyc09/1014 -> EX
15. ft3 -> memcyc09/1014
16. memcyc09/1014 -> S          # trigger acc memcycle
17. EX -> memcyc09/1014

18. memacc -> LS
19. LS -> memacc

20. ...delayed MOV [FGHIJ],A


---
A probably working design -- Update: NOPE
Uses ft2 for word decode, but requires 18 entries
Uses ft3 repeat 5 to delay ft3 output until we can read it
On cycle 6 we use DISCMEMCYC as our temp space, to be able to receive ft2 next cycle

splitA2 is designed to decode acc in top after two ads, word low after one add
X A2A1 XX XX XX XX -> 0 A2A1 00 00 00 0A1 

1. DISCMEMCYC -> EX, clear LS
2. RF -splitA2-> DISCMEMCYC
3. RF -splitA2-> DISCMEMCYC, trigger ft2    # word lookup (0,2,4,6,8)
4. DISCMEMCYC -> ft2.arg, trigger ft3       # word pos, digit 2 may be 1, table with 18 entries?
5. discriminate DISCMEMCYC, -S-> ft3.arg    # 9-acc on digit 10, ft2 shadow

###### blargh S and A will both try to go to main for ft.arg, clash

6. WORDSEL -> DISCMEMCYC                    # ft2 shadow, ft3 shadow

DISCMEMCYC pos, A < 10
  7. ft2 -> WORDSEL                         # ft2 send, ft3 shadow
  8. WORDSEL -> S, trigger ft1/2 dummies    # ft3 send 1
  9. DISCMEMCYC -> WORDSEL                  # ft3 send 2
  10. EX -> DISMEMCYC                       # ft3 send 3
  11. MEMCYC09 -> EX                        # ft3 send 4
  12. FT3 -> MEMCYC09                       # ft3 send 5
  13. send MEMCYC09.S, clear                # trigger accumulator memory cycle
  14. EX -> MEMCYC09

 15. mem -> LS
 16. LS -> mem

Word MOV programs
 17. ...


--

Translate address, then LOADACC, then MOV

The main challenge is temp space for addressing, because we need to rotate
the arg for ft3 which takes two spare accumulators.  We can use LS to manage
this for LOAD, e.g.

Option 1:

# Compute accumulator# 0-14 and 2x word offset 0,2,4,6,8 from [B] into the top
# 3 digits of LS.  This leaves F with the accumulator# and the top of G with 2x
# word offset.
1. clear LS
2. RF -selB-> LS
3. RF -selB-> LS  # LS += 2*0Bb0000000  e.g. 57+57 -> 1140000000

# Lookup 2x word offset (e.g. 04) in ft3, reusing the LOADACC decode table.
# Use this to start a long-running dummy to trigger the appropriate MOV opcode
# to MOV the desired word from LS to A after LOADACC finishes.  The dummies are
# taken from GETWORD.S digits 0,2,4,6,8, and trigger MOV [FGHIJ],A - they
# should probably be FT dummies.

# Trying to reuse mostly the same sequence as LOADACC
4. DISCMEMCYC -> EX, clear
5. LS -splitB-> DISCMEMCYC  # DISCMEMCYC += 000000000b
   trigger ft3
6. DISCMEMCYC -> ft3.arg, clear
7. EX -> DISCMEMCYC (ft shadow)
8. GETWORD -> EX, clear (ft shadow)
9. FT3 -> GETWORD
10. send GETWORD.S, clear, trigger dummies for getword
11. EX -> GETWORD

# This is basically LOADACC except we need to use LS not RF.
12. DISCMEMCYC -> EX, clear
13. LS -splitA-> DISCMEMCYC, clear, trigger ft3  # DISCMEMCYC: PM=A2, 1=A1
14. disc DISCMEMCYC, DISCMEMCYC -> ft3.arg, clear
15. EX -> DISCMEMCYC
16. MEMCYC09/1014 -> EX, clear
17. FT3 -> MEMCYC09/1014
18. send MEMCYC09/1014.S, clear, trigger mem cycle
19. EX -> MEMCYC09/1014
20. memacc -> LS
21. LS -> memacc

# Here the dummy from cycle 10 triggers MOV
22. trigger MOV [FGHIJ],A opcode
(27-8. fetch)

---

Alternatively, perhaps we could wire only the 1s digit of an accum to ft3 arg
via its S output?

# 1. FT3ARG1 -> EX, clear
# 2. RF -selB1-> FT3ARG1
# 3. RF -selB1-> FT3ARG1  # FT3ARG1 += 2*000000000b  e.g. 07+07 -> 0000000014
#    trigger ft3
# 4. FT3ARG1.S -> ft3.arg, clear  # NB only connects digit 1
# 5. EX -> FT3ARG1 (ft shadow)
# 6. GETWORD -> EX (ft shadow)
# 7. FT3 -> GETWORD
# 8. send GETWORD.S, clear, trigger dummies for getword
# 9. EX -> GETWORD

It's a bit more nuanced to do the same trick for DISCMEMCYC.10 -> ft3.arg
because the S output is wired for discrimination, but it should be possible.

# 10. DISCMEMCYC -> EX, clear
# 11. RF -selB-> DISCMEMCYC, clear
# 12. RF -selB-> DISCMEMCYC, clear  # DMC += 2*Bb00000000  e.g. 57+57 -> M 1400000000
# 13. discriminate DISCMEMCYC, trigger ft3
#
# DISCMEMCYC pos, A < 10
#   14. DISCMEMCYC += M00000   # set sign to M send on S does not trigger disc
#   15. DISCMEMCYC.S -> ft3.arg, clear
#   16. EX -> DISCMEMCYC             (ft shadow)
#   17. MEMCYC09 -> EX, clear        (ft shadow)
#   18. FT3 -> MEMCYC09
#   19. send MEMCYC09.S, clear, trigger accumulator memory cycle
#   20. main -> LS
#   21. LS -> main
#   22. EX -> MEMCYC09



MOV A,[B]  (aka STORE)
# Reuse MOV [B],A to find the correct accumulator and word offset, but instead
# of GETWORD, decode into PUTWORD.  This triggers sequences for MOVSTORE
# A,[FGHIJ] following LOADACC.  These sequences perform a MOV and then
# immediately tail call STOREACC.
#
# XXX A problem here is where to compute the address for STOREACC.  Likely
# requires the option 2 rewiring hack.


MOV [BCDE],A and MOV [FGHIJ],A
(Shared with SWAP)
1. $clearA-1
2. $clearA-2
3. MOVSWAP -> EX
4. (RF or LS) -movswap[BCDE]-> MOVSWAP
5. MOVSWAP -selectA-> RF
6. EX -> MOVSWAP


SWAP A,[BCDE]
(Shared with MOV)
1. MOVSWAP -> EX
2. RF -movswap[BCDE]-> MOVSWAP
3. MOVSWAP -> RF
4. EX -> MOVSWAP


MOV #XX,A
1. $clearA-1
2. $clearA-2
3. $consume-op-1  -rf-selEA-> RF
4. $consume-op-2


CLR A
1. RF -clearA-> EX, clear   
2. EX -> RF, clear


INC A
CT sends P 01 00 00 00 00 -> RF


DEC A
1. M99000 -> RF


ADD D,A   (A += D)
1. RFTMP -> EX            # can't use EX directly because RF may be -
2. RF -> RFTMP
3. RFTMP -selDA-> RF, clear
4. EX -> RFTMP


SUB D,A   (A -= D, treating D as +)
1. RF.S -> EX             # adapter on S deletes PM and digit 1 (so no 1'p)
2. EX -selDA-> RF, clear  # A += 99-D
3. P01000 -> RF           # A += 100-D
4. M00000 -> RF           # Fix sign (don't have M01 constant)


JMP XXXX 
1. NEWPC -> EX
2. IR -extract-pc -> NEWPC
3. PC -keep-r     -> NEWPC $discft-1
4. (send PC)               $discft-2
5. NEWPC -> PC             $discft-1
6. (send NEWPC)            $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline


JMP XX
nearjump:                    # maybe an opcode, used as subprogram for conditionals
1. PC -clearPC2-> EX         # zero current PC
2. EX -> PC, clear
3. IR -S-loadim2-irS-> PC    # load next PC
   goto fetchline


JN XX
1. DISCJX->EX, clear
2. RF->DISCJX
3. disc DISCJX, clear
  (A>=0)
  4. EX->DISCJX, clear
  5. IR -S-> EX, clear      # consume operand; assumes IR<0 so disc not triggered
  6. EX -S-fill99exS-> IR, clear 
  (A<0)
  4. EX->DISCJX, clear
     goto nearjump


JZ XX   (NB treats M00 as P00)
1. DISCJX -> EX, clear
2. RF -shiftA-> DISCJX, trigger ft2
3. DISCJX -> ft2.arg
4. wait
5. wait
6. ft2.AxxS -> DISCJX
7. goto JN-3


JNZ for unsigned values
negate
jump if negative - use subprogram


JIL XX
1. DISCJX -> EX, clear
2. RF -shiftA-> DISCJX, trigger ft2
3. DISCJX -> ft2.arg
4. wait
5. wait
6. ft2.BxxS -> DISCJX
7. goto JN-3


JSR XXXX
1. NEWPC -> EX
2. IR -extract-pc -> NEWPC
3. PC -shiftl4-pc -> NEWPC  $discft-1
4. (send PC)                $discft-2
5. NEWPC -> PC              $discft-1
6. (send NEWPC)             $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline


RET
1. NEWPC -> EX
2. nop  # because sharing sequence
3. PC -shiftr4-pc -> NEWPC  $discft-1
4. (send PC)                $discft-2
5. NEWPC -> PC              $discft-1
6. (send NEWPC)             $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline






SAMPLE CODE

; [XX] += [YY]
mov A,[XX]        ; 01
swap A,D          ; 2
mov A,[YY]        ; 34
add D,A           ; 5
mov [XX],A        ; 67


FIND IN ARRAY
; val to find in D
; base addr in B
; array len in C
; return address or -1 in A
top:
 mov a,[b]  ; 00
 sub a,d    ; 11
 jz found   ; 22 33
 inc b      ; 44
 nop        ; 55
 loop top   ; 00 11
 clr a      ; 22
 dec a      ; 33
 ret        ; 44
 nop        ; 55
found:  
 mov a,b    ; 00 
 ret        ; 11



