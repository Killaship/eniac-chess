51 ORDER CODE (v4, extended registers)

00 - nop
01 - swap A,B
02 - swap A,C
03 - swap A,D
04 - swap A,E
05 - swap A,F     ? imeplementable??

10 - loadacc A    ; acc A -> FGHIJ
11 - storeacc A   ; FGHIJ -> acc A
12 - swapall      ; ABCDE <-> FGHIJ
13 - scanall      ; destructively search FGHIJ for index of A, to A, -1 if not found
14 - ftload A     ; FGHIJ = ft3[A] first 10 digits
15 - ftlookup A,#XX ; A <- ft3[A+XX] last 2 digits

20 - mov B,A
21 - mov C,A
22 - mov D,A
23 - mov E,A
24 - (reserved for future RF<->RF mov)
25 - (reserved for future RF<->RF mov)

30 - mov G,A
31 - mov H,A
32 - mov I,A
33 - mov J,A
34 - mov F,A
35 - (reserved for future LS<->RF mov)

40 - mov XX,A
41 - mov XX,D   
42 - mov [XX],A
43 - mov [B],A
44 - mov A,[XX]
45 - mov A,[B]

50 - (reserved for 9x decode)
51 - (reserved for 8x decode)
52 - inc A
53 - dec A
54 - inc B
55 - (reserved for 7x decode)

70 - add D,A
71 - neg A
72 - sub D,A      ; aka compare
73 - jmp XX       ; within current function table
74 - jmp far XXXX ; to any function table
75 - jmp +A

80 - jn XX        ; jump if A<0 
81 - jz XX        ; jump if A==0
82 - jil XX       ; jump if A is an illegal board square: D2 or D1 is 0 or 9
83 - loop XX      ; dec C; jump if C!=0
84 - jsr XXXX     ; always far
85 - ret

90 - clr A
91 - read AB
92 - print AB
93 -              ; XXX 3-cycle mov puts MOV F,A here
94 - nextline     ; go immediately to line fetch
95 - halt



ACCUMULATOR LAYOUT 
------------------
Typical contents, plus wiring for inputs and outputs


PC:
Current program counter PPPP and return address RRRR, plus a temp SS which is
usually I1, the next instruction to execute.
layout: SS RRRR PPPP

A - main (to mp steppers, op<=55)
S - main (to mp steppers, op>55; SS field digits swapped)
a - main
b - shiftl8-ir: XX XX XX XX I1 -> I1 00 00 00 00, used in control cycle
g - clearA: XX RRRR PPPP -> 00 RRRR PPPP, wired to EX.S for control cycle
d - loadPC2: SS RRRR PPPP -> 00 0000 00PP, used for JMP/JN/JZ/JIL
e - loadPC4: SS RRRR PPPP -> 00 0000 PPPP, used for JMP FAR


IR:
Up to five next instructions. M0 if empty, otherwise P I6 I5 I4 I3 I2.
99 fills in from the left as instructions are consumed so we can easily detect
an empty IR by adding 1, giving P999... + 1 = M0.

A - d-irA (sign used in control cycle)
    main (digits but not sign)
S - d-irS, used in control cycle
AS - fetch discriminate
a - main
b - from FT
g - fill99: replace top 2 digits with 99


EX:
General purpose execution register, also used to disc opcode >55
typically: 100-I1 XX XX XX XX 

A - d-exA (sign used in control cycle)
    main (digits but not sign)
S - exS, used in control cycle
AS - op discriminate
a - main
b - rotate-ir: I5 I4 I3 I2 I1 -> I1 I5 I4 I3 I2, used in control cycle
g - clearA: aa bb cc dd ee -> 00 bb cc dd ee, used in control cycle
d - clearPC2: XX XX XX XX 21 -> XX XX XX XX 00, used for JN/JZ/JIL
e - clearPC4: XX XX XX 43 21 -> XX XX XX 00 00, used for JMP


RF:
Main register file
layout: PM AA BB CC DD EE

A - main
S - main, deleting PM and digit 1, used for SUB D,A
a - main
b - selBA: XX bb XX XX XX -> bb 00 00 00 00, used for MOV B,A
g - selCA: XX XX cc XX XX -> cc 00 00 00 00, used for MOV C,A
d - selDA: XX XX XX dd XX -> dd 00 00 00 00, used for MOV D,A/ADD D,A
e - selEA: XX XX XX XX ee -> ee 00 00 00 00, used for MOV E,A/MOV #X,A


LS:
Secondary register file / load/store accumulator 
layout: FF GG HH II JJ

A - main
a - main
b - signonly: delete all digits, used to preserve sign of DISCFTx in STOREACC


A6
MEM0:
DISCMEMCYC
# Discriminate memory cycle 0-9 vs. 10-14
AS - Discriminate memcyc
A - main
a - main
b - splitA: Prepare A for disc A<10, X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1
g - dropsign: used to clear sign of LS in STOREACC


A7
MEM1
MEMCYC1014
# Trigger mem cycle 10-14 on S outputs
A - main
S - trigger memcyc 10-14
a - main
b - ftselacc: read from FT output


A8
MEM2:
A - main
a = main


A9
MEM3
A - main
a - main


A10
MEM4:
SWAPBCDE:
a - nop
b-e - swapA[BCDE]


A11
MEM5:
A - main
a - main


A12
MEM6
NEWPC
A - main
a - main
b - extract-pc: XX XXXX PPPP -> 00 0000 PPPP
g - keep-r:     XX RRRR XXXX -> 00 RRRR 0000
d - shiftr4-pc: XX RRRR PPPP -> 00 0000 RRRR
e - shiftl4-pc: XX XXXX PPPP -> XX PPPP 0000


A13
MEM7
a - main
b - printAB: AA BB CC DD EE -> 0A AB B 0 00 00 for printing AB with leading 0


A14
MEM8
A - main
a - main


A15
MEM9
DISCJX
AS - disc JX
A - main
S - trigger conditional jump/taken
a - main
b - shiftA: used to shift RF A into digits 1+2 for ft arg
g - ftjzsign: get sign for jz discrimination


A16
# Trigger mem cycle 0-9 on S outputs
MEM10
MEMCYC09
A - main
S - trigger memcyc 0-9
a - main 
b - ftselacc: assemble 10 digits from FT output
g - shiftr8 - put A in low digits. Used to send A as arg to FT


A17
MEM11:
MOVSWAP:
A - main
a - main
b - clearA: aa bb cc dd ee -> 00 bb cc dd ee
g - selectA: aa XX XX XX XX -> aa 00 00 00 00
e - selA (preserve sign)


A18
MEM12: 
DISCFT1:
A - main
S - discft1
a - main
b - resetPC: sign digit to ftsg1, used to load initial PC
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


A19
MEM13:
DISCFT2:
A - main
S - discft2
a - main
b - exA
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


A20
MEM14:
DISCFT3:
A - main
S - discft3
a - main
b - exA
g - ftsg2: x xx xx xx Dx xx -> PM
d - ftsg1: x xx xx xx xD xx -> PM


CONTROL CYCLE
-------------
The control loop usually resumes from cycle 1.  It takes 6 cycles to dispatch
instructions from the IR, and 12 cycles to dispatch instructions when we must
load IR from an FT, ignoring the actual instruction time.  NOP takes 0 cycles,
so a program consisting entirely of NOPs takes 6*5+12*1 cycles per 6 NOPs, or 7
cpi.  With 5kHz add cycles this would be about 714 instructions/second.

0. clear EX
1. [p-fetch] IR -> EX, IR-shiftl8->PC,
             discriminate IR (P->p-nofetch-eat-op, M->p-fetchline)
  (IR>=0, p-nofetch-eat-op: triggers both p-nofetch and p-eat-op via pulse amps)
  2. [p-nofetch] EX += 43                     [p-nofetch-eat-op] nop
  3. [p-disc-op] disc EX,                     [p-eat-op] M00000 -fill99-> IR,
                 clear EX,                               EX -fill99-> IR,
                 clear mp                                IR += 1
    (EX>=0, op<=55)                           
    4. [p-oplt55] PC -clearA-> EX,
                  PC-A->master programmer
    5. [p-oplt55] EX -> PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
  else
    (EX<0, op>55)
    4. [p-opgt55] PC-S->EX,
                  PC-S->master programmer
    5. [p-opgt55] EX-S-clearA->PC,
                  clear EX,
                  trigger master programmer
    6. (decode)
    7. operation begins in this add time
else
  2. [p-fetchline]  MEM17-S->dummy, MEM18-S->dummy, MEM19-S->dummy
  3. [p-fetchtrig]  stim FT
  4. [p-fetcharg]   PC->FT
  5. [p-preinc-fetch]  EX += P01..., PC += P01...
  6. wait
  7. [p-fetchread]   FT -> IR,EX,PC, IR += 1, PC += 1
                     goto p-nofetch*

* note this does not trigger p-eat-op so the top of IR is preserved.


CHANGE FT:

The current ft for instruction fetch is selected by the signs of MEM18/19/20,
where P means to fetch from the corresponding ft. Signs are decoded from PC
ftsg only for instructions which may change it,

MEM18.S = P+ftsg2 -> ft 1 (09)  # disable for 90 or 99
MEM19.S = P+ftsg1 -> ft 2 (90)  # disable for 09 or 99
MEM20.S = P+ftsg1+ftsg2 -> ft 3 (99)  # disable for 09 or 90

[p-decode-ftsg]
  1. PC-ftsg2->MEM18, PC-ftsg1->MEM19, PC-ftsg1->MEM20
  2. PC-ftsg2->MEM20

p-decode-ftsg relies on having signs at P initially, and will toggle signs for
disabled fts. So the sequence for changing ft should be:

  A. -> p-decode-ftsg  # (using old ftsg) reset all signs to P
  B. set new ftsg
  C. -> p-decode-ftsg  # select the new ftsg


OPCODE MICROPROGRAMS
--------------------

LOADACC A
Accumulator index in A, store result in LS
Use function table as a 1-of-10 decoder on A1 (ones digit)
Use A2 (tens digit) to place ft result in MEMCYC09 or MEMCYC1014
Then S outputs of MEMCYC09/MEMCYC1014 trigger a single accumulator to transmit its value

1. DISCMEMCYC -> EX, clear, clear LS
2. RF -splitA-> DISCMEMCYC, X XX XX XX XX A2A1 -> A2 00 00 00 00 0A1, trigger ft3
3. discriminate DISCMEMCYC, send arg, clear
4. EX -> DISCMEMCYC             (ft shadow)

DISCMEMCYC pos, A < 10
  5. MEMCYC09 -> EX, clear        (ft shadow)
  6. FT3 -> MEMCYC09
  7. send MEMCYC09.S, clear, trigger accumulator memory cycle
  8. EX -> MEMCYC09

DISCMEMCYC neg, A >= 10
  5. MEMCYC1014 -> EX, clear        (ft shadow)
  6. FT3 -> MEMCYC1014
  7. send MEMCYC1014.S, clear, trigger accumulator memory cycle
  8. EX -> MEMCYC1014

9. main -> LS
10. LS -> main


STOREACC A
Based on LOADACC. Basic idea is we ignore the memcycle sendc, then send LS for the
rec phase. This replaces accumulator value with LS, instead of vice-versa. Voilla!
Complication is we can't change the sign of destination, as M18-M20 signs
are used for FT decode ("bank switch"). To prevent changes, we store the sign only
during the sendc phase. This also requires clearing LS sign in advance.

1. DISCMEMCYC -> EX, clear
2. LS -dropsign-> DISCMEMCYC  # clears LS.PM
3. DISCMEMCYC -> LS
goto step 2 of LOADACC 
.
. wait 8 cycles
.
11. main -signonly-> LS       # leaves LS contents intact, but saves memacc PM



LOADNEXT
# acc:word in B:C

# if C1>=4, time to load
RF -checkWord-> LN     ; x xx xx C2C1 xx xx -> C1 00 00 00 00 00
LN += constant P 60 00 00 00 00
disc LN, clear
(LN<0 so C1>=4)                 ; load now
  RF -checkWord2-> LN           ; x xx xx C2C1 xx xx -> C2 00 00 00 00 00
  disc LN, clear
  (LN<0 so C2!=0)               ; this is first load, C2 is +5
    RF -loadC2->LN              ; x xx xx C2C1 xx xx -> 0 00 00 00 00 0C1
    LN += constant P 00 00 00 00 05
    ?? save back to C
  (LN>0 so C2=0)
    RF -loadC2-inc->LN          ; x xx xx C2C1 xx xx -> 0 00 00 00 00 0C1+1
    RF += 00 00 01 00 00        ; faster than storing C1+1 back

  ...
  sub program loadacc
  ...

  RF -> EX, clear                   ; clear A in RF
  EX -clearA-> RF, clear

  # index the word of LS we want, using S outputs of LN
  LN -> EX,clear
  RF -selC1-> LN, stim FT3     ; use B1 to index FT
  LN -> FT3, clear             
  .
  .
  FT3 -loadAB-> LN             
  send LN on S, clear               ; trigger appropriate receive program
  EX -> LOADSEL



MOV [B],A  (aka LOAD)

Translate address, then LOADACC, then MOV

The main challenge is temp space for addressing, because we need to rotate
the arg for ft3 which takes two spare accumulators.  We can use LS to manage
this for LOAD, e.g.

Option 1:

# Compute accumulator# 0-14 and 2x word offset 0,2,4,6,8 from [B] into the top
# 3 digits of LS.  This leaves F with the accumulator# and the top of G with 2x
# word offset.
1. clear LS
2. RF -selB-> LS
3. RF -selB-> LS  # LS += 2*0Bb0000000  e.g. 57+57 -> 1140000000

# Lookup 2x word offset (e.g. 04) in ft3, reusing the LOADACC decode table.
# Use this to start a long-running dummy to trigger the appropriate MOV opcode
# to MOV the desired word from LS to A after LOADACC finishes.  The dummies are
# taken from GETWORD.S digits 0,2,4,6,8, and trigger MOV [FGHIJ],A - they
# should probably be FT dummies.

# Trying to reuse mostly the same sequence as LOADACC
4. DISCMEMCYC -> EX, clear
5. LS -splitB-> DISCMEMCYC  # DISCMEMCYC += 000000000b
   trigger ft3
6. DISCMEMCYC -> ft3.arg, clear
7. EX -> DISCMEMCYC (ft shadow)
8. GETWORD -> EX, clear (ft shadow)
9. FT3 -> GETWORD
10. send GETWORD.S, clear, trigger dummies for getword
11. EX -> GETWORD

# This is basically LOADACC-1/2 except we need to use LS not RF.
12. DISCMEMCYC -> EX, clear
13. LS -splitA-> DISCMEMCYC, clear  # DISCMEMCYC: PM=A2, 1=A1

# Can reuse LOADACC-3 from here on
14-22. LOADACC-3

# Here the dummy from cycle 10 triggers MOV
23. trigger MOV [FGHIJ],A opcode
(27-8. fetch)

---

Alternatively, perhaps we could wire only the 1s digit of an accum to ft3 arg
via its S output?

# 1. FT3ARG1 -> EX, clear
# 2. RF -selB1-> FT3ARG1
# 3. RF -selB1-> FT3ARG1  # FT3ARG1 += 2*000000000b  e.g. 07+07 -> 0000000014
#    trigger ft3
# 4. FT3ARG1.S -> ft3.arg, clear  # NB only connects digit 1
# 5. EX -> FT3ARG1 (ft shadow)
# 6. GETWORD -> EX (ft shadow)
# 7. FT3 -> GETWORD
# 8. send GETWORD.S, clear, trigger dummies for getword
# 9. EX -> GETWORD

It's a bit more nuanced to do the same trick for DISCMEMCYC.10 -> ft3.arg
because the S output is wired for discrimination, but it should be possible.

# 10. DISCMEMCYC -> EX, clear
# 11. RF -selB-> DISCMEMCYC, clear
# 12. RF -selB-> DISCMEMCYC, clear  # DMC += 2*Bb00000000  e.g. 57+57 -> M 1400000000
# 13. discriminate DISCMEMCYC, trigger ft3
#
# DISCMEMCYC pos, A < 10
#   14. DISCMEMCYC += M00000   # set sign to M send on S does not trigger disc
#   15. DISCMEMCYC.S -> ft3.arg, clear
#   16. EX -> DISCMEMCYC             (ft shadow)
#   17. MEMCYC09 -> EX, clear        (ft shadow)
#   18. FT3 -> MEMCYC09
#   19. send MEMCYC09.S, clear, trigger accumulator memory cycle
#   20. main -> LS
#   21. LS -> main
#   22. EX -> MEMCYC09



MOV A,[B]  (aka STORE)
# Reuse MOV [B],A to find the correct accumulator and word offset, but instead
# of GETWORD, decode into PUTWORD.  This triggers sequences for MOVSTORE
# A,[FGHIJ] following LOADACC.  These sequences perform a MOV and then
# immediately tail call STOREACC.
#
# XXX A problem here is where to compute the address for STOREACC.  Likely
# requires the option 2 rewiring hack.


MOV [BCDEFGHIJ],A
Option 1: 3-cycle sequence
1. RF -clearA-> EX
2. EX -> RF, don't clear
3. EX -sel[BCDE]A-> RF, clear
   (or: LS -sel[BCDE]A -> RF, clear EX)
# but needs separate sequence for MOV F,A,
# which is super expensive :(
1. MOVFA -> EX
2. RF -clearA-> MOVFA
3. LS -selectA-> MOVFA
4. MOVFA -> RF
5. EX -> MOVFA
# also not shared with SWAP

Option 2: 6-cycle sequence (works for all regs)
Can share with SWAP
1. $clearA-1
2. $clearA-2
3. MOVSWAP -> EX
4. (RF or LS) -movswap[BCDE]-> MOVSWAP
5. MOVSWAP -selectA-> RF
6. EX -> MOVSWAP


SWAP A,[BCDE]
(Shared with MOV)
1. MOVSWAP -> EX
2. RF -movswap[BCDE]-> MOVSWAP
3. MOVSWAP -> RF
4. EX -> MOVSWAP


SWAP A,F
??
M -> EX, clear
LS -sel A-> PC, LS -mask A-> M, clear  ?? PC sel A?
M -> LS, clear
RF -mask A-> M, RF -sel A->LS, clear
M -> RF, PC ->sel A-> RF ?? PC sel A?
EX->M, clear


MOV A,#X
?? need selA input on RF
1. RF -clearA-> EX, clear   
2. EX -> RF, clear
3. IR -S-> EX, clear      # assumes IR<0 so disc is not triggered
4. EX -S-selA-> RF, EX -S-fill99exS-> IR, clear   

The +1 from EX->S both advances 99-I2 to 100-I2 in IR, and converts 100-I1 to I1 in RF
MOV A,#0 will fail because it will overflow a +1 to I2 on previous fetch cycle (100-0 = 100)


CLR A
1. RF -clearA-> EX, clear   
2. EX -> RF, clear


INC A
CT sends P 01 00 00 00 00 -> RF


INC B
?? works unless B=99, then changes sign of A!
1. MEM12 -> EX, clear
2. RF -swapB-> MEM12, clear
3. MEM12 += CT P 01 00 00 00 00
4. MEM12 -> RF, clear
2. RF -swapB-> MEM12, clear
4. MEM12 -> RF, clear
1. EX->MEM12, clear


DEC A
1. M99000 -> RF


ADD D,A   (A += D)
1. RF -> EX
2. EX -selDA-> RF, clear


SUB D,A   (A -= D, treating D as +)
1. RF.S -> EX             # adapter on S deletes PM and digit 1 (so no 1'p)
2. EX -selDA-> RF, clear  # A += 99-D
3. P01000 -> RF           # A += 100-D
4. M00000 -> RF           # Fix sign (don't have M01 constant)


NEG A
1. MEM14 -> EX, clear
2. RF -> MEM14, clear
3. MEM14 -clearA-> RF         # clearA must clear sign
4. MEM14 -S-> RF, clear       # S keeps only A and sign
5. RF += P 01 00 00 00 00, EX->MEM14, clear


JMP XXXX 
1. NEWPC -> EX
2. IR -extract-pc -> NEWPC
3. PC -keep-r     -> NEWPC $discft-1
4. (send PC)               $discft-2
5. NEWPC -> PC             $discft-1
6. (send NEWPC)            $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline


JMP XX
nearjump:                    # maybe an opcode, used as subprogram for conditionals
1. PC -clearPC2-> EX         # zero current PC
2. EX -> PC, clear
3. IR -S-loadim2-irS-> PC    # load next PC
   goto fetchline


JN XX
1. DISCJX->EX, clear
2. RF->DISCJX
3. disc DISCJX, clear
  (A>=0)
  4. EX->DISCJX, clear
  5. IR -S-> EX, clear      # consume operand; assumes IR<0 so disc not triggered
  6. EX -S-fill99exS-> IR, clear 
  (A<0)
  4. EX->DISCJX, clear
     goto nearjump


JZ XX   (NB treats M00 as P00)
1. DISCJX -> EX, clear
2. RF -shiftA-> DISCJX, trigger ft2
3. DISCJX -> ft2.arg
4. wait
5. wait
6. ft2.AxxS -> DISCJX
7. goto JN-3


JNZ for unsigned values
negate
jump if negative - use subprogram


JIL XX
?? could replace all of this with sign from 00-99 ft lookup

# Basic idea: both digits need to be not 0 and not 9
# In other words they both need to send a pulse both normally and complemented
# Simplest implementation is to use four discriminate stages, on four accs

1. jump if A1=0 = set PM to P, 9-complement, inc, jump if N
  0 -> 9 -> M0
  1..8 -> 9..2
  9 -> 0 -> 1

2. jump if A1=9 = set PM to M, inc, then jump if P
  0 -> M0 -> M1
  1..8 -> M1..M8 -> M2..M9
  9 -> M9 -> 0

1. JIL1 -> EX
2. RF -S-extendA2Right-inc-> JIL1   ; check A2=0: set PM to P, 9-complement, inc, jump if M
3. discriminate JIL1, clear
  (JIL1<0)
  4. EX -> JIL1, clear
     goto localjmp
(JIL1>=0)
4. EX -> JIL1
5. JIL2 -> EX
6. RF -extendA2Right -> JIL2   ; check A2=9: set PM to M, inc, jump if P
7. constant M0100000000 -> JIL2
8. discriminate JIL2, clear
  (JIL2>=0)
  9. EX -> JIL2, clear
  goto localjmp
(JIL2<0)
10. EX -> JIL2, clear
11. JIL3 -> EX, clear
12. RF -S-extendA1Right-inc-> JIL3   ; check A1=0: set PM to P, 9-complement, inc, jump if M
13. discriminate JIL3, clear
  (JIL3<0)
  14. EX -> JIL3, clear
     goto localjmp
(JIL3>=0)
14. EX -> JIL3, clear
15. JIL4 -> EX , clear
16. RF -extendA1Right -> JIL4   ; check A1=9: set PM to M, inc, jump if P
17. constant M0100000000 -> JIL4
18. discriminate JIL4, clear
  (JIL4>=0)
  19. EX -> JIL4, clear
  goto localjmp
(JIL4<0)
19. EX -> JIL4, clear
goto fetch


JSR XXXX
1. NEWPC -> EX
2. IR -extract-pc -> NEWPC
3. PC -shiftl4-pc -> NEWPC  $discft-1
4. (send PC)                $discft-2
5. NEWPC -> PC              $discft-1
6. (send NEWPC)             $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline


RET
1. NEWPC -> EX
2. nop  # because sharing sequence
3. PC -shiftr4-pc -> NEWPC  $discft-1
4. (send PC)                $discft-2
5. NEWPC -> PC              $discft-1
6. (send NEWPC)             $discft-2
goto fetchline
 . EX -> NEWPC  # parallel with p-fetchline


NEXTLINE
goto fetchline







SAMPLE CODE

; [XX] += [YY]
mov A,[XX]        ; 01
swap A,D          ; 2
mov A,[YY]        ; 34
add D,A           ; 5
mov [XX],A        ; 67


FIND IN ARRAY
; val to find in D
; base addr in B
; array len in C
; return address or -1 in A
top:
 mov a,[b]  ; 00
 sub a,d    ; 11
 jz found   ; 22 33
 inc b      ; 44
 nop        ; 55
 loop top   ; 00 11
 clr a      ; 22
 dec a      ; 33
 ret        ; 44
 nop        ; 55
found:  
 mov a,b    ; 00 
 ret        ; 11



