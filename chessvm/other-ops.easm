# -- Other opcodes --
# Implements SWAPALL, PRINT, READ, HALT


# - SWAPALL -
if OP_SWAPALL
# Exchange RF and LS through RFTMP (RF may be negative).

# trigger fetch via ft dummy to save final ts
$ft-dummy {p-opswapall} 5 {p-fetch}

# RFTMP->EX
$sendc {p-opswapall} {a-rftmp} {t-sub-rftmp} A {p-opswapall-2}
$loadex {p-opswapall}

# RF->RFTMP, clear
$sendc-rf {p-opswapall-2}
$rec {p-opswapall-2} {a-rftmp} {t-opswapall-2} {i-main} {p-opswapall-3}

# LS->RF, clear
$pulseamp {p-opswapall-3} {p-sendcls}
$loadrf {p-opswapall-3}
$dummy {p-opswapall-3} {p-opswapall-4}

# RFTMP->LS
$sendc {p-opswapall-4} {a-rftmp} {t-opswapall-4} A {p-opswapall-5}
$pulseamp {p-opswapall-4} {p-recls}

# EX->RFTMP, goto fetch
$storeex {p-opswapall-5}
$recx {p-opswapall-5} {a-rftmp} {x-opswapall-5} {i-main}

endif # OP_SWAPALL


# - PRINT - 
if OP_PRINT

p {p-opprint} i.pi

# prints high half accumulator 13
s pr.2 P
s pr.pm1 2,1
s pr.pm2 2,2
s pr.pm3 2,3
s pr.pm4 2,4

p i.po {p-fetch}

endif # OP_PRINT


# - READ -
if OP_READ

# read in a new card into constant transmitter
# (the assembler will make sure LS is clear)
p {p-opread} i.Ri
$dummy {p-opread} {p-opread-2}

# wait for card to read
p {p-opread-2} i.Rl

# when data is ready, read Al into LS (FFGGH)
# XXX It'd make sense to read 10 digits and replace LS, but ct output wiring
# crosses over the right 5 digits to the left 5 so that we can get four
# constants out of JK switches.  If we were willing to rely on initializing
# constants from a card at reset time, we could get rid of that hack and be
# able to read 10 digits at once here.
p i.Ro {p-opread-3}
$manual-dummy {p-opread-3} a19 {t-opread-3} 1 {p-opread-4}
$manual-dummy {p-opread-3} a20 {t-opread-3} 1 {p-recls}
p {p-opread-4} c.1i
s c.s1 Al
p c.1o {p-fetch}

endif


# - HALT -
# Wire halt to quit the simulator so we can run programs and exit when they're
# done.
# p {p-op95} debug.quit
